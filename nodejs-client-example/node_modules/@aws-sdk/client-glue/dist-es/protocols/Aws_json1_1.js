import { HttpRequest as __HttpRequest } from "@aws-sdk/protocol-http";
import { decorateServiceException as __decorateServiceException, expectBoolean as __expectBoolean, expectInt32 as __expectInt32, expectLong as __expectLong, expectNonNull as __expectNonNull, expectNumber as __expectNumber, expectString as __expectString, limitedParseDouble as __limitedParseDouble, parseEpochTimestamp as __parseEpochTimestamp, serializeFloat as __serializeFloat, throwDefaultError, } from "@aws-sdk/smithy-client";
import { GlueServiceException as __BaseException } from "../models/GlueServiceException";
import { AccessDeniedException, AlreadyExistsException, ConcurrentModificationException, EntityNotFoundException, GlueEncryptionException, IdempotentParameterMismatchException, IllegalSessionStateException, InternalServiceException, InvalidInputException, InvalidStateException, OperationTimeoutException, ResourceNotReadyException, ResourceNumberLimitExceededException, ValidationException, } from "../models/models_0";
import { ConditionCheckFailureException, ConflictException, CrawlerRunningException, PermissionTypeMismatchException, SchedulerTransitioningException, } from "../models/models_1";
import { ConcurrentRunsExceededException, CrawlerNotRunningException, CrawlerStoppingException, IllegalBlueprintStateException, IllegalWorkflowStateException, MLTransformNotReadyException, NoScheduleException, SchedulerNotRunningException, SchedulerRunningException, VersionMismatchException, } from "../models/models_2";
export const serializeAws_json1_1BatchCreatePartitionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.BatchCreatePartition",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1BatchCreatePartitionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1BatchDeleteConnectionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.BatchDeleteConnection",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1BatchDeleteConnectionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1BatchDeletePartitionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.BatchDeletePartition",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1BatchDeletePartitionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1BatchDeleteTableCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.BatchDeleteTable",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1BatchDeleteTableRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1BatchDeleteTableVersionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.BatchDeleteTableVersion",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1BatchDeleteTableVersionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1BatchGetBlueprintsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.BatchGetBlueprints",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1BatchGetBlueprintsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1BatchGetCrawlersCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.BatchGetCrawlers",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1BatchGetCrawlersRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1BatchGetCustomEntityTypesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.BatchGetCustomEntityTypes",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1BatchGetCustomEntityTypesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1BatchGetDataQualityResultCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.BatchGetDataQualityResult",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1BatchGetDataQualityResultRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1BatchGetDevEndpointsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.BatchGetDevEndpoints",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1BatchGetDevEndpointsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1BatchGetJobsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.BatchGetJobs",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1BatchGetJobsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1BatchGetPartitionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.BatchGetPartition",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1BatchGetPartitionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1BatchGetTriggersCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.BatchGetTriggers",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1BatchGetTriggersRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1BatchGetWorkflowsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.BatchGetWorkflows",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1BatchGetWorkflowsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1BatchStopJobRunCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.BatchStopJobRun",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1BatchStopJobRunRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1BatchUpdatePartitionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.BatchUpdatePartition",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1BatchUpdatePartitionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1CancelDataQualityRuleRecommendationRunCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.CancelDataQualityRuleRecommendationRun",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CancelDataQualityRuleRecommendationRunRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1CancelDataQualityRulesetEvaluationRunCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.CancelDataQualityRulesetEvaluationRun",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CancelDataQualityRulesetEvaluationRunRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1CancelMLTaskRunCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.CancelMLTaskRun",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CancelMLTaskRunRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1CancelStatementCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.CancelStatement",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CancelStatementRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1CheckSchemaVersionValidityCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.CheckSchemaVersionValidity",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CheckSchemaVersionValidityInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1CreateBlueprintCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.CreateBlueprint",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateBlueprintRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1CreateClassifierCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.CreateClassifier",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateClassifierRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1CreateConnectionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.CreateConnection",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateConnectionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1CreateCrawlerCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.CreateCrawler",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateCrawlerRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1CreateCustomEntityTypeCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.CreateCustomEntityType",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateCustomEntityTypeRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1CreateDatabaseCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.CreateDatabase",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateDatabaseRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1CreateDataQualityRulesetCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.CreateDataQualityRuleset",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateDataQualityRulesetRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1CreateDevEndpointCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.CreateDevEndpoint",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateDevEndpointRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1CreateJobCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.CreateJob",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateJobRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1CreateMLTransformCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.CreateMLTransform",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateMLTransformRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1CreatePartitionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.CreatePartition",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreatePartitionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1CreatePartitionIndexCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.CreatePartitionIndex",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreatePartitionIndexRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1CreateRegistryCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.CreateRegistry",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateRegistryInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1CreateSchemaCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.CreateSchema",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateSchemaInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1CreateScriptCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.CreateScript",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateScriptRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1CreateSecurityConfigurationCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.CreateSecurityConfiguration",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateSecurityConfigurationRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1CreateSessionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.CreateSession",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateSessionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1CreateTableCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.CreateTable",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateTableRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1CreateTriggerCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.CreateTrigger",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateTriggerRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1CreateUserDefinedFunctionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.CreateUserDefinedFunction",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateUserDefinedFunctionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1CreateWorkflowCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.CreateWorkflow",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1CreateWorkflowRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1DeleteBlueprintCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.DeleteBlueprint",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteBlueprintRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1DeleteClassifierCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.DeleteClassifier",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteClassifierRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1DeleteColumnStatisticsForPartitionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.DeleteColumnStatisticsForPartition",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteColumnStatisticsForPartitionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1DeleteColumnStatisticsForTableCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.DeleteColumnStatisticsForTable",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteColumnStatisticsForTableRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1DeleteConnectionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.DeleteConnection",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteConnectionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1DeleteCrawlerCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.DeleteCrawler",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteCrawlerRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1DeleteCustomEntityTypeCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.DeleteCustomEntityType",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteCustomEntityTypeRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1DeleteDatabaseCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.DeleteDatabase",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteDatabaseRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1DeleteDataQualityRulesetCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.DeleteDataQualityRuleset",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteDataQualityRulesetRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1DeleteDevEndpointCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.DeleteDevEndpoint",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteDevEndpointRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1DeleteJobCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.DeleteJob",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteJobRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1DeleteMLTransformCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.DeleteMLTransform",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteMLTransformRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1DeletePartitionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.DeletePartition",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeletePartitionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1DeletePartitionIndexCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.DeletePartitionIndex",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeletePartitionIndexRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1DeleteRegistryCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.DeleteRegistry",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteRegistryInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1DeleteResourcePolicyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.DeleteResourcePolicy",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteResourcePolicyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1DeleteSchemaCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.DeleteSchema",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteSchemaInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1DeleteSchemaVersionsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.DeleteSchemaVersions",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteSchemaVersionsInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1DeleteSecurityConfigurationCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.DeleteSecurityConfiguration",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteSecurityConfigurationRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1DeleteSessionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.DeleteSession",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteSessionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1DeleteTableCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.DeleteTable",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteTableRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1DeleteTableVersionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.DeleteTableVersion",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteTableVersionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1DeleteTriggerCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.DeleteTrigger",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteTriggerRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1DeleteUserDefinedFunctionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.DeleteUserDefinedFunction",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteUserDefinedFunctionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1DeleteWorkflowCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.DeleteWorkflow",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1DeleteWorkflowRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetBlueprintCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetBlueprint",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetBlueprintRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetBlueprintRunCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetBlueprintRun",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetBlueprintRunRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetBlueprintRunsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetBlueprintRuns",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetBlueprintRunsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetCatalogImportStatusCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetCatalogImportStatus",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetCatalogImportStatusRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetClassifierCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetClassifier",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetClassifierRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetClassifiersCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetClassifiers",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetClassifiersRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetColumnStatisticsForPartitionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetColumnStatisticsForPartition",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetColumnStatisticsForPartitionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetColumnStatisticsForTableCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetColumnStatisticsForTable",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetColumnStatisticsForTableRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetConnectionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetConnection",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetConnectionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetConnectionsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetConnections",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetConnectionsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetCrawlerCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetCrawler",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetCrawlerRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetCrawlerMetricsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetCrawlerMetrics",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetCrawlerMetricsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetCrawlersCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetCrawlers",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetCrawlersRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetCustomEntityTypeCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetCustomEntityType",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetCustomEntityTypeRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetDatabaseCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetDatabase",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetDatabaseRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetDatabasesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetDatabases",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetDatabasesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetDataCatalogEncryptionSettingsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetDataCatalogEncryptionSettings",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetDataCatalogEncryptionSettingsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetDataflowGraphCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetDataflowGraph",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetDataflowGraphRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetDataQualityResultCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetDataQualityResult",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetDataQualityResultRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetDataQualityRuleRecommendationRunCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetDataQualityRuleRecommendationRun",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetDataQualityRuleRecommendationRunRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetDataQualityRulesetCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetDataQualityRuleset",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetDataQualityRulesetRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetDataQualityRulesetEvaluationRunCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetDataQualityRulesetEvaluationRun",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetDataQualityRulesetEvaluationRunRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetDevEndpointCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetDevEndpoint",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetDevEndpointRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetDevEndpointsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetDevEndpoints",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetDevEndpointsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetJobCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetJob",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetJobRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetJobBookmarkCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetJobBookmark",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetJobBookmarkRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetJobRunCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetJobRun",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetJobRunRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetJobRunsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetJobRuns",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetJobRunsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetJobsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetJobs",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetJobsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetMappingCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetMapping",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetMappingRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetMLTaskRunCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetMLTaskRun",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetMLTaskRunRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetMLTaskRunsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetMLTaskRuns",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetMLTaskRunsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetMLTransformCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetMLTransform",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetMLTransformRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetMLTransformsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetMLTransforms",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetMLTransformsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetPartitionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetPartition",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetPartitionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetPartitionIndexesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetPartitionIndexes",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetPartitionIndexesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetPartitionsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetPartitions",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetPartitionsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetPlanCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetPlan",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetPlanRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetRegistryCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetRegistry",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetRegistryInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetResourcePoliciesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetResourcePolicies",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetResourcePoliciesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetResourcePolicyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetResourcePolicy",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetResourcePolicyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetSchemaCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetSchema",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetSchemaInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetSchemaByDefinitionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetSchemaByDefinition",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetSchemaByDefinitionInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetSchemaVersionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetSchemaVersion",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetSchemaVersionInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetSchemaVersionsDiffCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetSchemaVersionsDiff",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetSchemaVersionsDiffInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetSecurityConfigurationCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetSecurityConfiguration",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetSecurityConfigurationRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetSecurityConfigurationsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetSecurityConfigurations",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetSecurityConfigurationsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetSessionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetSession",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetSessionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetStatementCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetStatement",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetStatementRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetTableCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetTable",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetTableRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetTablesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetTables",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetTablesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetTableVersionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetTableVersion",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetTableVersionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetTableVersionsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetTableVersions",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetTableVersionsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetTagsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetTags",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetTagsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetTriggerCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetTrigger",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetTriggerRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetTriggersCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetTriggers",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetTriggersRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetUnfilteredPartitionMetadataCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetUnfilteredPartitionMetadata",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetUnfilteredPartitionMetadataRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetUnfilteredPartitionsMetadataCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetUnfilteredPartitionsMetadata",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetUnfilteredPartitionsMetadataRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetUnfilteredTableMetadataCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetUnfilteredTableMetadata",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetUnfilteredTableMetadataRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetUserDefinedFunctionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetUserDefinedFunction",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetUserDefinedFunctionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetUserDefinedFunctionsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetUserDefinedFunctions",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetUserDefinedFunctionsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetWorkflowCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetWorkflow",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetWorkflowRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetWorkflowRunCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetWorkflowRun",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetWorkflowRunRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetWorkflowRunPropertiesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetWorkflowRunProperties",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetWorkflowRunPropertiesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1GetWorkflowRunsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.GetWorkflowRuns",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1GetWorkflowRunsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1ImportCatalogToGlueCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.ImportCatalogToGlue",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ImportCatalogToGlueRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1ListBlueprintsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.ListBlueprints",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListBlueprintsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1ListCrawlersCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.ListCrawlers",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListCrawlersRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1ListCrawlsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.ListCrawls",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListCrawlsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1ListCustomEntityTypesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.ListCustomEntityTypes",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListCustomEntityTypesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1ListDataQualityResultsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.ListDataQualityResults",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListDataQualityResultsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1ListDataQualityRuleRecommendationRunsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.ListDataQualityRuleRecommendationRuns",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListDataQualityRuleRecommendationRunsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1ListDataQualityRulesetEvaluationRunsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.ListDataQualityRulesetEvaluationRuns",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListDataQualityRulesetEvaluationRunsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1ListDataQualityRulesetsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.ListDataQualityRulesets",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListDataQualityRulesetsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1ListDevEndpointsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.ListDevEndpoints",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListDevEndpointsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1ListJobsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.ListJobs",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListJobsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1ListMLTransformsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.ListMLTransforms",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListMLTransformsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1ListRegistriesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.ListRegistries",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListRegistriesInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1ListSchemasCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.ListSchemas",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListSchemasInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1ListSchemaVersionsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.ListSchemaVersions",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListSchemaVersionsInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1ListSessionsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.ListSessions",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListSessionsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1ListStatementsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.ListStatements",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListStatementsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1ListTriggersCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.ListTriggers",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListTriggersRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1ListWorkflowsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.ListWorkflows",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ListWorkflowsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1PutDataCatalogEncryptionSettingsCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.PutDataCatalogEncryptionSettings",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1PutDataCatalogEncryptionSettingsRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1PutResourcePolicyCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.PutResourcePolicy",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1PutResourcePolicyRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1PutSchemaVersionMetadataCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.PutSchemaVersionMetadata",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1PutSchemaVersionMetadataInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1PutWorkflowRunPropertiesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.PutWorkflowRunProperties",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1PutWorkflowRunPropertiesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1QuerySchemaVersionMetadataCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.QuerySchemaVersionMetadata",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1QuerySchemaVersionMetadataInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1RegisterSchemaVersionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.RegisterSchemaVersion",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1RegisterSchemaVersionInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1RemoveSchemaVersionMetadataCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.RemoveSchemaVersionMetadata",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1RemoveSchemaVersionMetadataInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1ResetJobBookmarkCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.ResetJobBookmark",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ResetJobBookmarkRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1ResumeWorkflowRunCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.ResumeWorkflowRun",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1ResumeWorkflowRunRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1RunStatementCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.RunStatement",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1RunStatementRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1SearchTablesCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.SearchTables",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1SearchTablesRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1StartBlueprintRunCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.StartBlueprintRun",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StartBlueprintRunRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1StartCrawlerCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.StartCrawler",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StartCrawlerRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1StartCrawlerScheduleCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.StartCrawlerSchedule",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StartCrawlerScheduleRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1StartDataQualityRuleRecommendationRunCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.StartDataQualityRuleRecommendationRun",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StartDataQualityRuleRecommendationRunRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1StartDataQualityRulesetEvaluationRunCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.StartDataQualityRulesetEvaluationRun",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StartDataQualityRulesetEvaluationRunRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1StartExportLabelsTaskRunCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.StartExportLabelsTaskRun",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StartExportLabelsTaskRunRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1StartImportLabelsTaskRunCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.StartImportLabelsTaskRun",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StartImportLabelsTaskRunRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1StartJobRunCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.StartJobRun",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StartJobRunRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1StartMLEvaluationTaskRunCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.StartMLEvaluationTaskRun",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StartMLEvaluationTaskRunRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1StartMLLabelingSetGenerationTaskRunCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.StartMLLabelingSetGenerationTaskRun",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StartMLLabelingSetGenerationTaskRunRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1StartTriggerCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.StartTrigger",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StartTriggerRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1StartWorkflowRunCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.StartWorkflowRun",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StartWorkflowRunRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1StopCrawlerCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.StopCrawler",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StopCrawlerRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1StopCrawlerScheduleCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.StopCrawlerSchedule",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StopCrawlerScheduleRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1StopSessionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.StopSession",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StopSessionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1StopTriggerCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.StopTrigger",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StopTriggerRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1StopWorkflowRunCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.StopWorkflowRun",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1StopWorkflowRunRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1TagResourceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.TagResource",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1TagResourceRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1UntagResourceCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.UntagResource",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UntagResourceRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1UpdateBlueprintCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.UpdateBlueprint",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateBlueprintRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1UpdateClassifierCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.UpdateClassifier",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateClassifierRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1UpdateColumnStatisticsForPartitionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.UpdateColumnStatisticsForPartition",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateColumnStatisticsForPartitionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1UpdateColumnStatisticsForTableCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.UpdateColumnStatisticsForTable",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateColumnStatisticsForTableRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1UpdateConnectionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.UpdateConnection",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateConnectionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1UpdateCrawlerCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.UpdateCrawler",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateCrawlerRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1UpdateCrawlerScheduleCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.UpdateCrawlerSchedule",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateCrawlerScheduleRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1UpdateDatabaseCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.UpdateDatabase",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateDatabaseRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1UpdateDataQualityRulesetCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.UpdateDataQualityRuleset",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateDataQualityRulesetRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1UpdateDevEndpointCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.UpdateDevEndpoint",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateDevEndpointRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1UpdateJobCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.UpdateJob",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateJobRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1UpdateJobFromSourceControlCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.UpdateJobFromSourceControl",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateJobFromSourceControlRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1UpdateMLTransformCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.UpdateMLTransform",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateMLTransformRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1UpdatePartitionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.UpdatePartition",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdatePartitionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1UpdateRegistryCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.UpdateRegistry",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateRegistryInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1UpdateSchemaCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.UpdateSchema",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateSchemaInput(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1UpdateSourceControlFromJobCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.UpdateSourceControlFromJob",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateSourceControlFromJobRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1UpdateTableCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.UpdateTable",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateTableRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1UpdateTriggerCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.UpdateTrigger",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateTriggerRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1UpdateUserDefinedFunctionCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.UpdateUserDefinedFunction",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateUserDefinedFunctionRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const serializeAws_json1_1UpdateWorkflowCommand = async (input, context) => {
    const headers = {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": "AWSGlue.UpdateWorkflow",
    };
    let body;
    body = JSON.stringify(serializeAws_json1_1UpdateWorkflowRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
export const deserializeAws_json1_1BatchCreatePartitionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1BatchCreatePartitionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1BatchCreatePartitionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1BatchCreatePartitionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AlreadyExistsException":
        case "com.amazonaws.glue#AlreadyExistsException":
            throw await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "ResourceNumberLimitExceededException":
        case "com.amazonaws.glue#ResourceNumberLimitExceededException":
            throw await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1BatchDeleteConnectionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1BatchDeleteConnectionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1BatchDeleteConnectionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1BatchDeleteConnectionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1BatchDeletePartitionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1BatchDeletePartitionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1BatchDeletePartitionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1BatchDeletePartitionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1BatchDeleteTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1BatchDeleteTableCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1BatchDeleteTableResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1BatchDeleteTableCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "ResourceNotReadyException":
        case "com.amazonaws.glue#ResourceNotReadyException":
            throw await deserializeAws_json1_1ResourceNotReadyExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1BatchDeleteTableVersionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1BatchDeleteTableVersionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1BatchDeleteTableVersionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1BatchDeleteTableVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1BatchGetBlueprintsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1BatchGetBlueprintsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1BatchGetBlueprintsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1BatchGetBlueprintsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1BatchGetCrawlersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1BatchGetCrawlersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1BatchGetCrawlersResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1BatchGetCrawlersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1BatchGetCustomEntityTypesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1BatchGetCustomEntityTypesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1BatchGetCustomEntityTypesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1BatchGetCustomEntityTypesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1BatchGetDataQualityResultCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1BatchGetDataQualityResultCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1BatchGetDataQualityResultResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1BatchGetDataQualityResultCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1BatchGetDevEndpointsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1BatchGetDevEndpointsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1BatchGetDevEndpointsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1BatchGetDevEndpointsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1BatchGetJobsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1BatchGetJobsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1BatchGetJobsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1BatchGetJobsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1BatchGetPartitionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1BatchGetPartitionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1BatchGetPartitionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1BatchGetPartitionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "InvalidStateException":
        case "com.amazonaws.glue#InvalidStateException":
            throw await deserializeAws_json1_1InvalidStateExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1BatchGetTriggersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1BatchGetTriggersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1BatchGetTriggersResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1BatchGetTriggersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1BatchGetWorkflowsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1BatchGetWorkflowsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1BatchGetWorkflowsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1BatchGetWorkflowsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1BatchStopJobRunCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1BatchStopJobRunCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1BatchStopJobRunResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1BatchStopJobRunCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1BatchUpdatePartitionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1BatchUpdatePartitionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1BatchUpdatePartitionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1BatchUpdatePartitionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1CancelDataQualityRuleRecommendationRunCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CancelDataQualityRuleRecommendationRunCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CancelDataQualityRuleRecommendationRunResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1CancelDataQualityRuleRecommendationRunCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1CancelDataQualityRulesetEvaluationRunCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CancelDataQualityRulesetEvaluationRunCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CancelDataQualityRulesetEvaluationRunResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1CancelDataQualityRulesetEvaluationRunCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1CancelMLTaskRunCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CancelMLTaskRunCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CancelMLTaskRunResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1CancelMLTaskRunCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1CancelStatementCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CancelStatementCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CancelStatementResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1CancelStatementCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "IllegalSessionStateException":
        case "com.amazonaws.glue#IllegalSessionStateException":
            throw await deserializeAws_json1_1IllegalSessionStateExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1CheckSchemaVersionValidityCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CheckSchemaVersionValidityCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CheckSchemaVersionValidityResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1CheckSchemaVersionValidityCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1CreateBlueprintCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateBlueprintCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateBlueprintResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1CreateBlueprintCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AlreadyExistsException":
        case "com.amazonaws.glue#AlreadyExistsException":
            throw await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "ResourceNumberLimitExceededException":
        case "com.amazonaws.glue#ResourceNumberLimitExceededException":
            throw await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1CreateClassifierCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateClassifierCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateClassifierResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1CreateClassifierCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AlreadyExistsException":
        case "com.amazonaws.glue#AlreadyExistsException":
            throw await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1CreateConnectionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateConnectionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateConnectionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1CreateConnectionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AlreadyExistsException":
        case "com.amazonaws.glue#AlreadyExistsException":
            throw await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "ResourceNumberLimitExceededException":
        case "com.amazonaws.glue#ResourceNumberLimitExceededException":
            throw await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1CreateCrawlerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateCrawlerCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateCrawlerResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1CreateCrawlerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AlreadyExistsException":
        case "com.amazonaws.glue#AlreadyExistsException":
            throw await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "ResourceNumberLimitExceededException":
        case "com.amazonaws.glue#ResourceNumberLimitExceededException":
            throw await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1CreateCustomEntityTypeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateCustomEntityTypeCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateCustomEntityTypeResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1CreateCustomEntityTypeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "AlreadyExistsException":
        case "com.amazonaws.glue#AlreadyExistsException":
            throw await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context);
        case "IdempotentParameterMismatchException":
        case "com.amazonaws.glue#IdempotentParameterMismatchException":
            throw await deserializeAws_json1_1IdempotentParameterMismatchExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "ResourceNumberLimitExceededException":
        case "com.amazonaws.glue#ResourceNumberLimitExceededException":
            throw await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1CreateDatabaseCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateDatabaseCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateDatabaseResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1CreateDatabaseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AlreadyExistsException":
        case "com.amazonaws.glue#AlreadyExistsException":
            throw await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context);
        case "ConcurrentModificationException":
        case "com.amazonaws.glue#ConcurrentModificationException":
            throw await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "ResourceNumberLimitExceededException":
        case "com.amazonaws.glue#ResourceNumberLimitExceededException":
            throw await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1CreateDataQualityRulesetCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateDataQualityRulesetCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateDataQualityRulesetResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1CreateDataQualityRulesetCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AlreadyExistsException":
        case "com.amazonaws.glue#AlreadyExistsException":
            throw await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "ResourceNumberLimitExceededException":
        case "com.amazonaws.glue#ResourceNumberLimitExceededException":
            throw await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1CreateDevEndpointCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateDevEndpointCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateDevEndpointResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1CreateDevEndpointCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "AlreadyExistsException":
        case "com.amazonaws.glue#AlreadyExistsException":
            throw await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context);
        case "IdempotentParameterMismatchException":
        case "com.amazonaws.glue#IdempotentParameterMismatchException":
            throw await deserializeAws_json1_1IdempotentParameterMismatchExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "ResourceNumberLimitExceededException":
        case "com.amazonaws.glue#ResourceNumberLimitExceededException":
            throw await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.glue#ValidationException":
            throw await deserializeAws_json1_1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1CreateJobCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateJobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateJobResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1CreateJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AlreadyExistsException":
        case "com.amazonaws.glue#AlreadyExistsException":
            throw await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context);
        case "ConcurrentModificationException":
        case "com.amazonaws.glue#ConcurrentModificationException":
            throw await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context);
        case "IdempotentParameterMismatchException":
        case "com.amazonaws.glue#IdempotentParameterMismatchException":
            throw await deserializeAws_json1_1IdempotentParameterMismatchExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "ResourceNumberLimitExceededException":
        case "com.amazonaws.glue#ResourceNumberLimitExceededException":
            throw await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1CreateMLTransformCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateMLTransformCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateMLTransformResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1CreateMLTransformCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "AlreadyExistsException":
        case "com.amazonaws.glue#AlreadyExistsException":
            throw await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context);
        case "IdempotentParameterMismatchException":
        case "com.amazonaws.glue#IdempotentParameterMismatchException":
            throw await deserializeAws_json1_1IdempotentParameterMismatchExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "ResourceNumberLimitExceededException":
        case "com.amazonaws.glue#ResourceNumberLimitExceededException":
            throw await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1CreatePartitionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreatePartitionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreatePartitionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1CreatePartitionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AlreadyExistsException":
        case "com.amazonaws.glue#AlreadyExistsException":
            throw await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "ResourceNumberLimitExceededException":
        case "com.amazonaws.glue#ResourceNumberLimitExceededException":
            throw await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1CreatePartitionIndexCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreatePartitionIndexCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreatePartitionIndexResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1CreatePartitionIndexCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AlreadyExistsException":
        case "com.amazonaws.glue#AlreadyExistsException":
            throw await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "ResourceNumberLimitExceededException":
        case "com.amazonaws.glue#ResourceNumberLimitExceededException":
            throw await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1CreateRegistryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateRegistryCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateRegistryResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1CreateRegistryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "AlreadyExistsException":
        case "com.amazonaws.glue#AlreadyExistsException":
            throw await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context);
        case "ConcurrentModificationException":
        case "com.amazonaws.glue#ConcurrentModificationException":
            throw await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "ResourceNumberLimitExceededException":
        case "com.amazonaws.glue#ResourceNumberLimitExceededException":
            throw await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1CreateSchemaCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateSchemaCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateSchemaResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1CreateSchemaCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "AlreadyExistsException":
        case "com.amazonaws.glue#AlreadyExistsException":
            throw await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context);
        case "ConcurrentModificationException":
        case "com.amazonaws.glue#ConcurrentModificationException":
            throw await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "ResourceNumberLimitExceededException":
        case "com.amazonaws.glue#ResourceNumberLimitExceededException":
            throw await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1CreateScriptCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateScriptCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateScriptResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1CreateScriptCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1CreateSecurityConfigurationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateSecurityConfigurationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateSecurityConfigurationResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1CreateSecurityConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AlreadyExistsException":
        case "com.amazonaws.glue#AlreadyExistsException":
            throw await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "ResourceNumberLimitExceededException":
        case "com.amazonaws.glue#ResourceNumberLimitExceededException":
            throw await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1CreateSessionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateSessionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateSessionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1CreateSessionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "AlreadyExistsException":
        case "com.amazonaws.glue#AlreadyExistsException":
            throw await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context);
        case "IdempotentParameterMismatchException":
        case "com.amazonaws.glue#IdempotentParameterMismatchException":
            throw await deserializeAws_json1_1IdempotentParameterMismatchExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "ResourceNumberLimitExceededException":
        case "com.amazonaws.glue#ResourceNumberLimitExceededException":
            throw await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.glue#ValidationException":
            throw await deserializeAws_json1_1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1CreateTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateTableCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateTableResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1CreateTableCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AlreadyExistsException":
        case "com.amazonaws.glue#AlreadyExistsException":
            throw await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context);
        case "ConcurrentModificationException":
        case "com.amazonaws.glue#ConcurrentModificationException":
            throw await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "ResourceNotReadyException":
        case "com.amazonaws.glue#ResourceNotReadyException":
            throw await deserializeAws_json1_1ResourceNotReadyExceptionResponse(parsedOutput, context);
        case "ResourceNumberLimitExceededException":
        case "com.amazonaws.glue#ResourceNumberLimitExceededException":
            throw await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1CreateTriggerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateTriggerCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateTriggerResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1CreateTriggerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AlreadyExistsException":
        case "com.amazonaws.glue#AlreadyExistsException":
            throw await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context);
        case "ConcurrentModificationException":
        case "com.amazonaws.glue#ConcurrentModificationException":
            throw await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "IdempotentParameterMismatchException":
        case "com.amazonaws.glue#IdempotentParameterMismatchException":
            throw await deserializeAws_json1_1IdempotentParameterMismatchExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "ResourceNumberLimitExceededException":
        case "com.amazonaws.glue#ResourceNumberLimitExceededException":
            throw await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1CreateUserDefinedFunctionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateUserDefinedFunctionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateUserDefinedFunctionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1CreateUserDefinedFunctionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AlreadyExistsException":
        case "com.amazonaws.glue#AlreadyExistsException":
            throw await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "ResourceNumberLimitExceededException":
        case "com.amazonaws.glue#ResourceNumberLimitExceededException":
            throw await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1CreateWorkflowCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1CreateWorkflowCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1CreateWorkflowResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1CreateWorkflowCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AlreadyExistsException":
        case "com.amazonaws.glue#AlreadyExistsException":
            throw await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context);
        case "ConcurrentModificationException":
        case "com.amazonaws.glue#ConcurrentModificationException":
            throw await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "ResourceNumberLimitExceededException":
        case "com.amazonaws.glue#ResourceNumberLimitExceededException":
            throw await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1DeleteBlueprintCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteBlueprintCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteBlueprintResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1DeleteBlueprintCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1DeleteClassifierCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteClassifierCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteClassifierResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1DeleteClassifierCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1DeleteColumnStatisticsForPartitionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteColumnStatisticsForPartitionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteColumnStatisticsForPartitionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1DeleteColumnStatisticsForPartitionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1DeleteColumnStatisticsForTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteColumnStatisticsForTableCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteColumnStatisticsForTableResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1DeleteColumnStatisticsForTableCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1DeleteConnectionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteConnectionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteConnectionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1DeleteConnectionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1DeleteCrawlerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteCrawlerCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteCrawlerResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1DeleteCrawlerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CrawlerRunningException":
        case "com.amazonaws.glue#CrawlerRunningException":
            throw await deserializeAws_json1_1CrawlerRunningExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "SchedulerTransitioningException":
        case "com.amazonaws.glue#SchedulerTransitioningException":
            throw await deserializeAws_json1_1SchedulerTransitioningExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1DeleteCustomEntityTypeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteCustomEntityTypeCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteCustomEntityTypeResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1DeleteCustomEntityTypeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1DeleteDatabaseCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteDatabaseCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteDatabaseResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1DeleteDatabaseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModificationException":
        case "com.amazonaws.glue#ConcurrentModificationException":
            throw await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1DeleteDataQualityRulesetCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteDataQualityRulesetCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteDataQualityRulesetResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1DeleteDataQualityRulesetCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1DeleteDevEndpointCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteDevEndpointCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteDevEndpointResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1DeleteDevEndpointCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1DeleteJobCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteJobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteJobResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1DeleteJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1DeleteMLTransformCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteMLTransformCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteMLTransformResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1DeleteMLTransformCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1DeletePartitionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeletePartitionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeletePartitionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1DeletePartitionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1DeletePartitionIndexCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeletePartitionIndexCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeletePartitionIndexResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1DeletePartitionIndexCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictException":
        case "com.amazonaws.glue#ConflictException":
            throw await deserializeAws_json1_1ConflictExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1DeleteRegistryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteRegistryCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteRegistryResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1DeleteRegistryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ConcurrentModificationException":
        case "com.amazonaws.glue#ConcurrentModificationException":
            throw await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1DeleteResourcePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteResourcePolicyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteResourcePolicyResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1DeleteResourcePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConditionCheckFailureException":
        case "com.amazonaws.glue#ConditionCheckFailureException":
            throw await deserializeAws_json1_1ConditionCheckFailureExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1DeleteSchemaCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteSchemaCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteSchemaResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1DeleteSchemaCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ConcurrentModificationException":
        case "com.amazonaws.glue#ConcurrentModificationException":
            throw await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1DeleteSchemaVersionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteSchemaVersionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteSchemaVersionsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1DeleteSchemaVersionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ConcurrentModificationException":
        case "com.amazonaws.glue#ConcurrentModificationException":
            throw await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1DeleteSecurityConfigurationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteSecurityConfigurationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteSecurityConfigurationResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1DeleteSecurityConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1DeleteSessionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteSessionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteSessionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1DeleteSessionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ConcurrentModificationException":
        case "com.amazonaws.glue#ConcurrentModificationException":
            throw await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context);
        case "IllegalSessionStateException":
        case "com.amazonaws.glue#IllegalSessionStateException":
            throw await deserializeAws_json1_1IllegalSessionStateExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1DeleteTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteTableCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteTableResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1DeleteTableCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModificationException":
        case "com.amazonaws.glue#ConcurrentModificationException":
            throw await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "ResourceNotReadyException":
        case "com.amazonaws.glue#ResourceNotReadyException":
            throw await deserializeAws_json1_1ResourceNotReadyExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1DeleteTableVersionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteTableVersionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteTableVersionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1DeleteTableVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1DeleteTriggerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteTriggerCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteTriggerResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1DeleteTriggerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModificationException":
        case "com.amazonaws.glue#ConcurrentModificationException":
            throw await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1DeleteUserDefinedFunctionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteUserDefinedFunctionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteUserDefinedFunctionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1DeleteUserDefinedFunctionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1DeleteWorkflowCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1DeleteWorkflowCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1DeleteWorkflowResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1DeleteWorkflowCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModificationException":
        case "com.amazonaws.glue#ConcurrentModificationException":
            throw await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetBlueprintCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetBlueprintCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetBlueprintResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetBlueprintCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetBlueprintRunCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetBlueprintRunCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetBlueprintRunResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetBlueprintRunCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetBlueprintRunsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetBlueprintRunsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetBlueprintRunsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetBlueprintRunsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetCatalogImportStatusCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetCatalogImportStatusCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetCatalogImportStatusResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetCatalogImportStatusCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetClassifierCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetClassifierCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetClassifierResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetClassifierCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetClassifiersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetClassifiersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetClassifiersResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetClassifiersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetColumnStatisticsForPartitionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetColumnStatisticsForPartitionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetColumnStatisticsForPartitionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetColumnStatisticsForPartitionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetColumnStatisticsForTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetColumnStatisticsForTableCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetColumnStatisticsForTableResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetColumnStatisticsForTableCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetConnectionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetConnectionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetConnectionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetConnectionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetConnectionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetConnectionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetConnectionsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetConnectionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetCrawlerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetCrawlerCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetCrawlerResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetCrawlerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetCrawlerMetricsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetCrawlerMetricsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetCrawlerMetricsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetCrawlerMetricsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetCrawlersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetCrawlersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetCrawlersResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetCrawlersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetCustomEntityTypeCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetCustomEntityTypeCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetCustomEntityTypeResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetCustomEntityTypeCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetDatabaseCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetDatabaseCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetDatabaseResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetDatabaseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetDatabasesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetDatabasesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetDatabasesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetDatabasesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetDataCatalogEncryptionSettingsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetDataCatalogEncryptionSettingsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetDataCatalogEncryptionSettingsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetDataCatalogEncryptionSettingsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetDataflowGraphCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetDataflowGraphCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetDataflowGraphResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetDataflowGraphCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetDataQualityResultCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetDataQualityResultCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetDataQualityResultResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetDataQualityResultCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetDataQualityRuleRecommendationRunCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetDataQualityRuleRecommendationRunCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetDataQualityRuleRecommendationRunResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetDataQualityRuleRecommendationRunCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetDataQualityRulesetCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetDataQualityRulesetCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetDataQualityRulesetResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetDataQualityRulesetCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetDataQualityRulesetEvaluationRunCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetDataQualityRulesetEvaluationRunCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetDataQualityRulesetEvaluationRunResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetDataQualityRulesetEvaluationRunCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetDevEndpointCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetDevEndpointCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetDevEndpointResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetDevEndpointCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetDevEndpointsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetDevEndpointsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetDevEndpointsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetDevEndpointsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetJobCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetJobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetJobResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetJobBookmarkCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetJobBookmarkCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetJobBookmarkResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetJobBookmarkCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.glue#ValidationException":
            throw await deserializeAws_json1_1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetJobRunCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetJobRunCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetJobRunResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetJobRunCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetJobRunsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetJobRunsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetJobRunsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetJobRunsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetJobsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetJobsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetJobsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetJobsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetMappingCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetMappingCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetMappingResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetMappingCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetMLTaskRunCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetMLTaskRunCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetMLTaskRunResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetMLTaskRunCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetMLTaskRunsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetMLTaskRunsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetMLTaskRunsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetMLTaskRunsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetMLTransformCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetMLTransformCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetMLTransformResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetMLTransformCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetMLTransformsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetMLTransformsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetMLTransformsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetMLTransformsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetPartitionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetPartitionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetPartitionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetPartitionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetPartitionIndexesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetPartitionIndexesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetPartitionIndexesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetPartitionIndexesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictException":
        case "com.amazonaws.glue#ConflictException":
            throw await deserializeAws_json1_1ConflictExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetPartitionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetPartitionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetPartitionsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetPartitionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "InvalidStateException":
        case "com.amazonaws.glue#InvalidStateException":
            throw await deserializeAws_json1_1InvalidStateExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "ResourceNotReadyException":
        case "com.amazonaws.glue#ResourceNotReadyException":
            throw await deserializeAws_json1_1ResourceNotReadyExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetPlanCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetPlanCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetPlanResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetPlanCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetRegistryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetRegistryCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetRegistryResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetRegistryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetResourcePoliciesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetResourcePoliciesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetResourcePoliciesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetResourcePoliciesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetResourcePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetResourcePolicyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetResourcePolicyResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetResourcePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetSchemaCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetSchemaCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetSchemaResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetSchemaCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetSchemaByDefinitionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetSchemaByDefinitionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetSchemaByDefinitionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetSchemaByDefinitionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetSchemaVersionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetSchemaVersionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetSchemaVersionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetSchemaVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetSchemaVersionsDiffCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetSchemaVersionsDiffCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetSchemaVersionsDiffResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetSchemaVersionsDiffCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetSecurityConfigurationCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetSecurityConfigurationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetSecurityConfigurationResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetSecurityConfigurationCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetSecurityConfigurationsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetSecurityConfigurationsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetSecurityConfigurationsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetSecurityConfigurationsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetSessionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetSessionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetSessionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetSessionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetStatementCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetStatementCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetStatementResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetStatementCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "IllegalSessionStateException":
        case "com.amazonaws.glue#IllegalSessionStateException":
            throw await deserializeAws_json1_1IllegalSessionStateExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetTableCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetTableResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetTableCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "ResourceNotReadyException":
        case "com.amazonaws.glue#ResourceNotReadyException":
            throw await deserializeAws_json1_1ResourceNotReadyExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetTablesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetTablesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetTablesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetTablesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetTableVersionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetTableVersionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetTableVersionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetTableVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetTableVersionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetTableVersionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetTableVersionsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetTableVersionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetTagsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetTagsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetTagsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetTagsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetTriggerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetTriggerCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetTriggerResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetTriggerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetTriggersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetTriggersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetTriggersResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetTriggersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetUnfilteredPartitionMetadataCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetUnfilteredPartitionMetadataCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetUnfilteredPartitionMetadataResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetUnfilteredPartitionMetadataCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "PermissionTypeMismatchException":
        case "com.amazonaws.glue#PermissionTypeMismatchException":
            throw await deserializeAws_json1_1PermissionTypeMismatchExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetUnfilteredPartitionsMetadataCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetUnfilteredPartitionsMetadataCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetUnfilteredPartitionsMetadataResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetUnfilteredPartitionsMetadataCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "PermissionTypeMismatchException":
        case "com.amazonaws.glue#PermissionTypeMismatchException":
            throw await deserializeAws_json1_1PermissionTypeMismatchExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetUnfilteredTableMetadataCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetUnfilteredTableMetadataCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetUnfilteredTableMetadataResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetUnfilteredTableMetadataCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "PermissionTypeMismatchException":
        case "com.amazonaws.glue#PermissionTypeMismatchException":
            throw await deserializeAws_json1_1PermissionTypeMismatchExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetUserDefinedFunctionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetUserDefinedFunctionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetUserDefinedFunctionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetUserDefinedFunctionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetUserDefinedFunctionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetUserDefinedFunctionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetUserDefinedFunctionsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetUserDefinedFunctionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetWorkflowCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetWorkflowCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetWorkflowResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetWorkflowCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetWorkflowRunCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetWorkflowRunCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetWorkflowRunResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetWorkflowRunCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetWorkflowRunPropertiesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetWorkflowRunPropertiesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetWorkflowRunPropertiesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetWorkflowRunPropertiesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1GetWorkflowRunsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1GetWorkflowRunsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1GetWorkflowRunsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1GetWorkflowRunsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1ImportCatalogToGlueCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ImportCatalogToGlueCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ImportCatalogToGlueResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1ImportCatalogToGlueCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1ListBlueprintsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListBlueprintsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListBlueprintsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListBlueprintsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1ListCrawlersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListCrawlersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListCrawlersResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListCrawlersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1ListCrawlsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListCrawlsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListCrawlsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListCrawlsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1ListCustomEntityTypesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListCustomEntityTypesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListCustomEntityTypesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListCustomEntityTypesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1ListDataQualityResultsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListDataQualityResultsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListDataQualityResultsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListDataQualityResultsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1ListDataQualityRuleRecommendationRunsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListDataQualityRuleRecommendationRunsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListDataQualityRuleRecommendationRunsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListDataQualityRuleRecommendationRunsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1ListDataQualityRulesetEvaluationRunsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListDataQualityRulesetEvaluationRunsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListDataQualityRulesetEvaluationRunsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListDataQualityRulesetEvaluationRunsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1ListDataQualityRulesetsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListDataQualityRulesetsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListDataQualityRulesetsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListDataQualityRulesetsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1ListDevEndpointsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListDevEndpointsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListDevEndpointsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListDevEndpointsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1ListJobsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListJobsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListJobsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListJobsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1ListMLTransformsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListMLTransformsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListMLTransformsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListMLTransformsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1ListRegistriesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListRegistriesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListRegistriesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListRegistriesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1ListSchemasCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListSchemasCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListSchemasResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListSchemasCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1ListSchemaVersionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListSchemaVersionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListSchemaVersionsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListSchemaVersionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1ListSessionsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListSessionsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListSessionsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListSessionsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1ListStatementsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListStatementsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListStatementsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListStatementsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "IllegalSessionStateException":
        case "com.amazonaws.glue#IllegalSessionStateException":
            throw await deserializeAws_json1_1IllegalSessionStateExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1ListTriggersCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListTriggersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListTriggersResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListTriggersCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1ListWorkflowsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ListWorkflowsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ListWorkflowsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1ListWorkflowsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1PutDataCatalogEncryptionSettingsCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1PutDataCatalogEncryptionSettingsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1PutDataCatalogEncryptionSettingsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1PutDataCatalogEncryptionSettingsCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1PutResourcePolicyCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1PutResourcePolicyCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1PutResourcePolicyResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1PutResourcePolicyCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConditionCheckFailureException":
        case "com.amazonaws.glue#ConditionCheckFailureException":
            throw await deserializeAws_json1_1ConditionCheckFailureExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1PutSchemaVersionMetadataCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1PutSchemaVersionMetadataCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1PutSchemaVersionMetadataResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1PutSchemaVersionMetadataCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "AlreadyExistsException":
        case "com.amazonaws.glue#AlreadyExistsException":
            throw await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "ResourceNumberLimitExceededException":
        case "com.amazonaws.glue#ResourceNumberLimitExceededException":
            throw await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1PutWorkflowRunPropertiesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1PutWorkflowRunPropertiesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1PutWorkflowRunPropertiesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1PutWorkflowRunPropertiesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AlreadyExistsException":
        case "com.amazonaws.glue#AlreadyExistsException":
            throw await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context);
        case "ConcurrentModificationException":
        case "com.amazonaws.glue#ConcurrentModificationException":
            throw await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "ResourceNumberLimitExceededException":
        case "com.amazonaws.glue#ResourceNumberLimitExceededException":
            throw await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1QuerySchemaVersionMetadataCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1QuerySchemaVersionMetadataCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1QuerySchemaVersionMetadataResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1QuerySchemaVersionMetadataCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1RegisterSchemaVersionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1RegisterSchemaVersionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1RegisterSchemaVersionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1RegisterSchemaVersionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ConcurrentModificationException":
        case "com.amazonaws.glue#ConcurrentModificationException":
            throw await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "ResourceNumberLimitExceededException":
        case "com.amazonaws.glue#ResourceNumberLimitExceededException":
            throw await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1RemoveSchemaVersionMetadataCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1RemoveSchemaVersionMetadataCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1RemoveSchemaVersionMetadataResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1RemoveSchemaVersionMetadataCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1ResetJobBookmarkCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ResetJobBookmarkCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ResetJobBookmarkResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1ResetJobBookmarkCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1ResumeWorkflowRunCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1ResumeWorkflowRunCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1ResumeWorkflowRunResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1ResumeWorkflowRunCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentRunsExceededException":
        case "com.amazonaws.glue#ConcurrentRunsExceededException":
            throw await deserializeAws_json1_1ConcurrentRunsExceededExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "IllegalWorkflowStateException":
        case "com.amazonaws.glue#IllegalWorkflowStateException":
            throw await deserializeAws_json1_1IllegalWorkflowStateExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1RunStatementCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1RunStatementCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1RunStatementResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1RunStatementCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "IllegalSessionStateException":
        case "com.amazonaws.glue#IllegalSessionStateException":
            throw await deserializeAws_json1_1IllegalSessionStateExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "ResourceNumberLimitExceededException":
        case "com.amazonaws.glue#ResourceNumberLimitExceededException":
            throw await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.glue#ValidationException":
            throw await deserializeAws_json1_1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1SearchTablesCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1SearchTablesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1SearchTablesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1SearchTablesCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1StartBlueprintRunCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1StartBlueprintRunCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StartBlueprintRunResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1StartBlueprintRunCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "IllegalBlueprintStateException":
        case "com.amazonaws.glue#IllegalBlueprintStateException":
            throw await deserializeAws_json1_1IllegalBlueprintStateExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "ResourceNumberLimitExceededException":
        case "com.amazonaws.glue#ResourceNumberLimitExceededException":
            throw await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1StartCrawlerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1StartCrawlerCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StartCrawlerResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1StartCrawlerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CrawlerRunningException":
        case "com.amazonaws.glue#CrawlerRunningException":
            throw await deserializeAws_json1_1CrawlerRunningExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1StartCrawlerScheduleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1StartCrawlerScheduleCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StartCrawlerScheduleResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1StartCrawlerScheduleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "NoScheduleException":
        case "com.amazonaws.glue#NoScheduleException":
            throw await deserializeAws_json1_1NoScheduleExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "SchedulerRunningException":
        case "com.amazonaws.glue#SchedulerRunningException":
            throw await deserializeAws_json1_1SchedulerRunningExceptionResponse(parsedOutput, context);
        case "SchedulerTransitioningException":
        case "com.amazonaws.glue#SchedulerTransitioningException":
            throw await deserializeAws_json1_1SchedulerTransitioningExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1StartDataQualityRuleRecommendationRunCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1StartDataQualityRuleRecommendationRunCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StartDataQualityRuleRecommendationRunResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1StartDataQualityRuleRecommendationRunCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictException":
        case "com.amazonaws.glue#ConflictException":
            throw await deserializeAws_json1_1ConflictExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1StartDataQualityRulesetEvaluationRunCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1StartDataQualityRulesetEvaluationRunCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StartDataQualityRulesetEvaluationRunResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1StartDataQualityRulesetEvaluationRunCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConflictException":
        case "com.amazonaws.glue#ConflictException":
            throw await deserializeAws_json1_1ConflictExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1StartExportLabelsTaskRunCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1StartExportLabelsTaskRunCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StartExportLabelsTaskRunResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1StartExportLabelsTaskRunCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1StartImportLabelsTaskRunCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1StartImportLabelsTaskRunCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StartImportLabelsTaskRunResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1StartImportLabelsTaskRunCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "ResourceNumberLimitExceededException":
        case "com.amazonaws.glue#ResourceNumberLimitExceededException":
            throw await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1StartJobRunCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1StartJobRunCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StartJobRunResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1StartJobRunCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentRunsExceededException":
        case "com.amazonaws.glue#ConcurrentRunsExceededException":
            throw await deserializeAws_json1_1ConcurrentRunsExceededExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "ResourceNumberLimitExceededException":
        case "com.amazonaws.glue#ResourceNumberLimitExceededException":
            throw await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1StartMLEvaluationTaskRunCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1StartMLEvaluationTaskRunCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StartMLEvaluationTaskRunResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1StartMLEvaluationTaskRunCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentRunsExceededException":
        case "com.amazonaws.glue#ConcurrentRunsExceededException":
            throw await deserializeAws_json1_1ConcurrentRunsExceededExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "MLTransformNotReadyException":
        case "com.amazonaws.glue#MLTransformNotReadyException":
            throw await deserializeAws_json1_1MLTransformNotReadyExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1StartMLLabelingSetGenerationTaskRunCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1StartMLLabelingSetGenerationTaskRunCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StartMLLabelingSetGenerationTaskRunResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1StartMLLabelingSetGenerationTaskRunCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentRunsExceededException":
        case "com.amazonaws.glue#ConcurrentRunsExceededException":
            throw await deserializeAws_json1_1ConcurrentRunsExceededExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1StartTriggerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1StartTriggerCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StartTriggerResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1StartTriggerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentRunsExceededException":
        case "com.amazonaws.glue#ConcurrentRunsExceededException":
            throw await deserializeAws_json1_1ConcurrentRunsExceededExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "ResourceNumberLimitExceededException":
        case "com.amazonaws.glue#ResourceNumberLimitExceededException":
            throw await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1StartWorkflowRunCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1StartWorkflowRunCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StartWorkflowRunResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1StartWorkflowRunCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentRunsExceededException":
        case "com.amazonaws.glue#ConcurrentRunsExceededException":
            throw await deserializeAws_json1_1ConcurrentRunsExceededExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "ResourceNumberLimitExceededException":
        case "com.amazonaws.glue#ResourceNumberLimitExceededException":
            throw await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1StopCrawlerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1StopCrawlerCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StopCrawlerResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1StopCrawlerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CrawlerNotRunningException":
        case "com.amazonaws.glue#CrawlerNotRunningException":
            throw await deserializeAws_json1_1CrawlerNotRunningExceptionResponse(parsedOutput, context);
        case "CrawlerStoppingException":
        case "com.amazonaws.glue#CrawlerStoppingException":
            throw await deserializeAws_json1_1CrawlerStoppingExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1StopCrawlerScheduleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1StopCrawlerScheduleCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StopCrawlerScheduleResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1StopCrawlerScheduleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "SchedulerNotRunningException":
        case "com.amazonaws.glue#SchedulerNotRunningException":
            throw await deserializeAws_json1_1SchedulerNotRunningExceptionResponse(parsedOutput, context);
        case "SchedulerTransitioningException":
        case "com.amazonaws.glue#SchedulerTransitioningException":
            throw await deserializeAws_json1_1SchedulerTransitioningExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1StopSessionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1StopSessionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StopSessionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1StopSessionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ConcurrentModificationException":
        case "com.amazonaws.glue#ConcurrentModificationException":
            throw await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context);
        case "IllegalSessionStateException":
        case "com.amazonaws.glue#IllegalSessionStateException":
            throw await deserializeAws_json1_1IllegalSessionStateExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1StopTriggerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1StopTriggerCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StopTriggerResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1StopTriggerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModificationException":
        case "com.amazonaws.glue#ConcurrentModificationException":
            throw await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1StopWorkflowRunCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1StopWorkflowRunCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1StopWorkflowRunResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1StopWorkflowRunCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "IllegalWorkflowStateException":
        case "com.amazonaws.glue#IllegalWorkflowStateException":
            throw await deserializeAws_json1_1IllegalWorkflowStateExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1TagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1TagResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1TagResourceResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1TagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1UntagResourceCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UntagResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UntagResourceResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1UntagResourceCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1UpdateBlueprintCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateBlueprintCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateBlueprintResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1UpdateBlueprintCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModificationException":
        case "com.amazonaws.glue#ConcurrentModificationException":
            throw await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "IllegalBlueprintStateException":
        case "com.amazonaws.glue#IllegalBlueprintStateException":
            throw await deserializeAws_json1_1IllegalBlueprintStateExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1UpdateClassifierCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateClassifierCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateClassifierResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1UpdateClassifierCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "VersionMismatchException":
        case "com.amazonaws.glue#VersionMismatchException":
            throw await deserializeAws_json1_1VersionMismatchExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1UpdateColumnStatisticsForPartitionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateColumnStatisticsForPartitionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateColumnStatisticsForPartitionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1UpdateColumnStatisticsForPartitionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1UpdateColumnStatisticsForTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateColumnStatisticsForTableCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateColumnStatisticsForTableResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1UpdateColumnStatisticsForTableCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1UpdateConnectionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateConnectionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateConnectionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1UpdateConnectionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1UpdateCrawlerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateCrawlerCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateCrawlerResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1UpdateCrawlerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "CrawlerRunningException":
        case "com.amazonaws.glue#CrawlerRunningException":
            throw await deserializeAws_json1_1CrawlerRunningExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "VersionMismatchException":
        case "com.amazonaws.glue#VersionMismatchException":
            throw await deserializeAws_json1_1VersionMismatchExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1UpdateCrawlerScheduleCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateCrawlerScheduleCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateCrawlerScheduleResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1UpdateCrawlerScheduleCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "SchedulerTransitioningException":
        case "com.amazonaws.glue#SchedulerTransitioningException":
            throw await deserializeAws_json1_1SchedulerTransitioningExceptionResponse(parsedOutput, context);
        case "VersionMismatchException":
        case "com.amazonaws.glue#VersionMismatchException":
            throw await deserializeAws_json1_1VersionMismatchExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1UpdateDatabaseCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateDatabaseCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateDatabaseResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1UpdateDatabaseCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModificationException":
        case "com.amazonaws.glue#ConcurrentModificationException":
            throw await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1UpdateDataQualityRulesetCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateDataQualityRulesetCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateDataQualityRulesetResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1UpdateDataQualityRulesetCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AlreadyExistsException":
        case "com.amazonaws.glue#AlreadyExistsException":
            throw await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "IdempotentParameterMismatchException":
        case "com.amazonaws.glue#IdempotentParameterMismatchException":
            throw await deserializeAws_json1_1IdempotentParameterMismatchExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "ResourceNumberLimitExceededException":
        case "com.amazonaws.glue#ResourceNumberLimitExceededException":
            throw await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1UpdateDevEndpointCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateDevEndpointCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateDevEndpointResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1UpdateDevEndpointCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.glue#ValidationException":
            throw await deserializeAws_json1_1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1UpdateJobCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateJobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateJobResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1UpdateJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModificationException":
        case "com.amazonaws.glue#ConcurrentModificationException":
            throw await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1UpdateJobFromSourceControlCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateJobFromSourceControlCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateJobFromSourceControlResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1UpdateJobFromSourceControlCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "AlreadyExistsException":
        case "com.amazonaws.glue#AlreadyExistsException":
            throw await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.glue#ValidationException":
            throw await deserializeAws_json1_1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1UpdateMLTransformCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateMLTransformCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateMLTransformResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1UpdateMLTransformCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1UpdatePartitionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdatePartitionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdatePartitionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1UpdatePartitionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1UpdateRegistryCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateRegistryCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateRegistryResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1UpdateRegistryCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ConcurrentModificationException":
        case "com.amazonaws.glue#ConcurrentModificationException":
            throw await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1UpdateSchemaCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateSchemaCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateSchemaResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1UpdateSchemaCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "ConcurrentModificationException":
        case "com.amazonaws.glue#ConcurrentModificationException":
            throw await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1UpdateSourceControlFromJobCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateSourceControlFromJobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateSourceControlFromJobResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1UpdateSourceControlFromJobCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "AccessDeniedException":
        case "com.amazonaws.glue#AccessDeniedException":
            throw await deserializeAws_json1_1AccessDeniedExceptionResponse(parsedOutput, context);
        case "AlreadyExistsException":
        case "com.amazonaws.glue#AlreadyExistsException":
            throw await deserializeAws_json1_1AlreadyExistsExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "ValidationException":
        case "com.amazonaws.glue#ValidationException":
            throw await deserializeAws_json1_1ValidationExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1UpdateTableCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateTableCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateTableResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1UpdateTableCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModificationException":
        case "com.amazonaws.glue#ConcurrentModificationException":
            throw await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        case "ResourceNotReadyException":
        case "com.amazonaws.glue#ResourceNotReadyException":
            throw await deserializeAws_json1_1ResourceNotReadyExceptionResponse(parsedOutput, context);
        case "ResourceNumberLimitExceededException":
        case "com.amazonaws.glue#ResourceNumberLimitExceededException":
            throw await deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1UpdateTriggerCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateTriggerCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateTriggerResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1UpdateTriggerCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModificationException":
        case "com.amazonaws.glue#ConcurrentModificationException":
            throw await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1UpdateUserDefinedFunctionCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateUserDefinedFunctionCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateUserDefinedFunctionResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1UpdateUserDefinedFunctionCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "GlueEncryptionException":
        case "com.amazonaws.glue#GlueEncryptionException":
            throw await deserializeAws_json1_1GlueEncryptionExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
export const deserializeAws_json1_1UpdateWorkflowCommand = async (output, context) => {
    if (output.statusCode >= 300) {
        return deserializeAws_json1_1UpdateWorkflowCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = deserializeAws_json1_1UpdateWorkflowResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents,
    };
    return Promise.resolve(response);
};
const deserializeAws_json1_1UpdateWorkflowCommandError = async (output, context) => {
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context),
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch (errorCode) {
        case "ConcurrentModificationException":
        case "com.amazonaws.glue#ConcurrentModificationException":
            throw await deserializeAws_json1_1ConcurrentModificationExceptionResponse(parsedOutput, context);
        case "EntityNotFoundException":
        case "com.amazonaws.glue#EntityNotFoundException":
            throw await deserializeAws_json1_1EntityNotFoundExceptionResponse(parsedOutput, context);
        case "InternalServiceException":
        case "com.amazonaws.glue#InternalServiceException":
            throw await deserializeAws_json1_1InternalServiceExceptionResponse(parsedOutput, context);
        case "InvalidInputException":
        case "com.amazonaws.glue#InvalidInputException":
            throw await deserializeAws_json1_1InvalidInputExceptionResponse(parsedOutput, context);
        case "OperationTimeoutException":
        case "com.amazonaws.glue#OperationTimeoutException":
            throw await deserializeAws_json1_1OperationTimeoutExceptionResponse(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            throwDefaultError({
                output,
                parsedBody,
                exceptionCtor: __BaseException,
                errorCode,
            });
    }
};
const deserializeAws_json1_1AccessDeniedExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1AccessDeniedException(body, context);
    const exception = new AccessDeniedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1AlreadyExistsExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1AlreadyExistsException(body, context);
    const exception = new AlreadyExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1ConcurrentModificationExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ConcurrentModificationException(body, context);
    const exception = new ConcurrentModificationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1ConcurrentRunsExceededExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ConcurrentRunsExceededException(body, context);
    const exception = new ConcurrentRunsExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1ConditionCheckFailureExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ConditionCheckFailureException(body, context);
    const exception = new ConditionCheckFailureException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1ConflictExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ConflictException(body, context);
    const exception = new ConflictException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1CrawlerNotRunningExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1CrawlerNotRunningException(body, context);
    const exception = new CrawlerNotRunningException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1CrawlerRunningExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1CrawlerRunningException(body, context);
    const exception = new CrawlerRunningException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1CrawlerStoppingExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1CrawlerStoppingException(body, context);
    const exception = new CrawlerStoppingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1EntityNotFoundExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1EntityNotFoundException(body, context);
    const exception = new EntityNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1GlueEncryptionExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1GlueEncryptionException(body, context);
    const exception = new GlueEncryptionException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1IdempotentParameterMismatchExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1IdempotentParameterMismatchException(body, context);
    const exception = new IdempotentParameterMismatchException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1IllegalBlueprintStateExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1IllegalBlueprintStateException(body, context);
    const exception = new IllegalBlueprintStateException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1IllegalSessionStateExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1IllegalSessionStateException(body, context);
    const exception = new IllegalSessionStateException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1IllegalWorkflowStateExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1IllegalWorkflowStateException(body, context);
    const exception = new IllegalWorkflowStateException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1InternalServiceExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InternalServiceException(body, context);
    const exception = new InternalServiceException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1InvalidInputExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidInputException(body, context);
    const exception = new InvalidInputException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1InvalidStateExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1InvalidStateException(body, context);
    const exception = new InvalidStateException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1MLTransformNotReadyExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1MLTransformNotReadyException(body, context);
    const exception = new MLTransformNotReadyException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1NoScheduleExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1NoScheduleException(body, context);
    const exception = new NoScheduleException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1OperationTimeoutExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1OperationTimeoutException(body, context);
    const exception = new OperationTimeoutException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1PermissionTypeMismatchExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1PermissionTypeMismatchException(body, context);
    const exception = new PermissionTypeMismatchException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1ResourceNotReadyExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ResourceNotReadyException(body, context);
    const exception = new ResourceNotReadyException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1ResourceNumberLimitExceededExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ResourceNumberLimitExceededException(body, context);
    const exception = new ResourceNumberLimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1SchedulerNotRunningExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1SchedulerNotRunningException(body, context);
    const exception = new SchedulerNotRunningException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1SchedulerRunningExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1SchedulerRunningException(body, context);
    const exception = new SchedulerRunningException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1SchedulerTransitioningExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1SchedulerTransitioningException(body, context);
    const exception = new SchedulerTransitioningException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1ValidationExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1ValidationException(body, context);
    const exception = new ValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const deserializeAws_json1_1VersionMismatchExceptionResponse = async (parsedOutput, context) => {
    const body = parsedOutput.body;
    const deserialized = deserializeAws_json1_1VersionMismatchException(body, context);
    const exception = new VersionMismatchException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized,
    });
    return __decorateServiceException(exception, body);
};
const serializeAws_json1_1Action = (input, context) => {
    return {
        ...(input.Arguments != null && { Arguments: serializeAws_json1_1GenericMap(input.Arguments, context) }),
        ...(input.CrawlerName != null && { CrawlerName: input.CrawlerName }),
        ...(input.JobName != null && { JobName: input.JobName }),
        ...(input.NotificationProperty != null && {
            NotificationProperty: serializeAws_json1_1NotificationProperty(input.NotificationProperty, context),
        }),
        ...(input.SecurityConfiguration != null && { SecurityConfiguration: input.SecurityConfiguration }),
        ...(input.Timeout != null && { Timeout: input.Timeout }),
    };
};
const serializeAws_json1_1ActionList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1Action(entry, context);
    });
};
const serializeAws_json1_1AdditionalOptions = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
const serializeAws_json1_1AdditionalPlanOptionsMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
const serializeAws_json1_1Aggregate = (input, context) => {
    return {
        ...(input.Aggs != null && { Aggs: serializeAws_json1_1AggregateOperations(input.Aggs, context) }),
        ...(input.Groups != null && { Groups: serializeAws_json1_1GlueStudioPathList(input.Groups, context) }),
        ...(input.Inputs != null && { Inputs: serializeAws_json1_1OneInput(input.Inputs, context) }),
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1AggregateOperation = (input, context) => {
    return {
        ...(input.AggFunc != null && { AggFunc: input.AggFunc }),
        ...(input.Column != null && { Column: serializeAws_json1_1EnclosedInStringProperties(input.Column, context) }),
    };
};
const serializeAws_json1_1AggregateOperations = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1AggregateOperation(entry, context);
    });
};
const serializeAws_json1_1ApplyMapping = (input, context) => {
    return {
        ...(input.Inputs != null && { Inputs: serializeAws_json1_1OneInput(input.Inputs, context) }),
        ...(input.Mapping != null && { Mapping: serializeAws_json1_1Mappings(input.Mapping, context) }),
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1AthenaConnectorSource = (input, context) => {
    return {
        ...(input.ConnectionName != null && { ConnectionName: input.ConnectionName }),
        ...(input.ConnectionTable != null && { ConnectionTable: input.ConnectionTable }),
        ...(input.ConnectionType != null && { ConnectionType: input.ConnectionType }),
        ...(input.ConnectorName != null && { ConnectorName: input.ConnectorName }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.OutputSchemas != null && {
            OutputSchemas: serializeAws_json1_1GlueSchemas(input.OutputSchemas, context),
        }),
        ...(input.SchemaName != null && { SchemaName: input.SchemaName }),
    };
};
const serializeAws_json1_1AuditColumnNamesList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1AuditContext = (input, context) => {
    return {
        ...(input.AdditionalAuditContext != null && { AdditionalAuditContext: input.AdditionalAuditContext }),
        ...(input.AllColumnsRequested != null && { AllColumnsRequested: input.AllColumnsRequested }),
        ...(input.RequestedColumns != null && {
            RequestedColumns: serializeAws_json1_1AuditColumnNamesList(input.RequestedColumns, context),
        }),
    };
};
const serializeAws_json1_1BasicCatalogTarget = (input, context) => {
    return {
        ...(input.Database != null && { Database: input.Database }),
        ...(input.Inputs != null && { Inputs: serializeAws_json1_1OneInput(input.Inputs, context) }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Table != null && { Table: input.Table }),
    };
};
const serializeAws_json1_1BatchCreatePartitionRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.PartitionInputList != null && {
            PartitionInputList: serializeAws_json1_1PartitionInputList(input.PartitionInputList, context),
        }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const serializeAws_json1_1BatchDeleteConnectionRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.ConnectionNameList != null && {
            ConnectionNameList: serializeAws_json1_1DeleteConnectionNameList(input.ConnectionNameList, context),
        }),
    };
};
const serializeAws_json1_1BatchDeletePartitionRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.PartitionsToDelete != null && {
            PartitionsToDelete: serializeAws_json1_1BatchDeletePartitionValueList(input.PartitionsToDelete, context),
        }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const serializeAws_json1_1BatchDeletePartitionValueList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1PartitionValueList(entry, context);
    });
};
const serializeAws_json1_1BatchDeleteTableNameList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1BatchDeleteTableRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.TablesToDelete != null && {
            TablesToDelete: serializeAws_json1_1BatchDeleteTableNameList(input.TablesToDelete, context),
        }),
        ...(input.TransactionId != null && { TransactionId: input.TransactionId }),
    };
};
const serializeAws_json1_1BatchDeleteTableVersionList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1BatchDeleteTableVersionRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.TableName != null && { TableName: input.TableName }),
        ...(input.VersionIds != null && {
            VersionIds: serializeAws_json1_1BatchDeleteTableVersionList(input.VersionIds, context),
        }),
    };
};
const serializeAws_json1_1BatchGetBlueprintNames = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1BatchGetBlueprintsRequest = (input, context) => {
    return {
        ...(input.IncludeBlueprint != null && { IncludeBlueprint: input.IncludeBlueprint }),
        ...(input.IncludeParameterSpec != null && { IncludeParameterSpec: input.IncludeParameterSpec }),
        ...(input.Names != null && { Names: serializeAws_json1_1BatchGetBlueprintNames(input.Names, context) }),
    };
};
const serializeAws_json1_1BatchGetCrawlersRequest = (input, context) => {
    return {
        ...(input.CrawlerNames != null && {
            CrawlerNames: serializeAws_json1_1CrawlerNameList(input.CrawlerNames, context),
        }),
    };
};
const serializeAws_json1_1BatchGetCustomEntityTypesRequest = (input, context) => {
    return {
        ...(input.Names != null && { Names: serializeAws_json1_1CustomEntityTypeNames(input.Names, context) }),
    };
};
const serializeAws_json1_1BatchGetDataQualityResultRequest = (input, context) => {
    return {
        ...(input.ResultIds != null && { ResultIds: serializeAws_json1_1DataQualityResultIds(input.ResultIds, context) }),
    };
};
const serializeAws_json1_1BatchGetDevEndpointsRequest = (input, context) => {
    return {
        ...(input.DevEndpointNames != null && {
            DevEndpointNames: serializeAws_json1_1DevEndpointNames(input.DevEndpointNames, context),
        }),
    };
};
const serializeAws_json1_1BatchGetJobsRequest = (input, context) => {
    return {
        ...(input.JobNames != null && { JobNames: serializeAws_json1_1JobNameList(input.JobNames, context) }),
    };
};
const serializeAws_json1_1BatchGetPartitionRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.PartitionsToGet != null && {
            PartitionsToGet: serializeAws_json1_1BatchGetPartitionValueList(input.PartitionsToGet, context),
        }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const serializeAws_json1_1BatchGetPartitionValueList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1PartitionValueList(entry, context);
    });
};
const serializeAws_json1_1BatchGetTriggersRequest = (input, context) => {
    return {
        ...(input.TriggerNames != null && {
            TriggerNames: serializeAws_json1_1TriggerNameList(input.TriggerNames, context),
        }),
    };
};
const serializeAws_json1_1BatchGetWorkflowsRequest = (input, context) => {
    return {
        ...(input.IncludeGraph != null && { IncludeGraph: input.IncludeGraph }),
        ...(input.Names != null && { Names: serializeAws_json1_1WorkflowNames(input.Names, context) }),
    };
};
const serializeAws_json1_1BatchStopJobRunJobRunIdList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1BatchStopJobRunRequest = (input, context) => {
    return {
        ...(input.JobName != null && { JobName: input.JobName }),
        ...(input.JobRunIds != null && {
            JobRunIds: serializeAws_json1_1BatchStopJobRunJobRunIdList(input.JobRunIds, context),
        }),
    };
};
const serializeAws_json1_1BatchUpdatePartitionRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.Entries != null && {
            Entries: serializeAws_json1_1BatchUpdatePartitionRequestEntryList(input.Entries, context),
        }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const serializeAws_json1_1BatchUpdatePartitionRequestEntry = (input, context) => {
    return {
        ...(input.PartitionInput != null && {
            PartitionInput: serializeAws_json1_1PartitionInput(input.PartitionInput, context),
        }),
        ...(input.PartitionValueList != null && {
            PartitionValueList: serializeAws_json1_1BoundedPartitionValueList(input.PartitionValueList, context),
        }),
    };
};
const serializeAws_json1_1BatchUpdatePartitionRequestEntryList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1BatchUpdatePartitionRequestEntry(entry, context);
    });
};
const serializeAws_json1_1BinaryColumnStatisticsData = (input, context) => {
    return {
        ...(input.AverageLength != null && { AverageLength: __serializeFloat(input.AverageLength) }),
        ...(input.MaximumLength != null && { MaximumLength: input.MaximumLength }),
        ...(input.NumberOfNulls != null && { NumberOfNulls: input.NumberOfNulls }),
    };
};
const serializeAws_json1_1BooleanColumnStatisticsData = (input, context) => {
    return {
        ...(input.NumberOfFalses != null && { NumberOfFalses: input.NumberOfFalses }),
        ...(input.NumberOfNulls != null && { NumberOfNulls: input.NumberOfNulls }),
        ...(input.NumberOfTrues != null && { NumberOfTrues: input.NumberOfTrues }),
    };
};
const serializeAws_json1_1BoundedPartitionValueList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1CancelDataQualityRuleRecommendationRunRequest = (input, context) => {
    return {
        ...(input.RunId != null && { RunId: input.RunId }),
    };
};
const serializeAws_json1_1CancelDataQualityRulesetEvaluationRunRequest = (input, context) => {
    return {
        ...(input.RunId != null && { RunId: input.RunId }),
    };
};
const serializeAws_json1_1CancelMLTaskRunRequest = (input, context) => {
    return {
        ...(input.TaskRunId != null && { TaskRunId: input.TaskRunId }),
        ...(input.TransformId != null && { TransformId: input.TransformId }),
    };
};
const serializeAws_json1_1CancelStatementRequest = (input, context) => {
    return {
        ...(input.Id != null && { Id: input.Id }),
        ...(input.RequestOrigin != null && { RequestOrigin: input.RequestOrigin }),
        ...(input.SessionId != null && { SessionId: input.SessionId }),
    };
};
const serializeAws_json1_1CatalogEntries = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1CatalogEntry(entry, context);
    });
};
const serializeAws_json1_1CatalogEntry = (input, context) => {
    return {
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const serializeAws_json1_1CatalogHudiSource = (input, context) => {
    return {
        ...(input.AdditionalHudiOptions != null && {
            AdditionalHudiOptions: serializeAws_json1_1AdditionalOptions(input.AdditionalHudiOptions, context),
        }),
        ...(input.Database != null && { Database: input.Database }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.OutputSchemas != null && {
            OutputSchemas: serializeAws_json1_1GlueSchemas(input.OutputSchemas, context),
        }),
        ...(input.Table != null && { Table: input.Table }),
    };
};
const serializeAws_json1_1CatalogKafkaSource = (input, context) => {
    return {
        ...(input.DataPreviewOptions != null && {
            DataPreviewOptions: serializeAws_json1_1StreamingDataPreviewOptions(input.DataPreviewOptions, context),
        }),
        ...(input.Database != null && { Database: input.Database }),
        ...(input.DetectSchema != null && { DetectSchema: input.DetectSchema }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.StreamingOptions != null && {
            StreamingOptions: serializeAws_json1_1KafkaStreamingSourceOptions(input.StreamingOptions, context),
        }),
        ...(input.Table != null && { Table: input.Table }),
        ...(input.WindowSize != null && { WindowSize: input.WindowSize }),
    };
};
const serializeAws_json1_1CatalogKinesisSource = (input, context) => {
    return {
        ...(input.DataPreviewOptions != null && {
            DataPreviewOptions: serializeAws_json1_1StreamingDataPreviewOptions(input.DataPreviewOptions, context),
        }),
        ...(input.Database != null && { Database: input.Database }),
        ...(input.DetectSchema != null && { DetectSchema: input.DetectSchema }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.StreamingOptions != null && {
            StreamingOptions: serializeAws_json1_1KinesisStreamingSourceOptions(input.StreamingOptions, context),
        }),
        ...(input.Table != null && { Table: input.Table }),
        ...(input.WindowSize != null && { WindowSize: input.WindowSize }),
    };
};
const serializeAws_json1_1CatalogSchemaChangePolicy = (input, context) => {
    return {
        ...(input.EnableUpdateCatalog != null && { EnableUpdateCatalog: input.EnableUpdateCatalog }),
        ...(input.UpdateBehavior != null && { UpdateBehavior: input.UpdateBehavior }),
    };
};
const serializeAws_json1_1CatalogSource = (input, context) => {
    return {
        ...(input.Database != null && { Database: input.Database }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Table != null && { Table: input.Table }),
    };
};
const serializeAws_json1_1CatalogTablesList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1CatalogTarget = (input, context) => {
    return {
        ...(input.ConnectionName != null && { ConnectionName: input.ConnectionName }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.DlqEventQueueArn != null && { DlqEventQueueArn: input.DlqEventQueueArn }),
        ...(input.EventQueueArn != null && { EventQueueArn: input.EventQueueArn }),
        ...(input.Tables != null && { Tables: serializeAws_json1_1CatalogTablesList(input.Tables, context) }),
    };
};
const serializeAws_json1_1CatalogTargetList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1CatalogTarget(entry, context);
    });
};
const serializeAws_json1_1CheckSchemaVersionValidityInput = (input, context) => {
    return {
        ...(input.DataFormat != null && { DataFormat: input.DataFormat }),
        ...(input.SchemaDefinition != null && { SchemaDefinition: input.SchemaDefinition }),
    };
};
const serializeAws_json1_1ClassifierNameList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1CloudWatchEncryption = (input, context) => {
    return {
        ...(input.CloudWatchEncryptionMode != null && { CloudWatchEncryptionMode: input.CloudWatchEncryptionMode }),
        ...(input.KmsKeyArn != null && { KmsKeyArn: input.KmsKeyArn }),
    };
};
const serializeAws_json1_1CodeGenConfigurationNode = (input, context) => {
    return {
        ...(input.Aggregate != null && { Aggregate: serializeAws_json1_1Aggregate(input.Aggregate, context) }),
        ...(input.ApplyMapping != null && { ApplyMapping: serializeAws_json1_1ApplyMapping(input.ApplyMapping, context) }),
        ...(input.AthenaConnectorSource != null && {
            AthenaConnectorSource: serializeAws_json1_1AthenaConnectorSource(input.AthenaConnectorSource, context),
        }),
        ...(input.CatalogHudiSource != null && {
            CatalogHudiSource: serializeAws_json1_1CatalogHudiSource(input.CatalogHudiSource, context),
        }),
        ...(input.CatalogKafkaSource != null && {
            CatalogKafkaSource: serializeAws_json1_1CatalogKafkaSource(input.CatalogKafkaSource, context),
        }),
        ...(input.CatalogKinesisSource != null && {
            CatalogKinesisSource: serializeAws_json1_1CatalogKinesisSource(input.CatalogKinesisSource, context),
        }),
        ...(input.CatalogSource != null && {
            CatalogSource: serializeAws_json1_1CatalogSource(input.CatalogSource, context),
        }),
        ...(input.CatalogTarget != null && {
            CatalogTarget: serializeAws_json1_1BasicCatalogTarget(input.CatalogTarget, context),
        }),
        ...(input.CustomCode != null && { CustomCode: serializeAws_json1_1CustomCode(input.CustomCode, context) }),
        ...(input.DirectJDBCSource != null && {
            DirectJDBCSource: serializeAws_json1_1DirectJDBCSource(input.DirectJDBCSource, context),
        }),
        ...(input.DirectKafkaSource != null && {
            DirectKafkaSource: serializeAws_json1_1DirectKafkaSource(input.DirectKafkaSource, context),
        }),
        ...(input.DirectKinesisSource != null && {
            DirectKinesisSource: serializeAws_json1_1DirectKinesisSource(input.DirectKinesisSource, context),
        }),
        ...(input.DropDuplicates != null && {
            DropDuplicates: serializeAws_json1_1DropDuplicates(input.DropDuplicates, context),
        }),
        ...(input.DropFields != null && { DropFields: serializeAws_json1_1DropFields(input.DropFields, context) }),
        ...(input.DropNullFields != null && {
            DropNullFields: serializeAws_json1_1DropNullFields(input.DropNullFields, context),
        }),
        ...(input.DynamicTransform != null && {
            DynamicTransform: serializeAws_json1_1DynamicTransform(input.DynamicTransform, context),
        }),
        ...(input.DynamoDBCatalogSource != null && {
            DynamoDBCatalogSource: serializeAws_json1_1DynamoDBCatalogSource(input.DynamoDBCatalogSource, context),
        }),
        ...(input.EvaluateDataQuality != null && {
            EvaluateDataQuality: serializeAws_json1_1EvaluateDataQuality(input.EvaluateDataQuality, context),
        }),
        ...(input.FillMissingValues != null && {
            FillMissingValues: serializeAws_json1_1FillMissingValues(input.FillMissingValues, context),
        }),
        ...(input.Filter != null && { Filter: serializeAws_json1_1Filter(input.Filter, context) }),
        ...(input.GovernedCatalogSource != null && {
            GovernedCatalogSource: serializeAws_json1_1GovernedCatalogSource(input.GovernedCatalogSource, context),
        }),
        ...(input.GovernedCatalogTarget != null && {
            GovernedCatalogTarget: serializeAws_json1_1GovernedCatalogTarget(input.GovernedCatalogTarget, context),
        }),
        ...(input.JDBCConnectorSource != null && {
            JDBCConnectorSource: serializeAws_json1_1JDBCConnectorSource(input.JDBCConnectorSource, context),
        }),
        ...(input.JDBCConnectorTarget != null && {
            JDBCConnectorTarget: serializeAws_json1_1JDBCConnectorTarget(input.JDBCConnectorTarget, context),
        }),
        ...(input.Join != null && { Join: serializeAws_json1_1Join(input.Join, context) }),
        ...(input.Merge != null && { Merge: serializeAws_json1_1Merge(input.Merge, context) }),
        ...(input.MicrosoftSQLServerCatalogSource != null && {
            MicrosoftSQLServerCatalogSource: serializeAws_json1_1MicrosoftSQLServerCatalogSource(input.MicrosoftSQLServerCatalogSource, context),
        }),
        ...(input.MicrosoftSQLServerCatalogTarget != null && {
            MicrosoftSQLServerCatalogTarget: serializeAws_json1_1MicrosoftSQLServerCatalogTarget(input.MicrosoftSQLServerCatalogTarget, context),
        }),
        ...(input.MySQLCatalogSource != null && {
            MySQLCatalogSource: serializeAws_json1_1MySQLCatalogSource(input.MySQLCatalogSource, context),
        }),
        ...(input.MySQLCatalogTarget != null && {
            MySQLCatalogTarget: serializeAws_json1_1MySQLCatalogTarget(input.MySQLCatalogTarget, context),
        }),
        ...(input.OracleSQLCatalogSource != null && {
            OracleSQLCatalogSource: serializeAws_json1_1OracleSQLCatalogSource(input.OracleSQLCatalogSource, context),
        }),
        ...(input.OracleSQLCatalogTarget != null && {
            OracleSQLCatalogTarget: serializeAws_json1_1OracleSQLCatalogTarget(input.OracleSQLCatalogTarget, context),
        }),
        ...(input.PIIDetection != null && { PIIDetection: serializeAws_json1_1PIIDetection(input.PIIDetection, context) }),
        ...(input.PostgreSQLCatalogSource != null && {
            PostgreSQLCatalogSource: serializeAws_json1_1PostgreSQLCatalogSource(input.PostgreSQLCatalogSource, context),
        }),
        ...(input.PostgreSQLCatalogTarget != null && {
            PostgreSQLCatalogTarget: serializeAws_json1_1PostgreSQLCatalogTarget(input.PostgreSQLCatalogTarget, context),
        }),
        ...(input.RedshiftSource != null && {
            RedshiftSource: serializeAws_json1_1RedshiftSource(input.RedshiftSource, context),
        }),
        ...(input.RedshiftTarget != null && {
            RedshiftTarget: serializeAws_json1_1RedshiftTarget(input.RedshiftTarget, context),
        }),
        ...(input.RelationalCatalogSource != null && {
            RelationalCatalogSource: serializeAws_json1_1RelationalCatalogSource(input.RelationalCatalogSource, context),
        }),
        ...(input.RenameField != null && { RenameField: serializeAws_json1_1RenameField(input.RenameField, context) }),
        ...(input.S3CatalogHudiSource != null && {
            S3CatalogHudiSource: serializeAws_json1_1S3CatalogHudiSource(input.S3CatalogHudiSource, context),
        }),
        ...(input.S3CatalogSource != null && {
            S3CatalogSource: serializeAws_json1_1S3CatalogSource(input.S3CatalogSource, context),
        }),
        ...(input.S3CatalogTarget != null && {
            S3CatalogTarget: serializeAws_json1_1S3CatalogTarget(input.S3CatalogTarget, context),
        }),
        ...(input.S3CsvSource != null && { S3CsvSource: serializeAws_json1_1S3CsvSource(input.S3CsvSource, context) }),
        ...(input.S3DirectTarget != null && {
            S3DirectTarget: serializeAws_json1_1S3DirectTarget(input.S3DirectTarget, context),
        }),
        ...(input.S3GlueParquetTarget != null && {
            S3GlueParquetTarget: serializeAws_json1_1S3GlueParquetTarget(input.S3GlueParquetTarget, context),
        }),
        ...(input.S3HudiCatalogTarget != null && {
            S3HudiCatalogTarget: serializeAws_json1_1S3HudiCatalogTarget(input.S3HudiCatalogTarget, context),
        }),
        ...(input.S3HudiDirectTarget != null && {
            S3HudiDirectTarget: serializeAws_json1_1S3HudiDirectTarget(input.S3HudiDirectTarget, context),
        }),
        ...(input.S3HudiSource != null && { S3HudiSource: serializeAws_json1_1S3HudiSource(input.S3HudiSource, context) }),
        ...(input.S3JsonSource != null && { S3JsonSource: serializeAws_json1_1S3JsonSource(input.S3JsonSource, context) }),
        ...(input.S3ParquetSource != null && {
            S3ParquetSource: serializeAws_json1_1S3ParquetSource(input.S3ParquetSource, context),
        }),
        ...(input.SelectFields != null && { SelectFields: serializeAws_json1_1SelectFields(input.SelectFields, context) }),
        ...(input.SelectFromCollection != null && {
            SelectFromCollection: serializeAws_json1_1SelectFromCollection(input.SelectFromCollection, context),
        }),
        ...(input.SparkConnectorSource != null && {
            SparkConnectorSource: serializeAws_json1_1SparkConnectorSource(input.SparkConnectorSource, context),
        }),
        ...(input.SparkConnectorTarget != null && {
            SparkConnectorTarget: serializeAws_json1_1SparkConnectorTarget(input.SparkConnectorTarget, context),
        }),
        ...(input.SparkSQL != null && { SparkSQL: serializeAws_json1_1SparkSQL(input.SparkSQL, context) }),
        ...(input.Spigot != null && { Spigot: serializeAws_json1_1Spigot(input.Spigot, context) }),
        ...(input.SplitFields != null && { SplitFields: serializeAws_json1_1SplitFields(input.SplitFields, context) }),
        ...(input.Union != null && { Union: serializeAws_json1_1Union(input.Union, context) }),
    };
};
const serializeAws_json1_1CodeGenConfigurationNodes = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = serializeAws_json1_1CodeGenConfigurationNode(value, context);
        return acc;
    }, {});
};
const serializeAws_json1_1CodeGenEdge = (input, context) => {
    return {
        ...(input.Source != null && { Source: input.Source }),
        ...(input.Target != null && { Target: input.Target }),
        ...(input.TargetParameter != null && { TargetParameter: input.TargetParameter }),
    };
};
const serializeAws_json1_1CodeGenNode = (input, context) => {
    return {
        ...(input.Args != null && { Args: serializeAws_json1_1CodeGenNodeArgs(input.Args, context) }),
        ...(input.Id != null && { Id: input.Id }),
        ...(input.LineNumber != null && { LineNumber: input.LineNumber }),
        ...(input.NodeType != null && { NodeType: input.NodeType }),
    };
};
const serializeAws_json1_1CodeGenNodeArg = (input, context) => {
    return {
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Param != null && { Param: input.Param }),
        ...(input.Value != null && { Value: input.Value }),
    };
};
const serializeAws_json1_1CodeGenNodeArgs = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1CodeGenNodeArg(entry, context);
    });
};
const serializeAws_json1_1Column = (input, context) => {
    return {
        ...(input.Comment != null && { Comment: input.Comment }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Parameters != null && { Parameters: serializeAws_json1_1ParametersMap(input.Parameters, context) }),
        ...(input.Type != null && { Type: input.Type }),
    };
};
const serializeAws_json1_1ColumnList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1Column(entry, context);
    });
};
const serializeAws_json1_1ColumnStatistics = (input, context) => {
    return {
        ...(input.AnalyzedTime != null && { AnalyzedTime: Math.round(input.AnalyzedTime.getTime() / 1000) }),
        ...(input.ColumnName != null && { ColumnName: input.ColumnName }),
        ...(input.ColumnType != null && { ColumnType: input.ColumnType }),
        ...(input.StatisticsData != null && {
            StatisticsData: serializeAws_json1_1ColumnStatisticsData(input.StatisticsData, context),
        }),
    };
};
const serializeAws_json1_1ColumnStatisticsData = (input, context) => {
    return {
        ...(input.BinaryColumnStatisticsData != null && {
            BinaryColumnStatisticsData: serializeAws_json1_1BinaryColumnStatisticsData(input.BinaryColumnStatisticsData, context),
        }),
        ...(input.BooleanColumnStatisticsData != null && {
            BooleanColumnStatisticsData: serializeAws_json1_1BooleanColumnStatisticsData(input.BooleanColumnStatisticsData, context),
        }),
        ...(input.DateColumnStatisticsData != null && {
            DateColumnStatisticsData: serializeAws_json1_1DateColumnStatisticsData(input.DateColumnStatisticsData, context),
        }),
        ...(input.DecimalColumnStatisticsData != null && {
            DecimalColumnStatisticsData: serializeAws_json1_1DecimalColumnStatisticsData(input.DecimalColumnStatisticsData, context),
        }),
        ...(input.DoubleColumnStatisticsData != null && {
            DoubleColumnStatisticsData: serializeAws_json1_1DoubleColumnStatisticsData(input.DoubleColumnStatisticsData, context),
        }),
        ...(input.LongColumnStatisticsData != null && {
            LongColumnStatisticsData: serializeAws_json1_1LongColumnStatisticsData(input.LongColumnStatisticsData, context),
        }),
        ...(input.StringColumnStatisticsData != null && {
            StringColumnStatisticsData: serializeAws_json1_1StringColumnStatisticsData(input.StringColumnStatisticsData, context),
        }),
        ...(input.Type != null && { Type: input.Type }),
    };
};
const serializeAws_json1_1ColumnValueStringList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1Condition = (input, context) => {
    return {
        ...(input.CrawlState != null && { CrawlState: input.CrawlState }),
        ...(input.CrawlerName != null && { CrawlerName: input.CrawlerName }),
        ...(input.JobName != null && { JobName: input.JobName }),
        ...(input.LogicalOperator != null && { LogicalOperator: input.LogicalOperator }),
        ...(input.State != null && { State: input.State }),
    };
};
const serializeAws_json1_1ConditionList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1Condition(entry, context);
    });
};
const serializeAws_json1_1ConnectionInput = (input, context) => {
    return {
        ...(input.ConnectionProperties != null && {
            ConnectionProperties: serializeAws_json1_1ConnectionProperties(input.ConnectionProperties, context),
        }),
        ...(input.ConnectionType != null && { ConnectionType: input.ConnectionType }),
        ...(input.Description != null && { Description: input.Description }),
        ...(input.MatchCriteria != null && {
            MatchCriteria: serializeAws_json1_1MatchCriteria(input.MatchCriteria, context),
        }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.PhysicalConnectionRequirements != null && {
            PhysicalConnectionRequirements: serializeAws_json1_1PhysicalConnectionRequirements(input.PhysicalConnectionRequirements, context),
        }),
    };
};
const serializeAws_json1_1ConnectionPasswordEncryption = (input, context) => {
    return {
        ...(input.AwsKmsKeyId != null && { AwsKmsKeyId: input.AwsKmsKeyId }),
        ...(input.ReturnConnectionPasswordEncrypted != null && {
            ReturnConnectionPasswordEncrypted: input.ReturnConnectionPasswordEncrypted,
        }),
    };
};
const serializeAws_json1_1ConnectionProperties = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
const serializeAws_json1_1ConnectionsList = (input, context) => {
    return {
        ...(input.Connections != null && {
            Connections: serializeAws_json1_1OrchestrationStringList(input.Connections, context),
        }),
    };
};
const serializeAws_json1_1ContextWords = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1CrawlerNameList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1CrawlerTargets = (input, context) => {
    return {
        ...(input.CatalogTargets != null && {
            CatalogTargets: serializeAws_json1_1CatalogTargetList(input.CatalogTargets, context),
        }),
        ...(input.DeltaTargets != null && {
            DeltaTargets: serializeAws_json1_1DeltaTargetList(input.DeltaTargets, context),
        }),
        ...(input.DynamoDBTargets != null && {
            DynamoDBTargets: serializeAws_json1_1DynamoDBTargetList(input.DynamoDBTargets, context),
        }),
        ...(input.JdbcTargets != null && { JdbcTargets: serializeAws_json1_1JdbcTargetList(input.JdbcTargets, context) }),
        ...(input.MongoDBTargets != null && {
            MongoDBTargets: serializeAws_json1_1MongoDBTargetList(input.MongoDBTargets, context),
        }),
        ...(input.S3Targets != null && { S3Targets: serializeAws_json1_1S3TargetList(input.S3Targets, context) }),
    };
};
const serializeAws_json1_1CrawlsFilter = (input, context) => {
    return {
        ...(input.FieldName != null && { FieldName: input.FieldName }),
        ...(input.FieldValue != null && { FieldValue: input.FieldValue }),
        ...(input.FilterOperator != null && { FilterOperator: input.FilterOperator }),
    };
};
const serializeAws_json1_1CrawlsFilterList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1CrawlsFilter(entry, context);
    });
};
const serializeAws_json1_1CreateBlueprintRequest = (input, context) => {
    return {
        ...(input.BlueprintLocation != null && { BlueprintLocation: input.BlueprintLocation }),
        ...(input.Description != null && { Description: input.Description }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Tags != null && { Tags: serializeAws_json1_1TagsMap(input.Tags, context) }),
    };
};
const serializeAws_json1_1CreateClassifierRequest = (input, context) => {
    return {
        ...(input.CsvClassifier != null && {
            CsvClassifier: serializeAws_json1_1CreateCsvClassifierRequest(input.CsvClassifier, context),
        }),
        ...(input.GrokClassifier != null && {
            GrokClassifier: serializeAws_json1_1CreateGrokClassifierRequest(input.GrokClassifier, context),
        }),
        ...(input.JsonClassifier != null && {
            JsonClassifier: serializeAws_json1_1CreateJsonClassifierRequest(input.JsonClassifier, context),
        }),
        ...(input.XMLClassifier != null && {
            XMLClassifier: serializeAws_json1_1CreateXMLClassifierRequest(input.XMLClassifier, context),
        }),
    };
};
const serializeAws_json1_1CreateConnectionRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.ConnectionInput != null && {
            ConnectionInput: serializeAws_json1_1ConnectionInput(input.ConnectionInput, context),
        }),
        ...(input.Tags != null && { Tags: serializeAws_json1_1TagsMap(input.Tags, context) }),
    };
};
const serializeAws_json1_1CreateCrawlerRequest = (input, context) => {
    return {
        ...(input.Classifiers != null && {
            Classifiers: serializeAws_json1_1ClassifierNameList(input.Classifiers, context),
        }),
        ...(input.Configuration != null && { Configuration: input.Configuration }),
        ...(input.CrawlerSecurityConfiguration != null && {
            CrawlerSecurityConfiguration: input.CrawlerSecurityConfiguration,
        }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.Description != null && { Description: input.Description }),
        ...(input.LakeFormationConfiguration != null && {
            LakeFormationConfiguration: serializeAws_json1_1LakeFormationConfiguration(input.LakeFormationConfiguration, context),
        }),
        ...(input.LineageConfiguration != null && {
            LineageConfiguration: serializeAws_json1_1LineageConfiguration(input.LineageConfiguration, context),
        }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.RecrawlPolicy != null && {
            RecrawlPolicy: serializeAws_json1_1RecrawlPolicy(input.RecrawlPolicy, context),
        }),
        ...(input.Role != null && { Role: input.Role }),
        ...(input.Schedule != null && { Schedule: input.Schedule }),
        ...(input.SchemaChangePolicy != null && {
            SchemaChangePolicy: serializeAws_json1_1SchemaChangePolicy(input.SchemaChangePolicy, context),
        }),
        ...(input.TablePrefix != null && { TablePrefix: input.TablePrefix }),
        ...(input.Tags != null && { Tags: serializeAws_json1_1TagsMap(input.Tags, context) }),
        ...(input.Targets != null && { Targets: serializeAws_json1_1CrawlerTargets(input.Targets, context) }),
    };
};
const serializeAws_json1_1CreateCsvClassifierRequest = (input, context) => {
    return {
        ...(input.AllowSingleColumn != null && { AllowSingleColumn: input.AllowSingleColumn }),
        ...(input.ContainsHeader != null && { ContainsHeader: input.ContainsHeader }),
        ...(input.CustomDatatypeConfigured != null && { CustomDatatypeConfigured: input.CustomDatatypeConfigured }),
        ...(input.CustomDatatypes != null && {
            CustomDatatypes: serializeAws_json1_1CustomDatatypes(input.CustomDatatypes, context),
        }),
        ...(input.Delimiter != null && { Delimiter: input.Delimiter }),
        ...(input.DisableValueTrimming != null && { DisableValueTrimming: input.DisableValueTrimming }),
        ...(input.Header != null && { Header: serializeAws_json1_1CsvHeader(input.Header, context) }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.QuoteSymbol != null && { QuoteSymbol: input.QuoteSymbol }),
    };
};
const serializeAws_json1_1CreateCustomEntityTypeRequest = (input, context) => {
    return {
        ...(input.ContextWords != null && { ContextWords: serializeAws_json1_1ContextWords(input.ContextWords, context) }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.RegexString != null && { RegexString: input.RegexString }),
    };
};
const serializeAws_json1_1CreateDatabaseRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.DatabaseInput != null && {
            DatabaseInput: serializeAws_json1_1DatabaseInput(input.DatabaseInput, context),
        }),
        ...(input.Tags != null && { Tags: serializeAws_json1_1TagsMap(input.Tags, context) }),
    };
};
const serializeAws_json1_1CreateDataQualityRulesetRequest = (input, context) => {
    return {
        ...(input.ClientToken != null && { ClientToken: input.ClientToken }),
        ...(input.Description != null && { Description: input.Description }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Ruleset != null && { Ruleset: input.Ruleset }),
        ...(input.Tags != null && { Tags: serializeAws_json1_1TagsMap(input.Tags, context) }),
        ...(input.TargetTable != null && {
            TargetTable: serializeAws_json1_1DataQualityTargetTable(input.TargetTable, context),
        }),
    };
};
const serializeAws_json1_1CreateDevEndpointRequest = (input, context) => {
    return {
        ...(input.Arguments != null && { Arguments: serializeAws_json1_1MapValue(input.Arguments, context) }),
        ...(input.EndpointName != null && { EndpointName: input.EndpointName }),
        ...(input.ExtraJarsS3Path != null && { ExtraJarsS3Path: input.ExtraJarsS3Path }),
        ...(input.ExtraPythonLibsS3Path != null && { ExtraPythonLibsS3Path: input.ExtraPythonLibsS3Path }),
        ...(input.GlueVersion != null && { GlueVersion: input.GlueVersion }),
        ...(input.NumberOfNodes != null && { NumberOfNodes: input.NumberOfNodes }),
        ...(input.NumberOfWorkers != null && { NumberOfWorkers: input.NumberOfWorkers }),
        ...(input.PublicKey != null && { PublicKey: input.PublicKey }),
        ...(input.PublicKeys != null && { PublicKeys: serializeAws_json1_1PublicKeysList(input.PublicKeys, context) }),
        ...(input.RoleArn != null && { RoleArn: input.RoleArn }),
        ...(input.SecurityConfiguration != null && { SecurityConfiguration: input.SecurityConfiguration }),
        ...(input.SecurityGroupIds != null && {
            SecurityGroupIds: serializeAws_json1_1StringList(input.SecurityGroupIds, context),
        }),
        ...(input.SubnetId != null && { SubnetId: input.SubnetId }),
        ...(input.Tags != null && { Tags: serializeAws_json1_1TagsMap(input.Tags, context) }),
        ...(input.WorkerType != null && { WorkerType: input.WorkerType }),
    };
};
const serializeAws_json1_1CreateGrokClassifierRequest = (input, context) => {
    return {
        ...(input.Classification != null && { Classification: input.Classification }),
        ...(input.CustomPatterns != null && { CustomPatterns: input.CustomPatterns }),
        ...(input.GrokPattern != null && { GrokPattern: input.GrokPattern }),
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1CreateJobRequest = (input, context) => {
    return {
        ...(input.AllocatedCapacity != null && { AllocatedCapacity: input.AllocatedCapacity }),
        ...(input.CodeGenConfigurationNodes != null && {
            CodeGenConfigurationNodes: serializeAws_json1_1CodeGenConfigurationNodes(input.CodeGenConfigurationNodes, context),
        }),
        ...(input.Command != null && { Command: serializeAws_json1_1JobCommand(input.Command, context) }),
        ...(input.Connections != null && { Connections: serializeAws_json1_1ConnectionsList(input.Connections, context) }),
        ...(input.DefaultArguments != null && {
            DefaultArguments: serializeAws_json1_1GenericMap(input.DefaultArguments, context),
        }),
        ...(input.Description != null && { Description: input.Description }),
        ...(input.ExecutionClass != null && { ExecutionClass: input.ExecutionClass }),
        ...(input.ExecutionProperty != null && {
            ExecutionProperty: serializeAws_json1_1ExecutionProperty(input.ExecutionProperty, context),
        }),
        ...(input.GlueVersion != null && { GlueVersion: input.GlueVersion }),
        ...(input.LogUri != null && { LogUri: input.LogUri }),
        ...(input.MaxCapacity != null && { MaxCapacity: __serializeFloat(input.MaxCapacity) }),
        ...(input.MaxRetries != null && { MaxRetries: input.MaxRetries }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.NonOverridableArguments != null && {
            NonOverridableArguments: serializeAws_json1_1GenericMap(input.NonOverridableArguments, context),
        }),
        ...(input.NotificationProperty != null && {
            NotificationProperty: serializeAws_json1_1NotificationProperty(input.NotificationProperty, context),
        }),
        ...(input.NumberOfWorkers != null && { NumberOfWorkers: input.NumberOfWorkers }),
        ...(input.Role != null && { Role: input.Role }),
        ...(input.SecurityConfiguration != null && { SecurityConfiguration: input.SecurityConfiguration }),
        ...(input.SourceControlDetails != null && {
            SourceControlDetails: serializeAws_json1_1SourceControlDetails(input.SourceControlDetails, context),
        }),
        ...(input.Tags != null && { Tags: serializeAws_json1_1TagsMap(input.Tags, context) }),
        ...(input.Timeout != null && { Timeout: input.Timeout }),
        ...(input.WorkerType != null && { WorkerType: input.WorkerType }),
    };
};
const serializeAws_json1_1CreateJsonClassifierRequest = (input, context) => {
    return {
        ...(input.JsonPath != null && { JsonPath: input.JsonPath }),
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1CreateMLTransformRequest = (input, context) => {
    return {
        ...(input.Description != null && { Description: input.Description }),
        ...(input.GlueVersion != null && { GlueVersion: input.GlueVersion }),
        ...(input.InputRecordTables != null && {
            InputRecordTables: serializeAws_json1_1GlueTables(input.InputRecordTables, context),
        }),
        ...(input.MaxCapacity != null && { MaxCapacity: __serializeFloat(input.MaxCapacity) }),
        ...(input.MaxRetries != null && { MaxRetries: input.MaxRetries }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.NumberOfWorkers != null && { NumberOfWorkers: input.NumberOfWorkers }),
        ...(input.Parameters != null && { Parameters: serializeAws_json1_1TransformParameters(input.Parameters, context) }),
        ...(input.Role != null && { Role: input.Role }),
        ...(input.Tags != null && { Tags: serializeAws_json1_1TagsMap(input.Tags, context) }),
        ...(input.Timeout != null && { Timeout: input.Timeout }),
        ...(input.TransformEncryption != null && {
            TransformEncryption: serializeAws_json1_1TransformEncryption(input.TransformEncryption, context),
        }),
        ...(input.WorkerType != null && { WorkerType: input.WorkerType }),
    };
};
const serializeAws_json1_1CreatePartitionIndexRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.PartitionIndex != null && {
            PartitionIndex: serializeAws_json1_1PartitionIndex(input.PartitionIndex, context),
        }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const serializeAws_json1_1CreatePartitionRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.PartitionInput != null && {
            PartitionInput: serializeAws_json1_1PartitionInput(input.PartitionInput, context),
        }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const serializeAws_json1_1CreateRegistryInput = (input, context) => {
    return {
        ...(input.Description != null && { Description: input.Description }),
        ...(input.RegistryName != null && { RegistryName: input.RegistryName }),
        ...(input.Tags != null && { Tags: serializeAws_json1_1TagsMap(input.Tags, context) }),
    };
};
const serializeAws_json1_1CreateSchemaInput = (input, context) => {
    return {
        ...(input.Compatibility != null && { Compatibility: input.Compatibility }),
        ...(input.DataFormat != null && { DataFormat: input.DataFormat }),
        ...(input.Description != null && { Description: input.Description }),
        ...(input.RegistryId != null && { RegistryId: serializeAws_json1_1RegistryId(input.RegistryId, context) }),
        ...(input.SchemaDefinition != null && { SchemaDefinition: input.SchemaDefinition }),
        ...(input.SchemaName != null && { SchemaName: input.SchemaName }),
        ...(input.Tags != null && { Tags: serializeAws_json1_1TagsMap(input.Tags, context) }),
    };
};
const serializeAws_json1_1CreateScriptRequest = (input, context) => {
    return {
        ...(input.DagEdges != null && { DagEdges: serializeAws_json1_1DagEdges(input.DagEdges, context) }),
        ...(input.DagNodes != null && { DagNodes: serializeAws_json1_1DagNodes(input.DagNodes, context) }),
        ...(input.Language != null && { Language: input.Language }),
    };
};
const serializeAws_json1_1CreateSecurityConfigurationRequest = (input, context) => {
    return {
        ...(input.EncryptionConfiguration != null && {
            EncryptionConfiguration: serializeAws_json1_1EncryptionConfiguration(input.EncryptionConfiguration, context),
        }),
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1CreateSessionRequest = (input, context) => {
    return {
        ...(input.Command != null && { Command: serializeAws_json1_1SessionCommand(input.Command, context) }),
        ...(input.Connections != null && { Connections: serializeAws_json1_1ConnectionsList(input.Connections, context) }),
        ...(input.DefaultArguments != null && {
            DefaultArguments: serializeAws_json1_1OrchestrationArgumentsMap(input.DefaultArguments, context),
        }),
        ...(input.Description != null && { Description: input.Description }),
        ...(input.GlueVersion != null && { GlueVersion: input.GlueVersion }),
        ...(input.Id != null && { Id: input.Id }),
        ...(input.IdleTimeout != null && { IdleTimeout: input.IdleTimeout }),
        ...(input.MaxCapacity != null && { MaxCapacity: __serializeFloat(input.MaxCapacity) }),
        ...(input.NumberOfWorkers != null && { NumberOfWorkers: input.NumberOfWorkers }),
        ...(input.RequestOrigin != null && { RequestOrigin: input.RequestOrigin }),
        ...(input.Role != null && { Role: input.Role }),
        ...(input.SecurityConfiguration != null && { SecurityConfiguration: input.SecurityConfiguration }),
        ...(input.Tags != null && { Tags: serializeAws_json1_1TagsMap(input.Tags, context) }),
        ...(input.Timeout != null && { Timeout: input.Timeout }),
        ...(input.WorkerType != null && { WorkerType: input.WorkerType }),
    };
};
const serializeAws_json1_1CreateTableRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.PartitionIndexes != null && {
            PartitionIndexes: serializeAws_json1_1PartitionIndexList(input.PartitionIndexes, context),
        }),
        ...(input.TableInput != null && { TableInput: serializeAws_json1_1TableInput(input.TableInput, context) }),
        ...(input.TransactionId != null && { TransactionId: input.TransactionId }),
    };
};
const serializeAws_json1_1CreateTriggerRequest = (input, context) => {
    return {
        ...(input.Actions != null && { Actions: serializeAws_json1_1ActionList(input.Actions, context) }),
        ...(input.Description != null && { Description: input.Description }),
        ...(input.EventBatchingCondition != null && {
            EventBatchingCondition: serializeAws_json1_1EventBatchingCondition(input.EventBatchingCondition, context),
        }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Predicate != null && { Predicate: serializeAws_json1_1Predicate(input.Predicate, context) }),
        ...(input.Schedule != null && { Schedule: input.Schedule }),
        ...(input.StartOnCreation != null && { StartOnCreation: input.StartOnCreation }),
        ...(input.Tags != null && { Tags: serializeAws_json1_1TagsMap(input.Tags, context) }),
        ...(input.Type != null && { Type: input.Type }),
        ...(input.WorkflowName != null && { WorkflowName: input.WorkflowName }),
    };
};
const serializeAws_json1_1CreateUserDefinedFunctionRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.FunctionInput != null && {
            FunctionInput: serializeAws_json1_1UserDefinedFunctionInput(input.FunctionInput, context),
        }),
    };
};
const serializeAws_json1_1CreateWorkflowRequest = (input, context) => {
    return {
        ...(input.DefaultRunProperties != null && {
            DefaultRunProperties: serializeAws_json1_1WorkflowRunProperties(input.DefaultRunProperties, context),
        }),
        ...(input.Description != null && { Description: input.Description }),
        ...(input.MaxConcurrentRuns != null && { MaxConcurrentRuns: input.MaxConcurrentRuns }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Tags != null && { Tags: serializeAws_json1_1TagsMap(input.Tags, context) }),
    };
};
const serializeAws_json1_1CreateXMLClassifierRequest = (input, context) => {
    return {
        ...(input.Classification != null && { Classification: input.Classification }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.RowTag != null && { RowTag: input.RowTag }),
    };
};
const serializeAws_json1_1CsvHeader = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1CustomCode = (input, context) => {
    return {
        ...(input.ClassName != null && { ClassName: input.ClassName }),
        ...(input.Code != null && { Code: input.Code }),
        ...(input.Inputs != null && { Inputs: serializeAws_json1_1ManyInputs(input.Inputs, context) }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.OutputSchemas != null && {
            OutputSchemas: serializeAws_json1_1GlueSchemas(input.OutputSchemas, context),
        }),
    };
};
const serializeAws_json1_1CustomDatatypes = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1CustomEntityTypeNames = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1DagEdges = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1CodeGenEdge(entry, context);
    });
};
const serializeAws_json1_1DagNodes = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1CodeGenNode(entry, context);
    });
};
const serializeAws_json1_1DatabaseIdentifier = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
    };
};
const serializeAws_json1_1DatabaseInput = (input, context) => {
    return {
        ...(input.CreateTableDefaultPermissions != null && {
            CreateTableDefaultPermissions: serializeAws_json1_1PrincipalPermissionsList(input.CreateTableDefaultPermissions, context),
        }),
        ...(input.Description != null && { Description: input.Description }),
        ...(input.LocationUri != null && { LocationUri: input.LocationUri }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Parameters != null && { Parameters: serializeAws_json1_1ParametersMap(input.Parameters, context) }),
        ...(input.TargetDatabase != null && {
            TargetDatabase: serializeAws_json1_1DatabaseIdentifier(input.TargetDatabase, context),
        }),
    };
};
const serializeAws_json1_1DataCatalogEncryptionSettings = (input, context) => {
    return {
        ...(input.ConnectionPasswordEncryption != null && {
            ConnectionPasswordEncryption: serializeAws_json1_1ConnectionPasswordEncryption(input.ConnectionPasswordEncryption, context),
        }),
        ...(input.EncryptionAtRest != null && {
            EncryptionAtRest: serializeAws_json1_1EncryptionAtRest(input.EncryptionAtRest, context),
        }),
    };
};
const serializeAws_json1_1DataLakePrincipal = (input, context) => {
    return {
        ...(input.DataLakePrincipalIdentifier != null && {
            DataLakePrincipalIdentifier: input.DataLakePrincipalIdentifier,
        }),
    };
};
const serializeAws_json1_1DataQualityEvaluationRunAdditionalRunOptions = (input, context) => {
    return {
        ...(input.CloudWatchMetricsEnabled != null && { CloudWatchMetricsEnabled: input.CloudWatchMetricsEnabled }),
        ...(input.ResultsS3Prefix != null && { ResultsS3Prefix: input.ResultsS3Prefix }),
    };
};
const serializeAws_json1_1DataQualityResultFilterCriteria = (input, context) => {
    return {
        ...(input.DataSource != null && { DataSource: serializeAws_json1_1DataSource(input.DataSource, context) }),
        ...(input.JobName != null && { JobName: input.JobName }),
        ...(input.JobRunId != null && { JobRunId: input.JobRunId }),
        ...(input.StartedAfter != null && { StartedAfter: Math.round(input.StartedAfter.getTime() / 1000) }),
        ...(input.StartedBefore != null && { StartedBefore: Math.round(input.StartedBefore.getTime() / 1000) }),
    };
};
const serializeAws_json1_1DataQualityResultIds = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1DataQualityRuleRecommendationRunFilter = (input, context) => {
    return {
        ...(input.DataSource != null && { DataSource: serializeAws_json1_1DataSource(input.DataSource, context) }),
        ...(input.StartedAfter != null && { StartedAfter: Math.round(input.StartedAfter.getTime() / 1000) }),
        ...(input.StartedBefore != null && { StartedBefore: Math.round(input.StartedBefore.getTime() / 1000) }),
    };
};
const serializeAws_json1_1DataQualityRulesetEvaluationRunFilter = (input, context) => {
    return {
        ...(input.DataSource != null && { DataSource: serializeAws_json1_1DataSource(input.DataSource, context) }),
        ...(input.StartedAfter != null && { StartedAfter: Math.round(input.StartedAfter.getTime() / 1000) }),
        ...(input.StartedBefore != null && { StartedBefore: Math.round(input.StartedBefore.getTime() / 1000) }),
    };
};
const serializeAws_json1_1DataQualityRulesetFilterCriteria = (input, context) => {
    return {
        ...(input.CreatedAfter != null && { CreatedAfter: Math.round(input.CreatedAfter.getTime() / 1000) }),
        ...(input.CreatedBefore != null && { CreatedBefore: Math.round(input.CreatedBefore.getTime() / 1000) }),
        ...(input.Description != null && { Description: input.Description }),
        ...(input.LastModifiedAfter != null && { LastModifiedAfter: Math.round(input.LastModifiedAfter.getTime() / 1000) }),
        ...(input.LastModifiedBefore != null && {
            LastModifiedBefore: Math.round(input.LastModifiedBefore.getTime() / 1000),
        }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.TargetTable != null && {
            TargetTable: serializeAws_json1_1DataQualityTargetTable(input.TargetTable, context),
        }),
    };
};
const serializeAws_json1_1DataQualityTargetTable = (input, context) => {
    return {
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const serializeAws_json1_1DataSource = (input, context) => {
    return {
        ...(input.GlueTable != null && { GlueTable: serializeAws_json1_1GlueTable(input.GlueTable, context) }),
    };
};
const serializeAws_json1_1Datatype = (input, context) => {
    return {
        ...(input.Id != null && { Id: input.Id }),
        ...(input.Label != null && { Label: input.Label }),
    };
};
const serializeAws_json1_1DateColumnStatisticsData = (input, context) => {
    return {
        ...(input.MaximumValue != null && { MaximumValue: Math.round(input.MaximumValue.getTime() / 1000) }),
        ...(input.MinimumValue != null && { MinimumValue: Math.round(input.MinimumValue.getTime() / 1000) }),
        ...(input.NumberOfDistinctValues != null && { NumberOfDistinctValues: input.NumberOfDistinctValues }),
        ...(input.NumberOfNulls != null && { NumberOfNulls: input.NumberOfNulls }),
    };
};
const serializeAws_json1_1DecimalColumnStatisticsData = (input, context) => {
    return {
        ...(input.MaximumValue != null && { MaximumValue: serializeAws_json1_1DecimalNumber(input.MaximumValue, context) }),
        ...(input.MinimumValue != null && { MinimumValue: serializeAws_json1_1DecimalNumber(input.MinimumValue, context) }),
        ...(input.NumberOfDistinctValues != null && { NumberOfDistinctValues: input.NumberOfDistinctValues }),
        ...(input.NumberOfNulls != null && { NumberOfNulls: input.NumberOfNulls }),
    };
};
const serializeAws_json1_1DecimalNumber = (input, context) => {
    return {
        ...(input.Scale != null && { Scale: input.Scale }),
        ...(input.UnscaledValue != null && { UnscaledValue: context.base64Encoder(input.UnscaledValue) }),
    };
};
const serializeAws_json1_1DeleteBlueprintRequest = (input, context) => {
    return {
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1DeleteClassifierRequest = (input, context) => {
    return {
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1DeleteColumnStatisticsForPartitionRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.ColumnName != null && { ColumnName: input.ColumnName }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.PartitionValues != null && {
            PartitionValues: serializeAws_json1_1ValueStringList(input.PartitionValues, context),
        }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const serializeAws_json1_1DeleteColumnStatisticsForTableRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.ColumnName != null && { ColumnName: input.ColumnName }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const serializeAws_json1_1DeleteConnectionNameList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1DeleteConnectionRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.ConnectionName != null && { ConnectionName: input.ConnectionName }),
    };
};
const serializeAws_json1_1DeleteCrawlerRequest = (input, context) => {
    return {
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1DeleteCustomEntityTypeRequest = (input, context) => {
    return {
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1DeleteDatabaseRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1DeleteDataQualityRulesetRequest = (input, context) => {
    return {
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1DeleteDevEndpointRequest = (input, context) => {
    return {
        ...(input.EndpointName != null && { EndpointName: input.EndpointName }),
    };
};
const serializeAws_json1_1DeleteJobRequest = (input, context) => {
    return {
        ...(input.JobName != null && { JobName: input.JobName }),
    };
};
const serializeAws_json1_1DeleteMLTransformRequest = (input, context) => {
    return {
        ...(input.TransformId != null && { TransformId: input.TransformId }),
    };
};
const serializeAws_json1_1DeletePartitionIndexRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.IndexName != null && { IndexName: input.IndexName }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const serializeAws_json1_1DeletePartitionRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.PartitionValues != null && {
            PartitionValues: serializeAws_json1_1ValueStringList(input.PartitionValues, context),
        }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const serializeAws_json1_1DeleteRegistryInput = (input, context) => {
    return {
        ...(input.RegistryId != null && { RegistryId: serializeAws_json1_1RegistryId(input.RegistryId, context) }),
    };
};
const serializeAws_json1_1DeleteResourcePolicyRequest = (input, context) => {
    return {
        ...(input.PolicyHashCondition != null && { PolicyHashCondition: input.PolicyHashCondition }),
        ...(input.ResourceArn != null && { ResourceArn: input.ResourceArn }),
    };
};
const serializeAws_json1_1DeleteSchemaInput = (input, context) => {
    return {
        ...(input.SchemaId != null && { SchemaId: serializeAws_json1_1SchemaId(input.SchemaId, context) }),
    };
};
const serializeAws_json1_1DeleteSchemaVersionsInput = (input, context) => {
    return {
        ...(input.SchemaId != null && { SchemaId: serializeAws_json1_1SchemaId(input.SchemaId, context) }),
        ...(input.Versions != null && { Versions: input.Versions }),
    };
};
const serializeAws_json1_1DeleteSecurityConfigurationRequest = (input, context) => {
    return {
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1DeleteSessionRequest = (input, context) => {
    return {
        ...(input.Id != null && { Id: input.Id }),
        ...(input.RequestOrigin != null && { RequestOrigin: input.RequestOrigin }),
    };
};
const serializeAws_json1_1DeleteTableRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.TransactionId != null && { TransactionId: input.TransactionId }),
    };
};
const serializeAws_json1_1DeleteTableVersionRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.TableName != null && { TableName: input.TableName }),
        ...(input.VersionId != null && { VersionId: input.VersionId }),
    };
};
const serializeAws_json1_1DeleteTriggerRequest = (input, context) => {
    return {
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1DeleteUserDefinedFunctionRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.FunctionName != null && { FunctionName: input.FunctionName }),
    };
};
const serializeAws_json1_1DeleteWorkflowRequest = (input, context) => {
    return {
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1DeltaTarget = (input, context) => {
    return {
        ...(input.ConnectionName != null && { ConnectionName: input.ConnectionName }),
        ...(input.CreateNativeDeltaTable != null && { CreateNativeDeltaTable: input.CreateNativeDeltaTable }),
        ...(input.DeltaTables != null && { DeltaTables: serializeAws_json1_1PathList(input.DeltaTables, context) }),
        ...(input.WriteManifest != null && { WriteManifest: input.WriteManifest }),
    };
};
const serializeAws_json1_1DeltaTargetList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1DeltaTarget(entry, context);
    });
};
const serializeAws_json1_1DevEndpointCustomLibraries = (input, context) => {
    return {
        ...(input.ExtraJarsS3Path != null && { ExtraJarsS3Path: input.ExtraJarsS3Path }),
        ...(input.ExtraPythonLibsS3Path != null && { ExtraPythonLibsS3Path: input.ExtraPythonLibsS3Path }),
    };
};
const serializeAws_json1_1DevEndpointNames = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1DirectJDBCSource = (input, context) => {
    return {
        ...(input.ConnectionName != null && { ConnectionName: input.ConnectionName }),
        ...(input.ConnectionType != null && { ConnectionType: input.ConnectionType }),
        ...(input.Database != null && { Database: input.Database }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.RedshiftTmpDir != null && { RedshiftTmpDir: input.RedshiftTmpDir }),
        ...(input.Table != null && { Table: input.Table }),
    };
};
const serializeAws_json1_1DirectKafkaSource = (input, context) => {
    return {
        ...(input.DataPreviewOptions != null && {
            DataPreviewOptions: serializeAws_json1_1StreamingDataPreviewOptions(input.DataPreviewOptions, context),
        }),
        ...(input.DetectSchema != null && { DetectSchema: input.DetectSchema }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.StreamingOptions != null && {
            StreamingOptions: serializeAws_json1_1KafkaStreamingSourceOptions(input.StreamingOptions, context),
        }),
        ...(input.WindowSize != null && { WindowSize: input.WindowSize }),
    };
};
const serializeAws_json1_1DirectKinesisSource = (input, context) => {
    return {
        ...(input.DataPreviewOptions != null && {
            DataPreviewOptions: serializeAws_json1_1StreamingDataPreviewOptions(input.DataPreviewOptions, context),
        }),
        ...(input.DetectSchema != null && { DetectSchema: input.DetectSchema }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.StreamingOptions != null && {
            StreamingOptions: serializeAws_json1_1KinesisStreamingSourceOptions(input.StreamingOptions, context),
        }),
        ...(input.WindowSize != null && { WindowSize: input.WindowSize }),
    };
};
const serializeAws_json1_1DirectSchemaChangePolicy = (input, context) => {
    return {
        ...(input.Database != null && { Database: input.Database }),
        ...(input.EnableUpdateCatalog != null && { EnableUpdateCatalog: input.EnableUpdateCatalog }),
        ...(input.Table != null && { Table: input.Table }),
        ...(input.UpdateBehavior != null && { UpdateBehavior: input.UpdateBehavior }),
    };
};
const serializeAws_json1_1DoubleColumnStatisticsData = (input, context) => {
    return {
        ...(input.MaximumValue != null && { MaximumValue: __serializeFloat(input.MaximumValue) }),
        ...(input.MinimumValue != null && { MinimumValue: __serializeFloat(input.MinimumValue) }),
        ...(input.NumberOfDistinctValues != null && { NumberOfDistinctValues: input.NumberOfDistinctValues }),
        ...(input.NumberOfNulls != null && { NumberOfNulls: input.NumberOfNulls }),
    };
};
const serializeAws_json1_1DQResultsPublishingOptions = (input, context) => {
    return {
        ...(input.CloudWatchMetricsEnabled != null && { CloudWatchMetricsEnabled: input.CloudWatchMetricsEnabled }),
        ...(input.EvaluationContext != null && { EvaluationContext: input.EvaluationContext }),
        ...(input.ResultsPublishingEnabled != null && { ResultsPublishingEnabled: input.ResultsPublishingEnabled }),
        ...(input.ResultsS3Prefix != null && { ResultsS3Prefix: input.ResultsS3Prefix }),
    };
};
const serializeAws_json1_1DQStopJobOnFailureOptions = (input, context) => {
    return {
        ...(input.StopJobOnFailureTiming != null && { StopJobOnFailureTiming: input.StopJobOnFailureTiming }),
    };
};
const serializeAws_json1_1DropDuplicates = (input, context) => {
    return {
        ...(input.Columns != null && { Columns: serializeAws_json1_1LimitedPathList(input.Columns, context) }),
        ...(input.Inputs != null && { Inputs: serializeAws_json1_1OneInput(input.Inputs, context) }),
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1DropFields = (input, context) => {
    return {
        ...(input.Inputs != null && { Inputs: serializeAws_json1_1OneInput(input.Inputs, context) }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Paths != null && { Paths: serializeAws_json1_1GlueStudioPathList(input.Paths, context) }),
    };
};
const serializeAws_json1_1DropNullFields = (input, context) => {
    return {
        ...(input.Inputs != null && { Inputs: serializeAws_json1_1OneInput(input.Inputs, context) }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.NullCheckBoxList != null && {
            NullCheckBoxList: serializeAws_json1_1NullCheckBoxList(input.NullCheckBoxList, context),
        }),
        ...(input.NullTextList != null && {
            NullTextList: serializeAws_json1_1NullValueFields(input.NullTextList, context),
        }),
    };
};
const serializeAws_json1_1DynamicTransform = (input, context) => {
    return {
        ...(input.FunctionName != null && { FunctionName: input.FunctionName }),
        ...(input.Inputs != null && { Inputs: serializeAws_json1_1OneInput(input.Inputs, context) }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Parameters != null && {
            Parameters: serializeAws_json1_1TransformConfigParameterList(input.Parameters, context),
        }),
        ...(input.Path != null && { Path: input.Path }),
        ...(input.TransformName != null && { TransformName: input.TransformName }),
        ...(input.Version != null && { Version: input.Version }),
    };
};
const serializeAws_json1_1DynamoDBCatalogSource = (input, context) => {
    return {
        ...(input.Database != null && { Database: input.Database }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Table != null && { Table: input.Table }),
    };
};
const serializeAws_json1_1DynamoDBTarget = (input, context) => {
    return {
        ...(input.Path != null && { Path: input.Path }),
        ...(input.scanAll != null && { scanAll: input.scanAll }),
        ...(input.scanRate != null && { scanRate: __serializeFloat(input.scanRate) }),
    };
};
const serializeAws_json1_1DynamoDBTargetList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1DynamoDBTarget(entry, context);
    });
};
const serializeAws_json1_1EnableAdditionalMetadata = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1EnclosedInStringProperties = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1EnclosedInStringPropertiesMinOne = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1EncryptionAtRest = (input, context) => {
    return {
        ...(input.CatalogEncryptionMode != null && { CatalogEncryptionMode: input.CatalogEncryptionMode }),
        ...(input.SseAwsKmsKeyId != null && { SseAwsKmsKeyId: input.SseAwsKmsKeyId }),
    };
};
const serializeAws_json1_1EncryptionConfiguration = (input, context) => {
    return {
        ...(input.CloudWatchEncryption != null && {
            CloudWatchEncryption: serializeAws_json1_1CloudWatchEncryption(input.CloudWatchEncryption, context),
        }),
        ...(input.JobBookmarksEncryption != null && {
            JobBookmarksEncryption: serializeAws_json1_1JobBookmarksEncryption(input.JobBookmarksEncryption, context),
        }),
        ...(input.S3Encryption != null && {
            S3Encryption: serializeAws_json1_1S3EncryptionList(input.S3Encryption, context),
        }),
    };
};
const serializeAws_json1_1EvaluateDataQuality = (input, context) => {
    return {
        ...(input.Inputs != null && { Inputs: serializeAws_json1_1OneInput(input.Inputs, context) }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Output != null && { Output: input.Output }),
        ...(input.PublishingOptions != null && {
            PublishingOptions: serializeAws_json1_1DQResultsPublishingOptions(input.PublishingOptions, context),
        }),
        ...(input.Ruleset != null && { Ruleset: input.Ruleset }),
        ...(input.StopJobOnFailureOptions != null && {
            StopJobOnFailureOptions: serializeAws_json1_1DQStopJobOnFailureOptions(input.StopJobOnFailureOptions, context),
        }),
    };
};
const serializeAws_json1_1EventBatchingCondition = (input, context) => {
    return {
        ...(input.BatchSize != null && { BatchSize: input.BatchSize }),
        ...(input.BatchWindow != null && { BatchWindow: input.BatchWindow }),
    };
};
const serializeAws_json1_1ExecutionProperty = (input, context) => {
    return {
        ...(input.MaxConcurrentRuns != null && { MaxConcurrentRuns: input.MaxConcurrentRuns }),
    };
};
const serializeAws_json1_1FillMissingValues = (input, context) => {
    return {
        ...(input.FilledPath != null && { FilledPath: input.FilledPath }),
        ...(input.ImputedPath != null && { ImputedPath: input.ImputedPath }),
        ...(input.Inputs != null && { Inputs: serializeAws_json1_1OneInput(input.Inputs, context) }),
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1Filter = (input, context) => {
    return {
        ...(input.Filters != null && { Filters: serializeAws_json1_1FilterExpressions(input.Filters, context) }),
        ...(input.Inputs != null && { Inputs: serializeAws_json1_1OneInput(input.Inputs, context) }),
        ...(input.LogicalOperator != null && { LogicalOperator: input.LogicalOperator }),
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1FilterExpression = (input, context) => {
    return {
        ...(input.Negated != null && { Negated: input.Negated }),
        ...(input.Operation != null && { Operation: input.Operation }),
        ...(input.Values != null && { Values: serializeAws_json1_1FilterValues(input.Values, context) }),
    };
};
const serializeAws_json1_1FilterExpressions = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1FilterExpression(entry, context);
    });
};
const serializeAws_json1_1FilterValue = (input, context) => {
    return {
        ...(input.Type != null && { Type: input.Type }),
        ...(input.Value != null && { Value: serializeAws_json1_1EnclosedInStringProperties(input.Value, context) }),
    };
};
const serializeAws_json1_1FilterValues = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1FilterValue(entry, context);
    });
};
const serializeAws_json1_1FindMatchesParameters = (input, context) => {
    return {
        ...(input.AccuracyCostTradeoff != null && { AccuracyCostTradeoff: __serializeFloat(input.AccuracyCostTradeoff) }),
        ...(input.EnforceProvidedLabels != null && { EnforceProvidedLabels: input.EnforceProvidedLabels }),
        ...(input.PrecisionRecallTradeoff != null && {
            PrecisionRecallTradeoff: __serializeFloat(input.PrecisionRecallTradeoff),
        }),
        ...(input.PrimaryKeyColumnName != null && { PrimaryKeyColumnName: input.PrimaryKeyColumnName }),
    };
};
const serializeAws_json1_1GenericMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
const serializeAws_json1_1GetBlueprintRequest = (input, context) => {
    return {
        ...(input.IncludeBlueprint != null && { IncludeBlueprint: input.IncludeBlueprint }),
        ...(input.IncludeParameterSpec != null && { IncludeParameterSpec: input.IncludeParameterSpec }),
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1GetBlueprintRunRequest = (input, context) => {
    return {
        ...(input.BlueprintName != null && { BlueprintName: input.BlueprintName }),
        ...(input.RunId != null && { RunId: input.RunId }),
    };
};
const serializeAws_json1_1GetBlueprintRunsRequest = (input, context) => {
    return {
        ...(input.BlueprintName != null && { BlueprintName: input.BlueprintName }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const serializeAws_json1_1GetCatalogImportStatusRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    };
};
const serializeAws_json1_1GetClassifierRequest = (input, context) => {
    return {
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1GetClassifiersRequest = (input, context) => {
    return {
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const serializeAws_json1_1GetColumnNamesList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1GetColumnStatisticsForPartitionRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.ColumnNames != null && {
            ColumnNames: serializeAws_json1_1GetColumnNamesList(input.ColumnNames, context),
        }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.PartitionValues != null && {
            PartitionValues: serializeAws_json1_1ValueStringList(input.PartitionValues, context),
        }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const serializeAws_json1_1GetColumnStatisticsForTableRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.ColumnNames != null && {
            ColumnNames: serializeAws_json1_1GetColumnNamesList(input.ColumnNames, context),
        }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const serializeAws_json1_1GetConnectionRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.HidePassword != null && { HidePassword: input.HidePassword }),
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1GetConnectionsFilter = (input, context) => {
    return {
        ...(input.ConnectionType != null && { ConnectionType: input.ConnectionType }),
        ...(input.MatchCriteria != null && {
            MatchCriteria: serializeAws_json1_1MatchCriteria(input.MatchCriteria, context),
        }),
    };
};
const serializeAws_json1_1GetConnectionsRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.Filter != null && { Filter: serializeAws_json1_1GetConnectionsFilter(input.Filter, context) }),
        ...(input.HidePassword != null && { HidePassword: input.HidePassword }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const serializeAws_json1_1GetCrawlerMetricsRequest = (input, context) => {
    return {
        ...(input.CrawlerNameList != null && {
            CrawlerNameList: serializeAws_json1_1CrawlerNameList(input.CrawlerNameList, context),
        }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const serializeAws_json1_1GetCrawlerRequest = (input, context) => {
    return {
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1GetCrawlersRequest = (input, context) => {
    return {
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const serializeAws_json1_1GetCustomEntityTypeRequest = (input, context) => {
    return {
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1GetDatabaseRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1GetDatabasesRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.ResourceShareType != null && { ResourceShareType: input.ResourceShareType }),
    };
};
const serializeAws_json1_1GetDataCatalogEncryptionSettingsRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    };
};
const serializeAws_json1_1GetDataflowGraphRequest = (input, context) => {
    return {
        ...(input.PythonScript != null && { PythonScript: input.PythonScript }),
    };
};
const serializeAws_json1_1GetDataQualityResultRequest = (input, context) => {
    return {
        ...(input.ResultId != null && { ResultId: input.ResultId }),
    };
};
const serializeAws_json1_1GetDataQualityRuleRecommendationRunRequest = (input, context) => {
    return {
        ...(input.RunId != null && { RunId: input.RunId }),
    };
};
const serializeAws_json1_1GetDataQualityRulesetEvaluationRunRequest = (input, context) => {
    return {
        ...(input.RunId != null && { RunId: input.RunId }),
    };
};
const serializeAws_json1_1GetDataQualityRulesetRequest = (input, context) => {
    return {
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1GetDevEndpointRequest = (input, context) => {
    return {
        ...(input.EndpointName != null && { EndpointName: input.EndpointName }),
    };
};
const serializeAws_json1_1GetDevEndpointsRequest = (input, context) => {
    return {
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const serializeAws_json1_1GetJobBookmarkRequest = (input, context) => {
    return {
        ...(input.JobName != null && { JobName: input.JobName }),
        ...(input.RunId != null && { RunId: input.RunId }),
    };
};
const serializeAws_json1_1GetJobRequest = (input, context) => {
    return {
        ...(input.JobName != null && { JobName: input.JobName }),
    };
};
const serializeAws_json1_1GetJobRunRequest = (input, context) => {
    return {
        ...(input.JobName != null && { JobName: input.JobName }),
        ...(input.PredecessorsIncluded != null && { PredecessorsIncluded: input.PredecessorsIncluded }),
        ...(input.RunId != null && { RunId: input.RunId }),
    };
};
const serializeAws_json1_1GetJobRunsRequest = (input, context) => {
    return {
        ...(input.JobName != null && { JobName: input.JobName }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const serializeAws_json1_1GetJobsRequest = (input, context) => {
    return {
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const serializeAws_json1_1GetMappingRequest = (input, context) => {
    return {
        ...(input.Location != null && { Location: serializeAws_json1_1Location(input.Location, context) }),
        ...(input.Sinks != null && { Sinks: serializeAws_json1_1CatalogEntries(input.Sinks, context) }),
        ...(input.Source != null && { Source: serializeAws_json1_1CatalogEntry(input.Source, context) }),
    };
};
const serializeAws_json1_1GetMLTaskRunRequest = (input, context) => {
    return {
        ...(input.TaskRunId != null && { TaskRunId: input.TaskRunId }),
        ...(input.TransformId != null && { TransformId: input.TransformId }),
    };
};
const serializeAws_json1_1GetMLTaskRunsRequest = (input, context) => {
    return {
        ...(input.Filter != null && { Filter: serializeAws_json1_1TaskRunFilterCriteria(input.Filter, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.Sort != null && { Sort: serializeAws_json1_1TaskRunSortCriteria(input.Sort, context) }),
        ...(input.TransformId != null && { TransformId: input.TransformId }),
    };
};
const serializeAws_json1_1GetMLTransformRequest = (input, context) => {
    return {
        ...(input.TransformId != null && { TransformId: input.TransformId }),
    };
};
const serializeAws_json1_1GetMLTransformsRequest = (input, context) => {
    return {
        ...(input.Filter != null && { Filter: serializeAws_json1_1TransformFilterCriteria(input.Filter, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.Sort != null && { Sort: serializeAws_json1_1TransformSortCriteria(input.Sort, context) }),
    };
};
const serializeAws_json1_1GetPartitionIndexesRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const serializeAws_json1_1GetPartitionRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.PartitionValues != null && {
            PartitionValues: serializeAws_json1_1ValueStringList(input.PartitionValues, context),
        }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const serializeAws_json1_1GetPartitionsRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.ExcludeColumnSchema != null && { ExcludeColumnSchema: input.ExcludeColumnSchema }),
        ...(input.Expression != null && { Expression: input.Expression }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.QueryAsOfTime != null && { QueryAsOfTime: Math.round(input.QueryAsOfTime.getTime() / 1000) }),
        ...(input.Segment != null && { Segment: serializeAws_json1_1Segment(input.Segment, context) }),
        ...(input.TableName != null && { TableName: input.TableName }),
        ...(input.TransactionId != null && { TransactionId: input.TransactionId }),
    };
};
const serializeAws_json1_1GetPlanRequest = (input, context) => {
    return {
        ...(input.AdditionalPlanOptionsMap != null && {
            AdditionalPlanOptionsMap: serializeAws_json1_1AdditionalPlanOptionsMap(input.AdditionalPlanOptionsMap, context),
        }),
        ...(input.Language != null && { Language: input.Language }),
        ...(input.Location != null && { Location: serializeAws_json1_1Location(input.Location, context) }),
        ...(input.Mapping != null && { Mapping: serializeAws_json1_1MappingList(input.Mapping, context) }),
        ...(input.Sinks != null && { Sinks: serializeAws_json1_1CatalogEntries(input.Sinks, context) }),
        ...(input.Source != null && { Source: serializeAws_json1_1CatalogEntry(input.Source, context) }),
    };
};
const serializeAws_json1_1GetRegistryInput = (input, context) => {
    return {
        ...(input.RegistryId != null && { RegistryId: serializeAws_json1_1RegistryId(input.RegistryId, context) }),
    };
};
const serializeAws_json1_1GetResourcePoliciesRequest = (input, context) => {
    return {
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const serializeAws_json1_1GetResourcePolicyRequest = (input, context) => {
    return {
        ...(input.ResourceArn != null && { ResourceArn: input.ResourceArn }),
    };
};
const serializeAws_json1_1GetSchemaByDefinitionInput = (input, context) => {
    return {
        ...(input.SchemaDefinition != null && { SchemaDefinition: input.SchemaDefinition }),
        ...(input.SchemaId != null && { SchemaId: serializeAws_json1_1SchemaId(input.SchemaId, context) }),
    };
};
const serializeAws_json1_1GetSchemaInput = (input, context) => {
    return {
        ...(input.SchemaId != null && { SchemaId: serializeAws_json1_1SchemaId(input.SchemaId, context) }),
    };
};
const serializeAws_json1_1GetSchemaVersionInput = (input, context) => {
    return {
        ...(input.SchemaId != null && { SchemaId: serializeAws_json1_1SchemaId(input.SchemaId, context) }),
        ...(input.SchemaVersionId != null && { SchemaVersionId: input.SchemaVersionId }),
        ...(input.SchemaVersionNumber != null && {
            SchemaVersionNumber: serializeAws_json1_1SchemaVersionNumber(input.SchemaVersionNumber, context),
        }),
    };
};
const serializeAws_json1_1GetSchemaVersionsDiffInput = (input, context) => {
    return {
        ...(input.FirstSchemaVersionNumber != null && {
            FirstSchemaVersionNumber: serializeAws_json1_1SchemaVersionNumber(input.FirstSchemaVersionNumber, context),
        }),
        ...(input.SchemaDiffType != null && { SchemaDiffType: input.SchemaDiffType }),
        ...(input.SchemaId != null && { SchemaId: serializeAws_json1_1SchemaId(input.SchemaId, context) }),
        ...(input.SecondSchemaVersionNumber != null && {
            SecondSchemaVersionNumber: serializeAws_json1_1SchemaVersionNumber(input.SecondSchemaVersionNumber, context),
        }),
    };
};
const serializeAws_json1_1GetSecurityConfigurationRequest = (input, context) => {
    return {
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1GetSecurityConfigurationsRequest = (input, context) => {
    return {
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const serializeAws_json1_1GetSessionRequest = (input, context) => {
    return {
        ...(input.Id != null && { Id: input.Id }),
        ...(input.RequestOrigin != null && { RequestOrigin: input.RequestOrigin }),
    };
};
const serializeAws_json1_1GetStatementRequest = (input, context) => {
    return {
        ...(input.Id != null && { Id: input.Id }),
        ...(input.RequestOrigin != null && { RequestOrigin: input.RequestOrigin }),
        ...(input.SessionId != null && { SessionId: input.SessionId }),
    };
};
const serializeAws_json1_1GetTableRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.QueryAsOfTime != null && { QueryAsOfTime: Math.round(input.QueryAsOfTime.getTime() / 1000) }),
        ...(input.TransactionId != null && { TransactionId: input.TransactionId }),
    };
};
const serializeAws_json1_1GetTablesRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.Expression != null && { Expression: input.Expression }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.QueryAsOfTime != null && { QueryAsOfTime: Math.round(input.QueryAsOfTime.getTime() / 1000) }),
        ...(input.TransactionId != null && { TransactionId: input.TransactionId }),
    };
};
const serializeAws_json1_1GetTableVersionRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.TableName != null && { TableName: input.TableName }),
        ...(input.VersionId != null && { VersionId: input.VersionId }),
    };
};
const serializeAws_json1_1GetTableVersionsRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const serializeAws_json1_1GetTagsRequest = (input, context) => {
    return {
        ...(input.ResourceArn != null && { ResourceArn: input.ResourceArn }),
    };
};
const serializeAws_json1_1GetTriggerRequest = (input, context) => {
    return {
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1GetTriggersRequest = (input, context) => {
    return {
        ...(input.DependentJobName != null && { DependentJobName: input.DependentJobName }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const serializeAws_json1_1GetUnfilteredPartitionMetadataRequest = (input, context) => {
    return {
        ...(input.AuditContext != null && { AuditContext: serializeAws_json1_1AuditContext(input.AuditContext, context) }),
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.PartitionValues != null && {
            PartitionValues: serializeAws_json1_1ValueStringList(input.PartitionValues, context),
        }),
        ...(input.SupportedPermissionTypes != null && {
            SupportedPermissionTypes: serializeAws_json1_1PermissionTypeList(input.SupportedPermissionTypes, context),
        }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const serializeAws_json1_1GetUnfilteredPartitionsMetadataRequest = (input, context) => {
    return {
        ...(input.AuditContext != null && { AuditContext: serializeAws_json1_1AuditContext(input.AuditContext, context) }),
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.Expression != null && { Expression: input.Expression }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.Segment != null && { Segment: serializeAws_json1_1Segment(input.Segment, context) }),
        ...(input.SupportedPermissionTypes != null && {
            SupportedPermissionTypes: serializeAws_json1_1PermissionTypeList(input.SupportedPermissionTypes, context),
        }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const serializeAws_json1_1GetUnfilteredTableMetadataRequest = (input, context) => {
    return {
        ...(input.AuditContext != null && { AuditContext: serializeAws_json1_1AuditContext(input.AuditContext, context) }),
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.SupportedPermissionTypes != null && {
            SupportedPermissionTypes: serializeAws_json1_1PermissionTypeList(input.SupportedPermissionTypes, context),
        }),
    };
};
const serializeAws_json1_1GetUserDefinedFunctionRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.FunctionName != null && { FunctionName: input.FunctionName }),
    };
};
const serializeAws_json1_1GetUserDefinedFunctionsRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.Pattern != null && { Pattern: input.Pattern }),
    };
};
const serializeAws_json1_1GetWorkflowRequest = (input, context) => {
    return {
        ...(input.IncludeGraph != null && { IncludeGraph: input.IncludeGraph }),
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1GetWorkflowRunPropertiesRequest = (input, context) => {
    return {
        ...(input.Name != null && { Name: input.Name }),
        ...(input.RunId != null && { RunId: input.RunId }),
    };
};
const serializeAws_json1_1GetWorkflowRunRequest = (input, context) => {
    return {
        ...(input.IncludeGraph != null && { IncludeGraph: input.IncludeGraph }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.RunId != null && { RunId: input.RunId }),
    };
};
const serializeAws_json1_1GetWorkflowRunsRequest = (input, context) => {
    return {
        ...(input.IncludeGraph != null && { IncludeGraph: input.IncludeGraph }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const serializeAws_json1_1GlueSchema = (input, context) => {
    return {
        ...(input.Columns != null && { Columns: serializeAws_json1_1GlueStudioSchemaColumnList(input.Columns, context) }),
    };
};
const serializeAws_json1_1GlueSchemas = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1GlueSchema(entry, context);
    });
};
const serializeAws_json1_1GlueStudioPathList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1EnclosedInStringProperties(entry, context);
    });
};
const serializeAws_json1_1GlueStudioSchemaColumn = (input, context) => {
    return {
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Type != null && { Type: input.Type }),
    };
};
const serializeAws_json1_1GlueStudioSchemaColumnList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1GlueStudioSchemaColumn(entry, context);
    });
};
const serializeAws_json1_1GlueTable = (input, context) => {
    return {
        ...(input.AdditionalOptions != null && {
            AdditionalOptions: serializeAws_json1_1GlueTableAdditionalOptions(input.AdditionalOptions, context),
        }),
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.ConnectionName != null && { ConnectionName: input.ConnectionName }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const serializeAws_json1_1GlueTableAdditionalOptions = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
const serializeAws_json1_1GlueTables = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1GlueTable(entry, context);
    });
};
const serializeAws_json1_1GovernedCatalogSource = (input, context) => {
    return {
        ...(input.AdditionalOptions != null && {
            AdditionalOptions: serializeAws_json1_1S3SourceAdditionalOptions(input.AdditionalOptions, context),
        }),
        ...(input.Database != null && { Database: input.Database }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.PartitionPredicate != null && { PartitionPredicate: input.PartitionPredicate }),
        ...(input.Table != null && { Table: input.Table }),
    };
};
const serializeAws_json1_1GovernedCatalogTarget = (input, context) => {
    return {
        ...(input.Database != null && { Database: input.Database }),
        ...(input.Inputs != null && { Inputs: serializeAws_json1_1OneInput(input.Inputs, context) }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.PartitionKeys != null && {
            PartitionKeys: serializeAws_json1_1GlueStudioPathList(input.PartitionKeys, context),
        }),
        ...(input.SchemaChangePolicy != null && {
            SchemaChangePolicy: serializeAws_json1_1CatalogSchemaChangePolicy(input.SchemaChangePolicy, context),
        }),
        ...(input.Table != null && { Table: input.Table }),
    };
};
const serializeAws_json1_1ImportCatalogToGlueRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
    };
};
const serializeAws_json1_1JDBCConnectorOptions = (input, context) => {
    return {
        ...(input.DataTypeMapping != null && {
            DataTypeMapping: serializeAws_json1_1JDBCDataTypeMapping(input.DataTypeMapping, context),
        }),
        ...(input.FilterPredicate != null && { FilterPredicate: input.FilterPredicate }),
        ...(input.JobBookmarkKeys != null && {
            JobBookmarkKeys: serializeAws_json1_1EnclosedInStringProperties(input.JobBookmarkKeys, context),
        }),
        ...(input.JobBookmarkKeysSortOrder != null && { JobBookmarkKeysSortOrder: input.JobBookmarkKeysSortOrder }),
        ...(input.LowerBound != null && { LowerBound: input.LowerBound }),
        ...(input.NumPartitions != null && { NumPartitions: input.NumPartitions }),
        ...(input.PartitionColumn != null && { PartitionColumn: input.PartitionColumn }),
        ...(input.UpperBound != null && { UpperBound: input.UpperBound }),
    };
};
const serializeAws_json1_1JDBCConnectorSource = (input, context) => {
    return {
        ...(input.AdditionalOptions != null && {
            AdditionalOptions: serializeAws_json1_1JDBCConnectorOptions(input.AdditionalOptions, context),
        }),
        ...(input.ConnectionName != null && { ConnectionName: input.ConnectionName }),
        ...(input.ConnectionTable != null && { ConnectionTable: input.ConnectionTable }),
        ...(input.ConnectionType != null && { ConnectionType: input.ConnectionType }),
        ...(input.ConnectorName != null && { ConnectorName: input.ConnectorName }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.OutputSchemas != null && {
            OutputSchemas: serializeAws_json1_1GlueSchemas(input.OutputSchemas, context),
        }),
        ...(input.Query != null && { Query: input.Query }),
    };
};
const serializeAws_json1_1JDBCConnectorTarget = (input, context) => {
    return {
        ...(input.AdditionalOptions != null && {
            AdditionalOptions: serializeAws_json1_1AdditionalOptions(input.AdditionalOptions, context),
        }),
        ...(input.ConnectionName != null && { ConnectionName: input.ConnectionName }),
        ...(input.ConnectionTable != null && { ConnectionTable: input.ConnectionTable }),
        ...(input.ConnectionType != null && { ConnectionType: input.ConnectionType }),
        ...(input.ConnectorName != null && { ConnectorName: input.ConnectorName }),
        ...(input.Inputs != null && { Inputs: serializeAws_json1_1OneInput(input.Inputs, context) }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.OutputSchemas != null && {
            OutputSchemas: serializeAws_json1_1GlueSchemas(input.OutputSchemas, context),
        }),
    };
};
const serializeAws_json1_1JDBCDataTypeMapping = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
const serializeAws_json1_1JdbcTarget = (input, context) => {
    return {
        ...(input.ConnectionName != null && { ConnectionName: input.ConnectionName }),
        ...(input.EnableAdditionalMetadata != null && {
            EnableAdditionalMetadata: serializeAws_json1_1EnableAdditionalMetadata(input.EnableAdditionalMetadata, context),
        }),
        ...(input.Exclusions != null && { Exclusions: serializeAws_json1_1PathList(input.Exclusions, context) }),
        ...(input.Path != null && { Path: input.Path }),
    };
};
const serializeAws_json1_1JdbcTargetList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1JdbcTarget(entry, context);
    });
};
const serializeAws_json1_1JobBookmarksEncryption = (input, context) => {
    return {
        ...(input.JobBookmarksEncryptionMode != null && { JobBookmarksEncryptionMode: input.JobBookmarksEncryptionMode }),
        ...(input.KmsKeyArn != null && { KmsKeyArn: input.KmsKeyArn }),
    };
};
const serializeAws_json1_1JobCommand = (input, context) => {
    return {
        ...(input.Name != null && { Name: input.Name }),
        ...(input.PythonVersion != null && { PythonVersion: input.PythonVersion }),
        ...(input.ScriptLocation != null && { ScriptLocation: input.ScriptLocation }),
    };
};
const serializeAws_json1_1JobNameList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1JobUpdate = (input, context) => {
    return {
        ...(input.AllocatedCapacity != null && { AllocatedCapacity: input.AllocatedCapacity }),
        ...(input.CodeGenConfigurationNodes != null && {
            CodeGenConfigurationNodes: serializeAws_json1_1CodeGenConfigurationNodes(input.CodeGenConfigurationNodes, context),
        }),
        ...(input.Command != null && { Command: serializeAws_json1_1JobCommand(input.Command, context) }),
        ...(input.Connections != null && { Connections: serializeAws_json1_1ConnectionsList(input.Connections, context) }),
        ...(input.DefaultArguments != null && {
            DefaultArguments: serializeAws_json1_1GenericMap(input.DefaultArguments, context),
        }),
        ...(input.Description != null && { Description: input.Description }),
        ...(input.ExecutionClass != null && { ExecutionClass: input.ExecutionClass }),
        ...(input.ExecutionProperty != null && {
            ExecutionProperty: serializeAws_json1_1ExecutionProperty(input.ExecutionProperty, context),
        }),
        ...(input.GlueVersion != null && { GlueVersion: input.GlueVersion }),
        ...(input.LogUri != null && { LogUri: input.LogUri }),
        ...(input.MaxCapacity != null && { MaxCapacity: __serializeFloat(input.MaxCapacity) }),
        ...(input.MaxRetries != null && { MaxRetries: input.MaxRetries }),
        ...(input.NonOverridableArguments != null && {
            NonOverridableArguments: serializeAws_json1_1GenericMap(input.NonOverridableArguments, context),
        }),
        ...(input.NotificationProperty != null && {
            NotificationProperty: serializeAws_json1_1NotificationProperty(input.NotificationProperty, context),
        }),
        ...(input.NumberOfWorkers != null && { NumberOfWorkers: input.NumberOfWorkers }),
        ...(input.Role != null && { Role: input.Role }),
        ...(input.SecurityConfiguration != null && { SecurityConfiguration: input.SecurityConfiguration }),
        ...(input.SourceControlDetails != null && {
            SourceControlDetails: serializeAws_json1_1SourceControlDetails(input.SourceControlDetails, context),
        }),
        ...(input.Timeout != null && { Timeout: input.Timeout }),
        ...(input.WorkerType != null && { WorkerType: input.WorkerType }),
    };
};
const serializeAws_json1_1Join = (input, context) => {
    return {
        ...(input.Columns != null && { Columns: serializeAws_json1_1JoinColumns(input.Columns, context) }),
        ...(input.Inputs != null && { Inputs: serializeAws_json1_1TwoInputs(input.Inputs, context) }),
        ...(input.JoinType != null && { JoinType: input.JoinType }),
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1JoinColumn = (input, context) => {
    return {
        ...(input.From != null && { From: input.From }),
        ...(input.Keys != null && { Keys: serializeAws_json1_1GlueStudioPathList(input.Keys, context) }),
    };
};
const serializeAws_json1_1JoinColumns = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1JoinColumn(entry, context);
    });
};
const serializeAws_json1_1KafkaStreamingSourceOptions = (input, context) => {
    return {
        ...(input.AddRecordTimestamp != null && { AddRecordTimestamp: input.AddRecordTimestamp }),
        ...(input.Assign != null && { Assign: input.Assign }),
        ...(input.BootstrapServers != null && { BootstrapServers: input.BootstrapServers }),
        ...(input.Classification != null && { Classification: input.Classification }),
        ...(input.ConnectionName != null && { ConnectionName: input.ConnectionName }),
        ...(input.Delimiter != null && { Delimiter: input.Delimiter }),
        ...(input.EmitConsumerLagMetrics != null && { EmitConsumerLagMetrics: input.EmitConsumerLagMetrics }),
        ...(input.EndingOffsets != null && { EndingOffsets: input.EndingOffsets }),
        ...(input.IncludeHeaders != null && { IncludeHeaders: input.IncludeHeaders }),
        ...(input.MaxOffsetsPerTrigger != null && { MaxOffsetsPerTrigger: input.MaxOffsetsPerTrigger }),
        ...(input.MinPartitions != null && { MinPartitions: input.MinPartitions }),
        ...(input.NumRetries != null && { NumRetries: input.NumRetries }),
        ...(input.PollTimeoutMs != null && { PollTimeoutMs: input.PollTimeoutMs }),
        ...(input.RetryIntervalMs != null && { RetryIntervalMs: input.RetryIntervalMs }),
        ...(input.SecurityProtocol != null && { SecurityProtocol: input.SecurityProtocol }),
        ...(input.StartingOffsets != null && { StartingOffsets: input.StartingOffsets }),
        ...(input.SubscribePattern != null && { SubscribePattern: input.SubscribePattern }),
        ...(input.TopicName != null && { TopicName: input.TopicName }),
    };
};
const serializeAws_json1_1KeyList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1KinesisStreamingSourceOptions = (input, context) => {
    return {
        ...(input.AddIdleTimeBetweenReads != null && { AddIdleTimeBetweenReads: input.AddIdleTimeBetweenReads }),
        ...(input.AddRecordTimestamp != null && { AddRecordTimestamp: input.AddRecordTimestamp }),
        ...(input.AvoidEmptyBatches != null && { AvoidEmptyBatches: input.AvoidEmptyBatches }),
        ...(input.Classification != null && { Classification: input.Classification }),
        ...(input.Delimiter != null && { Delimiter: input.Delimiter }),
        ...(input.DescribeShardInterval != null && { DescribeShardInterval: input.DescribeShardInterval }),
        ...(input.EmitConsumerLagMetrics != null && { EmitConsumerLagMetrics: input.EmitConsumerLagMetrics }),
        ...(input.EndpointUrl != null && { EndpointUrl: input.EndpointUrl }),
        ...(input.IdleTimeBetweenReadsInMs != null && { IdleTimeBetweenReadsInMs: input.IdleTimeBetweenReadsInMs }),
        ...(input.MaxFetchRecordsPerShard != null && { MaxFetchRecordsPerShard: input.MaxFetchRecordsPerShard }),
        ...(input.MaxFetchTimeInMs != null && { MaxFetchTimeInMs: input.MaxFetchTimeInMs }),
        ...(input.MaxRecordPerRead != null && { MaxRecordPerRead: input.MaxRecordPerRead }),
        ...(input.MaxRetryIntervalMs != null && { MaxRetryIntervalMs: input.MaxRetryIntervalMs }),
        ...(input.NumRetries != null && { NumRetries: input.NumRetries }),
        ...(input.RetryIntervalMs != null && { RetryIntervalMs: input.RetryIntervalMs }),
        ...(input.RoleArn != null && { RoleArn: input.RoleArn }),
        ...(input.RoleSessionName != null && { RoleSessionName: input.RoleSessionName }),
        ...(input.StartingPosition != null && { StartingPosition: input.StartingPosition }),
        ...(input.StreamArn != null && { StreamArn: input.StreamArn }),
        ...(input.StreamName != null && { StreamName: input.StreamName }),
    };
};
const serializeAws_json1_1LakeFormationConfiguration = (input, context) => {
    return {
        ...(input.AccountId != null && { AccountId: input.AccountId }),
        ...(input.UseLakeFormationCredentials != null && {
            UseLakeFormationCredentials: input.UseLakeFormationCredentials,
        }),
    };
};
const serializeAws_json1_1LimitedPathList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1LimitedStringList(entry, context);
    });
};
const serializeAws_json1_1LimitedStringList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1LineageConfiguration = (input, context) => {
    return {
        ...(input.CrawlerLineageSettings != null && { CrawlerLineageSettings: input.CrawlerLineageSettings }),
    };
};
const serializeAws_json1_1ListBlueprintsRequest = (input, context) => {
    return {
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.Tags != null && { Tags: serializeAws_json1_1TagsMap(input.Tags, context) }),
    };
};
const serializeAws_json1_1ListCrawlersRequest = (input, context) => {
    return {
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.Tags != null && { Tags: serializeAws_json1_1TagsMap(input.Tags, context) }),
    };
};
const serializeAws_json1_1ListCrawlsRequest = (input, context) => {
    return {
        ...(input.CrawlerName != null && { CrawlerName: input.CrawlerName }),
        ...(input.Filters != null && { Filters: serializeAws_json1_1CrawlsFilterList(input.Filters, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const serializeAws_json1_1ListCustomEntityTypesRequest = (input, context) => {
    return {
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const serializeAws_json1_1ListDataQualityResultsRequest = (input, context) => {
    return {
        ...(input.Filter != null && { Filter: serializeAws_json1_1DataQualityResultFilterCriteria(input.Filter, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const serializeAws_json1_1ListDataQualityRuleRecommendationRunsRequest = (input, context) => {
    return {
        ...(input.Filter != null && {
            Filter: serializeAws_json1_1DataQualityRuleRecommendationRunFilter(input.Filter, context),
        }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const serializeAws_json1_1ListDataQualityRulesetEvaluationRunsRequest = (input, context) => {
    return {
        ...(input.Filter != null && {
            Filter: serializeAws_json1_1DataQualityRulesetEvaluationRunFilter(input.Filter, context),
        }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const serializeAws_json1_1ListDataQualityRulesetsRequest = (input, context) => {
    return {
        ...(input.Filter != null && {
            Filter: serializeAws_json1_1DataQualityRulesetFilterCriteria(input.Filter, context),
        }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.Tags != null && { Tags: serializeAws_json1_1TagsMap(input.Tags, context) }),
    };
};
const serializeAws_json1_1ListDevEndpointsRequest = (input, context) => {
    return {
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.Tags != null && { Tags: serializeAws_json1_1TagsMap(input.Tags, context) }),
    };
};
const serializeAws_json1_1ListJobsRequest = (input, context) => {
    return {
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.Tags != null && { Tags: serializeAws_json1_1TagsMap(input.Tags, context) }),
    };
};
const serializeAws_json1_1ListMLTransformsRequest = (input, context) => {
    return {
        ...(input.Filter != null && { Filter: serializeAws_json1_1TransformFilterCriteria(input.Filter, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.Sort != null && { Sort: serializeAws_json1_1TransformSortCriteria(input.Sort, context) }),
        ...(input.Tags != null && { Tags: serializeAws_json1_1TagsMap(input.Tags, context) }),
    };
};
const serializeAws_json1_1ListRegistriesInput = (input, context) => {
    return {
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const serializeAws_json1_1ListSchemasInput = (input, context) => {
    return {
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.RegistryId != null && { RegistryId: serializeAws_json1_1RegistryId(input.RegistryId, context) }),
    };
};
const serializeAws_json1_1ListSchemaVersionsInput = (input, context) => {
    return {
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.SchemaId != null && { SchemaId: serializeAws_json1_1SchemaId(input.SchemaId, context) }),
    };
};
const serializeAws_json1_1ListSessionsRequest = (input, context) => {
    return {
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.RequestOrigin != null && { RequestOrigin: input.RequestOrigin }),
        ...(input.Tags != null && { Tags: serializeAws_json1_1TagsMap(input.Tags, context) }),
    };
};
const serializeAws_json1_1ListStatementsRequest = (input, context) => {
    return {
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.RequestOrigin != null && { RequestOrigin: input.RequestOrigin }),
        ...(input.SessionId != null && { SessionId: input.SessionId }),
    };
};
const serializeAws_json1_1ListTriggersRequest = (input, context) => {
    return {
        ...(input.DependentJobName != null && { DependentJobName: input.DependentJobName }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.Tags != null && { Tags: serializeAws_json1_1TagsMap(input.Tags, context) }),
    };
};
const serializeAws_json1_1ListWorkflowsRequest = (input, context) => {
    return {
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
    };
};
const serializeAws_json1_1Location = (input, context) => {
    return {
        ...(input.DynamoDB != null && { DynamoDB: serializeAws_json1_1CodeGenNodeArgs(input.DynamoDB, context) }),
        ...(input.Jdbc != null && { Jdbc: serializeAws_json1_1CodeGenNodeArgs(input.Jdbc, context) }),
        ...(input.S3 != null && { S3: serializeAws_json1_1CodeGenNodeArgs(input.S3, context) }),
    };
};
const serializeAws_json1_1LocationMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
const serializeAws_json1_1LocationStringList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1LongColumnStatisticsData = (input, context) => {
    return {
        ...(input.MaximumValue != null && { MaximumValue: input.MaximumValue }),
        ...(input.MinimumValue != null && { MinimumValue: input.MinimumValue }),
        ...(input.NumberOfDistinctValues != null && { NumberOfDistinctValues: input.NumberOfDistinctValues }),
        ...(input.NumberOfNulls != null && { NumberOfNulls: input.NumberOfNulls }),
    };
};
const serializeAws_json1_1ManyInputs = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1Mapping = (input, context) => {
    return {
        ...(input.Children != null && { Children: serializeAws_json1_1Mappings(input.Children, context) }),
        ...(input.Dropped != null && { Dropped: input.Dropped }),
        ...(input.FromPath != null && {
            FromPath: serializeAws_json1_1EnclosedInStringProperties(input.FromPath, context),
        }),
        ...(input.FromType != null && { FromType: input.FromType }),
        ...(input.ToKey != null && { ToKey: input.ToKey }),
        ...(input.ToType != null && { ToType: input.ToType }),
    };
};
const serializeAws_json1_1MappingEntry = (input, context) => {
    return {
        ...(input.SourcePath != null && { SourcePath: input.SourcePath }),
        ...(input.SourceTable != null && { SourceTable: input.SourceTable }),
        ...(input.SourceType != null && { SourceType: input.SourceType }),
        ...(input.TargetPath != null && { TargetPath: input.TargetPath }),
        ...(input.TargetTable != null && { TargetTable: input.TargetTable }),
        ...(input.TargetType != null && { TargetType: input.TargetType }),
    };
};
const serializeAws_json1_1MappingList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1MappingEntry(entry, context);
    });
};
const serializeAws_json1_1Mappings = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1Mapping(entry, context);
    });
};
const serializeAws_json1_1MapValue = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
const serializeAws_json1_1MatchCriteria = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1Merge = (input, context) => {
    return {
        ...(input.Inputs != null && { Inputs: serializeAws_json1_1TwoInputs(input.Inputs, context) }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.PrimaryKeys != null && {
            PrimaryKeys: serializeAws_json1_1GlueStudioPathList(input.PrimaryKeys, context),
        }),
        ...(input.Source != null && { Source: input.Source }),
    };
};
const serializeAws_json1_1MetadataKeyValuePair = (input, context) => {
    return {
        ...(input.MetadataKey != null && { MetadataKey: input.MetadataKey }),
        ...(input.MetadataValue != null && { MetadataValue: input.MetadataValue }),
    };
};
const serializeAws_json1_1MetadataList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1MetadataKeyValuePair(entry, context);
    });
};
const serializeAws_json1_1MicrosoftSQLServerCatalogSource = (input, context) => {
    return {
        ...(input.Database != null && { Database: input.Database }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Table != null && { Table: input.Table }),
    };
};
const serializeAws_json1_1MicrosoftSQLServerCatalogTarget = (input, context) => {
    return {
        ...(input.Database != null && { Database: input.Database }),
        ...(input.Inputs != null && { Inputs: serializeAws_json1_1OneInput(input.Inputs, context) }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Table != null && { Table: input.Table }),
    };
};
const serializeAws_json1_1MLUserDataEncryption = (input, context) => {
    return {
        ...(input.KmsKeyId != null && { KmsKeyId: input.KmsKeyId }),
        ...(input.MlUserDataEncryptionMode != null && { MlUserDataEncryptionMode: input.MlUserDataEncryptionMode }),
    };
};
const serializeAws_json1_1MongoDBTarget = (input, context) => {
    return {
        ...(input.ConnectionName != null && { ConnectionName: input.ConnectionName }),
        ...(input.Path != null && { Path: input.Path }),
        ...(input.ScanAll != null && { ScanAll: input.ScanAll }),
    };
};
const serializeAws_json1_1MongoDBTargetList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1MongoDBTarget(entry, context);
    });
};
const serializeAws_json1_1MySQLCatalogSource = (input, context) => {
    return {
        ...(input.Database != null && { Database: input.Database }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Table != null && { Table: input.Table }),
    };
};
const serializeAws_json1_1MySQLCatalogTarget = (input, context) => {
    return {
        ...(input.Database != null && { Database: input.Database }),
        ...(input.Inputs != null && { Inputs: serializeAws_json1_1OneInput(input.Inputs, context) }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Table != null && { Table: input.Table }),
    };
};
const serializeAws_json1_1NameStringList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1NodeIdList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1NotificationProperty = (input, context) => {
    return {
        ...(input.NotifyDelayAfter != null && { NotifyDelayAfter: input.NotifyDelayAfter }),
    };
};
const serializeAws_json1_1NullCheckBoxList = (input, context) => {
    return {
        ...(input.IsEmpty != null && { IsEmpty: input.IsEmpty }),
        ...(input.IsNegOne != null && { IsNegOne: input.IsNegOne }),
        ...(input.IsNullString != null && { IsNullString: input.IsNullString }),
    };
};
const serializeAws_json1_1NullValueField = (input, context) => {
    return {
        ...(input.Datatype != null && { Datatype: serializeAws_json1_1Datatype(input.Datatype, context) }),
        ...(input.Value != null && { Value: input.Value }),
    };
};
const serializeAws_json1_1NullValueFields = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1NullValueField(entry, context);
    });
};
const serializeAws_json1_1OneInput = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1OracleSQLCatalogSource = (input, context) => {
    return {
        ...(input.Database != null && { Database: input.Database }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Table != null && { Table: input.Table }),
    };
};
const serializeAws_json1_1OracleSQLCatalogTarget = (input, context) => {
    return {
        ...(input.Database != null && { Database: input.Database }),
        ...(input.Inputs != null && { Inputs: serializeAws_json1_1OneInput(input.Inputs, context) }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Table != null && { Table: input.Table }),
    };
};
const serializeAws_json1_1OrchestrationArgumentsMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
const serializeAws_json1_1OrchestrationStringList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1Order = (input, context) => {
    return {
        ...(input.Column != null && { Column: input.Column }),
        ...(input.SortOrder != null && { SortOrder: input.SortOrder }),
    };
};
const serializeAws_json1_1OrderList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1Order(entry, context);
    });
};
const serializeAws_json1_1ParametersMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
const serializeAws_json1_1PartitionIndex = (input, context) => {
    return {
        ...(input.IndexName != null && { IndexName: input.IndexName }),
        ...(input.Keys != null && { Keys: serializeAws_json1_1KeyList(input.Keys, context) }),
    };
};
const serializeAws_json1_1PartitionIndexList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1PartitionIndex(entry, context);
    });
};
const serializeAws_json1_1PartitionInput = (input, context) => {
    return {
        ...(input.LastAccessTime != null && { LastAccessTime: Math.round(input.LastAccessTime.getTime() / 1000) }),
        ...(input.LastAnalyzedTime != null && { LastAnalyzedTime: Math.round(input.LastAnalyzedTime.getTime() / 1000) }),
        ...(input.Parameters != null && { Parameters: serializeAws_json1_1ParametersMap(input.Parameters, context) }),
        ...(input.StorageDescriptor != null && {
            StorageDescriptor: serializeAws_json1_1StorageDescriptor(input.StorageDescriptor, context),
        }),
        ...(input.Values != null && { Values: serializeAws_json1_1ValueStringList(input.Values, context) }),
    };
};
const serializeAws_json1_1PartitionInputList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1PartitionInput(entry, context);
    });
};
const serializeAws_json1_1PartitionValueList = (input, context) => {
    return {
        ...(input.Values != null && { Values: serializeAws_json1_1ValueStringList(input.Values, context) }),
    };
};
const serializeAws_json1_1PathList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1PermissionList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1PermissionTypeList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1PhysicalConnectionRequirements = (input, context) => {
    return {
        ...(input.AvailabilityZone != null && { AvailabilityZone: input.AvailabilityZone }),
        ...(input.SecurityGroupIdList != null && {
            SecurityGroupIdList: serializeAws_json1_1SecurityGroupIdList(input.SecurityGroupIdList, context),
        }),
        ...(input.SubnetId != null && { SubnetId: input.SubnetId }),
    };
};
const serializeAws_json1_1PIIDetection = (input, context) => {
    return {
        ...(input.EntityTypesToDetect != null && {
            EntityTypesToDetect: serializeAws_json1_1EnclosedInStringProperties(input.EntityTypesToDetect, context),
        }),
        ...(input.Inputs != null && { Inputs: serializeAws_json1_1OneInput(input.Inputs, context) }),
        ...(input.MaskValue != null && { MaskValue: input.MaskValue }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.OutputColumnName != null && { OutputColumnName: input.OutputColumnName }),
        ...(input.PiiType != null && { PiiType: input.PiiType }),
        ...(input.SampleFraction != null && { SampleFraction: __serializeFloat(input.SampleFraction) }),
        ...(input.ThresholdFraction != null && { ThresholdFraction: __serializeFloat(input.ThresholdFraction) }),
    };
};
const serializeAws_json1_1PostgreSQLCatalogSource = (input, context) => {
    return {
        ...(input.Database != null && { Database: input.Database }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Table != null && { Table: input.Table }),
    };
};
const serializeAws_json1_1PostgreSQLCatalogTarget = (input, context) => {
    return {
        ...(input.Database != null && { Database: input.Database }),
        ...(input.Inputs != null && { Inputs: serializeAws_json1_1OneInput(input.Inputs, context) }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Table != null && { Table: input.Table }),
    };
};
const serializeAws_json1_1Predicate = (input, context) => {
    return {
        ...(input.Conditions != null && { Conditions: serializeAws_json1_1ConditionList(input.Conditions, context) }),
        ...(input.Logical != null && { Logical: input.Logical }),
    };
};
const serializeAws_json1_1PrincipalPermissions = (input, context) => {
    return {
        ...(input.Permissions != null && { Permissions: serializeAws_json1_1PermissionList(input.Permissions, context) }),
        ...(input.Principal != null && { Principal: serializeAws_json1_1DataLakePrincipal(input.Principal, context) }),
    };
};
const serializeAws_json1_1PrincipalPermissionsList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1PrincipalPermissions(entry, context);
    });
};
const serializeAws_json1_1PropertyPredicate = (input, context) => {
    return {
        ...(input.Comparator != null && { Comparator: input.Comparator }),
        ...(input.Key != null && { Key: input.Key }),
        ...(input.Value != null && { Value: input.Value }),
    };
};
const serializeAws_json1_1PublicKeysList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1PutDataCatalogEncryptionSettingsRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.DataCatalogEncryptionSettings != null && {
            DataCatalogEncryptionSettings: serializeAws_json1_1DataCatalogEncryptionSettings(input.DataCatalogEncryptionSettings, context),
        }),
    };
};
const serializeAws_json1_1PutResourcePolicyRequest = (input, context) => {
    return {
        ...(input.EnableHybrid != null && { EnableHybrid: input.EnableHybrid }),
        ...(input.PolicyExistsCondition != null && { PolicyExistsCondition: input.PolicyExistsCondition }),
        ...(input.PolicyHashCondition != null && { PolicyHashCondition: input.PolicyHashCondition }),
        ...(input.PolicyInJson != null && { PolicyInJson: input.PolicyInJson }),
        ...(input.ResourceArn != null && { ResourceArn: input.ResourceArn }),
    };
};
const serializeAws_json1_1PutSchemaVersionMetadataInput = (input, context) => {
    return {
        ...(input.MetadataKeyValue != null && {
            MetadataKeyValue: serializeAws_json1_1MetadataKeyValuePair(input.MetadataKeyValue, context),
        }),
        ...(input.SchemaId != null && { SchemaId: serializeAws_json1_1SchemaId(input.SchemaId, context) }),
        ...(input.SchemaVersionId != null && { SchemaVersionId: input.SchemaVersionId }),
        ...(input.SchemaVersionNumber != null && {
            SchemaVersionNumber: serializeAws_json1_1SchemaVersionNumber(input.SchemaVersionNumber, context),
        }),
    };
};
const serializeAws_json1_1PutWorkflowRunPropertiesRequest = (input, context) => {
    return {
        ...(input.Name != null && { Name: input.Name }),
        ...(input.RunId != null && { RunId: input.RunId }),
        ...(input.RunProperties != null && {
            RunProperties: serializeAws_json1_1WorkflowRunProperties(input.RunProperties, context),
        }),
    };
};
const serializeAws_json1_1QuerySchemaVersionMetadataInput = (input, context) => {
    return {
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.MetadataList != null && { MetadataList: serializeAws_json1_1MetadataList(input.MetadataList, context) }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.SchemaId != null && { SchemaId: serializeAws_json1_1SchemaId(input.SchemaId, context) }),
        ...(input.SchemaVersionId != null && { SchemaVersionId: input.SchemaVersionId }),
        ...(input.SchemaVersionNumber != null && {
            SchemaVersionNumber: serializeAws_json1_1SchemaVersionNumber(input.SchemaVersionNumber, context),
        }),
    };
};
const serializeAws_json1_1RecrawlPolicy = (input, context) => {
    return {
        ...(input.RecrawlBehavior != null && { RecrawlBehavior: input.RecrawlBehavior }),
    };
};
const serializeAws_json1_1RedshiftSource = (input, context) => {
    return {
        ...(input.Database != null && { Database: input.Database }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.RedshiftTmpDir != null && { RedshiftTmpDir: input.RedshiftTmpDir }),
        ...(input.Table != null && { Table: input.Table }),
        ...(input.TmpDirIAMRole != null && { TmpDirIAMRole: input.TmpDirIAMRole }),
    };
};
const serializeAws_json1_1RedshiftTarget = (input, context) => {
    return {
        ...(input.Database != null && { Database: input.Database }),
        ...(input.Inputs != null && { Inputs: serializeAws_json1_1OneInput(input.Inputs, context) }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.RedshiftTmpDir != null && { RedshiftTmpDir: input.RedshiftTmpDir }),
        ...(input.Table != null && { Table: input.Table }),
        ...(input.TmpDirIAMRole != null && { TmpDirIAMRole: input.TmpDirIAMRole }),
        ...(input.UpsertRedshiftOptions != null && {
            UpsertRedshiftOptions: serializeAws_json1_1UpsertRedshiftTargetOptions(input.UpsertRedshiftOptions, context),
        }),
    };
};
const serializeAws_json1_1RegisterSchemaVersionInput = (input, context) => {
    return {
        ...(input.SchemaDefinition != null && { SchemaDefinition: input.SchemaDefinition }),
        ...(input.SchemaId != null && { SchemaId: serializeAws_json1_1SchemaId(input.SchemaId, context) }),
    };
};
const serializeAws_json1_1RegistryId = (input, context) => {
    return {
        ...(input.RegistryArn != null && { RegistryArn: input.RegistryArn }),
        ...(input.RegistryName != null && { RegistryName: input.RegistryName }),
    };
};
const serializeAws_json1_1RelationalCatalogSource = (input, context) => {
    return {
        ...(input.Database != null && { Database: input.Database }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Table != null && { Table: input.Table }),
    };
};
const serializeAws_json1_1RemoveSchemaVersionMetadataInput = (input, context) => {
    return {
        ...(input.MetadataKeyValue != null && {
            MetadataKeyValue: serializeAws_json1_1MetadataKeyValuePair(input.MetadataKeyValue, context),
        }),
        ...(input.SchemaId != null && { SchemaId: serializeAws_json1_1SchemaId(input.SchemaId, context) }),
        ...(input.SchemaVersionId != null && { SchemaVersionId: input.SchemaVersionId }),
        ...(input.SchemaVersionNumber != null && {
            SchemaVersionNumber: serializeAws_json1_1SchemaVersionNumber(input.SchemaVersionNumber, context),
        }),
    };
};
const serializeAws_json1_1RenameField = (input, context) => {
    return {
        ...(input.Inputs != null && { Inputs: serializeAws_json1_1OneInput(input.Inputs, context) }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.SourcePath != null && {
            SourcePath: serializeAws_json1_1EnclosedInStringProperties(input.SourcePath, context),
        }),
        ...(input.TargetPath != null && {
            TargetPath: serializeAws_json1_1EnclosedInStringProperties(input.TargetPath, context),
        }),
    };
};
const serializeAws_json1_1ResetJobBookmarkRequest = (input, context) => {
    return {
        ...(input.JobName != null && { JobName: input.JobName }),
        ...(input.RunId != null && { RunId: input.RunId }),
    };
};
const serializeAws_json1_1ResourceUri = (input, context) => {
    return {
        ...(input.ResourceType != null && { ResourceType: input.ResourceType }),
        ...(input.Uri != null && { Uri: input.Uri }),
    };
};
const serializeAws_json1_1ResourceUriList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1ResourceUri(entry, context);
    });
};
const serializeAws_json1_1ResumeWorkflowRunRequest = (input, context) => {
    return {
        ...(input.Name != null && { Name: input.Name }),
        ...(input.NodeIds != null && { NodeIds: serializeAws_json1_1NodeIdList(input.NodeIds, context) }),
        ...(input.RunId != null && { RunId: input.RunId }),
    };
};
const serializeAws_json1_1RulesetNames = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1RunStatementRequest = (input, context) => {
    return {
        ...(input.Code != null && { Code: input.Code }),
        ...(input.RequestOrigin != null && { RequestOrigin: input.RequestOrigin }),
        ...(input.SessionId != null && { SessionId: input.SessionId }),
    };
};
const serializeAws_json1_1S3CatalogHudiSource = (input, context) => {
    return {
        ...(input.AdditionalHudiOptions != null && {
            AdditionalHudiOptions: serializeAws_json1_1AdditionalOptions(input.AdditionalHudiOptions, context),
        }),
        ...(input.Database != null && { Database: input.Database }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.OutputSchemas != null && {
            OutputSchemas: serializeAws_json1_1GlueSchemas(input.OutputSchemas, context),
        }),
        ...(input.Table != null && { Table: input.Table }),
    };
};
const serializeAws_json1_1S3CatalogSource = (input, context) => {
    return {
        ...(input.AdditionalOptions != null && {
            AdditionalOptions: serializeAws_json1_1S3SourceAdditionalOptions(input.AdditionalOptions, context),
        }),
        ...(input.Database != null && { Database: input.Database }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.PartitionPredicate != null && { PartitionPredicate: input.PartitionPredicate }),
        ...(input.Table != null && { Table: input.Table }),
    };
};
const serializeAws_json1_1S3CatalogTarget = (input, context) => {
    return {
        ...(input.Database != null && { Database: input.Database }),
        ...(input.Inputs != null && { Inputs: serializeAws_json1_1OneInput(input.Inputs, context) }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.PartitionKeys != null && {
            PartitionKeys: serializeAws_json1_1GlueStudioPathList(input.PartitionKeys, context),
        }),
        ...(input.SchemaChangePolicy != null && {
            SchemaChangePolicy: serializeAws_json1_1CatalogSchemaChangePolicy(input.SchemaChangePolicy, context),
        }),
        ...(input.Table != null && { Table: input.Table }),
    };
};
const serializeAws_json1_1S3CsvSource = (input, context) => {
    return {
        ...(input.AdditionalOptions != null && {
            AdditionalOptions: serializeAws_json1_1S3DirectSourceAdditionalOptions(input.AdditionalOptions, context),
        }),
        ...(input.CompressionType != null && { CompressionType: input.CompressionType }),
        ...(input.Escaper != null && { Escaper: input.Escaper }),
        ...(input.Exclusions != null && {
            Exclusions: serializeAws_json1_1EnclosedInStringProperties(input.Exclusions, context),
        }),
        ...(input.GroupFiles != null && { GroupFiles: input.GroupFiles }),
        ...(input.GroupSize != null && { GroupSize: input.GroupSize }),
        ...(input.MaxBand != null && { MaxBand: input.MaxBand }),
        ...(input.MaxFilesInBand != null && { MaxFilesInBand: input.MaxFilesInBand }),
        ...(input.Multiline != null && { Multiline: input.Multiline }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.OptimizePerformance != null && { OptimizePerformance: input.OptimizePerformance }),
        ...(input.OutputSchemas != null && {
            OutputSchemas: serializeAws_json1_1GlueSchemas(input.OutputSchemas, context),
        }),
        ...(input.Paths != null && { Paths: serializeAws_json1_1EnclosedInStringProperties(input.Paths, context) }),
        ...(input.QuoteChar != null && { QuoteChar: input.QuoteChar }),
        ...(input.Recurse != null && { Recurse: input.Recurse }),
        ...(input.Separator != null && { Separator: input.Separator }),
        ...(input.SkipFirst != null && { SkipFirst: input.SkipFirst }),
        ...(input.WithHeader != null && { WithHeader: input.WithHeader }),
        ...(input.WriteHeader != null && { WriteHeader: input.WriteHeader }),
    };
};
const serializeAws_json1_1S3DirectSourceAdditionalOptions = (input, context) => {
    return {
        ...(input.BoundedFiles != null && { BoundedFiles: input.BoundedFiles }),
        ...(input.BoundedSize != null && { BoundedSize: input.BoundedSize }),
        ...(input.EnableSamplePath != null && { EnableSamplePath: input.EnableSamplePath }),
        ...(input.SamplePath != null && { SamplePath: input.SamplePath }),
    };
};
const serializeAws_json1_1S3DirectTarget = (input, context) => {
    return {
        ...(input.Compression != null && { Compression: input.Compression }),
        ...(input.Format != null && { Format: input.Format }),
        ...(input.Inputs != null && { Inputs: serializeAws_json1_1OneInput(input.Inputs, context) }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.PartitionKeys != null && {
            PartitionKeys: serializeAws_json1_1GlueStudioPathList(input.PartitionKeys, context),
        }),
        ...(input.Path != null && { Path: input.Path }),
        ...(input.SchemaChangePolicy != null && {
            SchemaChangePolicy: serializeAws_json1_1DirectSchemaChangePolicy(input.SchemaChangePolicy, context),
        }),
    };
};
const serializeAws_json1_1S3Encryption = (input, context) => {
    return {
        ...(input.KmsKeyArn != null && { KmsKeyArn: input.KmsKeyArn }),
        ...(input.S3EncryptionMode != null && { S3EncryptionMode: input.S3EncryptionMode }),
    };
};
const serializeAws_json1_1S3EncryptionList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1S3Encryption(entry, context);
    });
};
const serializeAws_json1_1S3GlueParquetTarget = (input, context) => {
    return {
        ...(input.Compression != null && { Compression: input.Compression }),
        ...(input.Inputs != null && { Inputs: serializeAws_json1_1OneInput(input.Inputs, context) }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.PartitionKeys != null && {
            PartitionKeys: serializeAws_json1_1GlueStudioPathList(input.PartitionKeys, context),
        }),
        ...(input.Path != null && { Path: input.Path }),
        ...(input.SchemaChangePolicy != null && {
            SchemaChangePolicy: serializeAws_json1_1DirectSchemaChangePolicy(input.SchemaChangePolicy, context),
        }),
    };
};
const serializeAws_json1_1S3HudiCatalogTarget = (input, context) => {
    return {
        ...(input.AdditionalOptions != null && {
            AdditionalOptions: serializeAws_json1_1AdditionalOptions(input.AdditionalOptions, context),
        }),
        ...(input.Database != null && { Database: input.Database }),
        ...(input.Inputs != null && { Inputs: serializeAws_json1_1OneInput(input.Inputs, context) }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.PartitionKeys != null && {
            PartitionKeys: serializeAws_json1_1GlueStudioPathList(input.PartitionKeys, context),
        }),
        ...(input.SchemaChangePolicy != null && {
            SchemaChangePolicy: serializeAws_json1_1CatalogSchemaChangePolicy(input.SchemaChangePolicy, context),
        }),
        ...(input.Table != null && { Table: input.Table }),
    };
};
const serializeAws_json1_1S3HudiDirectTarget = (input, context) => {
    return {
        ...(input.AdditionalOptions != null && {
            AdditionalOptions: serializeAws_json1_1AdditionalOptions(input.AdditionalOptions, context),
        }),
        ...(input.Compression != null && { Compression: input.Compression }),
        ...(input.Format != null && { Format: input.Format }),
        ...(input.Inputs != null && { Inputs: serializeAws_json1_1OneInput(input.Inputs, context) }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.PartitionKeys != null && {
            PartitionKeys: serializeAws_json1_1GlueStudioPathList(input.PartitionKeys, context),
        }),
        ...(input.Path != null && { Path: input.Path }),
        ...(input.SchemaChangePolicy != null && {
            SchemaChangePolicy: serializeAws_json1_1DirectSchemaChangePolicy(input.SchemaChangePolicy, context),
        }),
    };
};
const serializeAws_json1_1S3HudiSource = (input, context) => {
    return {
        ...(input.AdditionalHudiOptions != null && {
            AdditionalHudiOptions: serializeAws_json1_1AdditionalOptions(input.AdditionalHudiOptions, context),
        }),
        ...(input.AdditionalOptions != null && {
            AdditionalOptions: serializeAws_json1_1S3DirectSourceAdditionalOptions(input.AdditionalOptions, context),
        }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.OutputSchemas != null && {
            OutputSchemas: serializeAws_json1_1GlueSchemas(input.OutputSchemas, context),
        }),
        ...(input.Paths != null && { Paths: serializeAws_json1_1EnclosedInStringProperties(input.Paths, context) }),
    };
};
const serializeAws_json1_1S3JsonSource = (input, context) => {
    return {
        ...(input.AdditionalOptions != null && {
            AdditionalOptions: serializeAws_json1_1S3DirectSourceAdditionalOptions(input.AdditionalOptions, context),
        }),
        ...(input.CompressionType != null && { CompressionType: input.CompressionType }),
        ...(input.Exclusions != null && {
            Exclusions: serializeAws_json1_1EnclosedInStringProperties(input.Exclusions, context),
        }),
        ...(input.GroupFiles != null && { GroupFiles: input.GroupFiles }),
        ...(input.GroupSize != null && { GroupSize: input.GroupSize }),
        ...(input.JsonPath != null && { JsonPath: input.JsonPath }),
        ...(input.MaxBand != null && { MaxBand: input.MaxBand }),
        ...(input.MaxFilesInBand != null && { MaxFilesInBand: input.MaxFilesInBand }),
        ...(input.Multiline != null && { Multiline: input.Multiline }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.OutputSchemas != null && {
            OutputSchemas: serializeAws_json1_1GlueSchemas(input.OutputSchemas, context),
        }),
        ...(input.Paths != null && { Paths: serializeAws_json1_1EnclosedInStringProperties(input.Paths, context) }),
        ...(input.Recurse != null && { Recurse: input.Recurse }),
    };
};
const serializeAws_json1_1S3ParquetSource = (input, context) => {
    return {
        ...(input.AdditionalOptions != null && {
            AdditionalOptions: serializeAws_json1_1S3DirectSourceAdditionalOptions(input.AdditionalOptions, context),
        }),
        ...(input.CompressionType != null && { CompressionType: input.CompressionType }),
        ...(input.Exclusions != null && {
            Exclusions: serializeAws_json1_1EnclosedInStringProperties(input.Exclusions, context),
        }),
        ...(input.GroupFiles != null && { GroupFiles: input.GroupFiles }),
        ...(input.GroupSize != null && { GroupSize: input.GroupSize }),
        ...(input.MaxBand != null && { MaxBand: input.MaxBand }),
        ...(input.MaxFilesInBand != null && { MaxFilesInBand: input.MaxFilesInBand }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.OutputSchemas != null && {
            OutputSchemas: serializeAws_json1_1GlueSchemas(input.OutputSchemas, context),
        }),
        ...(input.Paths != null && { Paths: serializeAws_json1_1EnclosedInStringProperties(input.Paths, context) }),
        ...(input.Recurse != null && { Recurse: input.Recurse }),
    };
};
const serializeAws_json1_1S3SourceAdditionalOptions = (input, context) => {
    return {
        ...(input.BoundedFiles != null && { BoundedFiles: input.BoundedFiles }),
        ...(input.BoundedSize != null && { BoundedSize: input.BoundedSize }),
    };
};
const serializeAws_json1_1S3Target = (input, context) => {
    return {
        ...(input.ConnectionName != null && { ConnectionName: input.ConnectionName }),
        ...(input.DlqEventQueueArn != null && { DlqEventQueueArn: input.DlqEventQueueArn }),
        ...(input.EventQueueArn != null && { EventQueueArn: input.EventQueueArn }),
        ...(input.Exclusions != null && { Exclusions: serializeAws_json1_1PathList(input.Exclusions, context) }),
        ...(input.Path != null && { Path: input.Path }),
        ...(input.SampleSize != null && { SampleSize: input.SampleSize }),
    };
};
const serializeAws_json1_1S3TargetList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1S3Target(entry, context);
    });
};
const serializeAws_json1_1SchemaChangePolicy = (input, context) => {
    return {
        ...(input.DeleteBehavior != null && { DeleteBehavior: input.DeleteBehavior }),
        ...(input.UpdateBehavior != null && { UpdateBehavior: input.UpdateBehavior }),
    };
};
const serializeAws_json1_1SchemaColumn = (input, context) => {
    return {
        ...(input.DataType != null && { DataType: input.DataType }),
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1SchemaId = (input, context) => {
    return {
        ...(input.RegistryName != null && { RegistryName: input.RegistryName }),
        ...(input.SchemaArn != null && { SchemaArn: input.SchemaArn }),
        ...(input.SchemaName != null && { SchemaName: input.SchemaName }),
    };
};
const serializeAws_json1_1SchemaReference = (input, context) => {
    return {
        ...(input.SchemaId != null && { SchemaId: serializeAws_json1_1SchemaId(input.SchemaId, context) }),
        ...(input.SchemaVersionId != null && { SchemaVersionId: input.SchemaVersionId }),
        ...(input.SchemaVersionNumber != null && { SchemaVersionNumber: input.SchemaVersionNumber }),
    };
};
const serializeAws_json1_1SchemaVersionNumber = (input, context) => {
    return {
        ...(input.LatestVersion != null && { LatestVersion: input.LatestVersion }),
        ...(input.VersionNumber != null && { VersionNumber: input.VersionNumber }),
    };
};
const serializeAws_json1_1SearchPropertyPredicates = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1PropertyPredicate(entry, context);
    });
};
const serializeAws_json1_1SearchTablesRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.Filters != null && { Filters: serializeAws_json1_1SearchPropertyPredicates(input.Filters, context) }),
        ...(input.MaxResults != null && { MaxResults: input.MaxResults }),
        ...(input.NextToken != null && { NextToken: input.NextToken }),
        ...(input.ResourceShareType != null && { ResourceShareType: input.ResourceShareType }),
        ...(input.SearchText != null && { SearchText: input.SearchText }),
        ...(input.SortCriteria != null && { SortCriteria: serializeAws_json1_1SortCriteria(input.SortCriteria, context) }),
    };
};
const serializeAws_json1_1SecurityGroupIdList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1Segment = (input, context) => {
    return {
        ...(input.SegmentNumber != null && { SegmentNumber: input.SegmentNumber }),
        ...(input.TotalSegments != null && { TotalSegments: input.TotalSegments }),
    };
};
const serializeAws_json1_1SelectFields = (input, context) => {
    return {
        ...(input.Inputs != null && { Inputs: serializeAws_json1_1OneInput(input.Inputs, context) }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Paths != null && { Paths: serializeAws_json1_1GlueStudioPathList(input.Paths, context) }),
    };
};
const serializeAws_json1_1SelectFromCollection = (input, context) => {
    return {
        ...(input.Index != null && { Index: input.Index }),
        ...(input.Inputs != null && { Inputs: serializeAws_json1_1OneInput(input.Inputs, context) }),
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1SerDeInfo = (input, context) => {
    return {
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Parameters != null && { Parameters: serializeAws_json1_1ParametersMap(input.Parameters, context) }),
        ...(input.SerializationLibrary != null && { SerializationLibrary: input.SerializationLibrary }),
    };
};
const serializeAws_json1_1SessionCommand = (input, context) => {
    return {
        ...(input.Name != null && { Name: input.Name }),
        ...(input.PythonVersion != null && { PythonVersion: input.PythonVersion }),
    };
};
const serializeAws_json1_1SkewedInfo = (input, context) => {
    return {
        ...(input.SkewedColumnNames != null && {
            SkewedColumnNames: serializeAws_json1_1NameStringList(input.SkewedColumnNames, context),
        }),
        ...(input.SkewedColumnValueLocationMaps != null && {
            SkewedColumnValueLocationMaps: serializeAws_json1_1LocationMap(input.SkewedColumnValueLocationMaps, context),
        }),
        ...(input.SkewedColumnValues != null && {
            SkewedColumnValues: serializeAws_json1_1ColumnValueStringList(input.SkewedColumnValues, context),
        }),
    };
};
const serializeAws_json1_1SortCriteria = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1SortCriterion(entry, context);
    });
};
const serializeAws_json1_1SortCriterion = (input, context) => {
    return {
        ...(input.FieldName != null && { FieldName: input.FieldName }),
        ...(input.Sort != null && { Sort: input.Sort }),
    };
};
const serializeAws_json1_1SourceControlDetails = (input, context) => {
    return {
        ...(input.AuthStrategy != null && { AuthStrategy: input.AuthStrategy }),
        ...(input.AuthToken != null && { AuthToken: input.AuthToken }),
        ...(input.Branch != null && { Branch: input.Branch }),
        ...(input.Folder != null && { Folder: input.Folder }),
        ...(input.LastCommitId != null && { LastCommitId: input.LastCommitId }),
        ...(input.Owner != null && { Owner: input.Owner }),
        ...(input.Provider != null && { Provider: input.Provider }),
        ...(input.Repository != null && { Repository: input.Repository }),
    };
};
const serializeAws_json1_1SparkConnectorSource = (input, context) => {
    return {
        ...(input.AdditionalOptions != null && {
            AdditionalOptions: serializeAws_json1_1AdditionalOptions(input.AdditionalOptions, context),
        }),
        ...(input.ConnectionName != null && { ConnectionName: input.ConnectionName }),
        ...(input.ConnectionType != null && { ConnectionType: input.ConnectionType }),
        ...(input.ConnectorName != null && { ConnectorName: input.ConnectorName }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.OutputSchemas != null && {
            OutputSchemas: serializeAws_json1_1GlueSchemas(input.OutputSchemas, context),
        }),
    };
};
const serializeAws_json1_1SparkConnectorTarget = (input, context) => {
    return {
        ...(input.AdditionalOptions != null && {
            AdditionalOptions: serializeAws_json1_1AdditionalOptions(input.AdditionalOptions, context),
        }),
        ...(input.ConnectionName != null && { ConnectionName: input.ConnectionName }),
        ...(input.ConnectionType != null && { ConnectionType: input.ConnectionType }),
        ...(input.ConnectorName != null && { ConnectorName: input.ConnectorName }),
        ...(input.Inputs != null && { Inputs: serializeAws_json1_1OneInput(input.Inputs, context) }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.OutputSchemas != null && {
            OutputSchemas: serializeAws_json1_1GlueSchemas(input.OutputSchemas, context),
        }),
    };
};
const serializeAws_json1_1SparkSQL = (input, context) => {
    return {
        ...(input.Inputs != null && { Inputs: serializeAws_json1_1ManyInputs(input.Inputs, context) }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.OutputSchemas != null && {
            OutputSchemas: serializeAws_json1_1GlueSchemas(input.OutputSchemas, context),
        }),
        ...(input.SqlAliases != null && { SqlAliases: serializeAws_json1_1SqlAliases(input.SqlAliases, context) }),
        ...(input.SqlQuery != null && { SqlQuery: input.SqlQuery }),
    };
};
const serializeAws_json1_1Spigot = (input, context) => {
    return {
        ...(input.Inputs != null && { Inputs: serializeAws_json1_1OneInput(input.Inputs, context) }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Path != null && { Path: input.Path }),
        ...(input.Prob != null && { Prob: __serializeFloat(input.Prob) }),
        ...(input.Topk != null && { Topk: input.Topk }),
    };
};
const serializeAws_json1_1SplitFields = (input, context) => {
    return {
        ...(input.Inputs != null && { Inputs: serializeAws_json1_1OneInput(input.Inputs, context) }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Paths != null && { Paths: serializeAws_json1_1GlueStudioPathList(input.Paths, context) }),
    };
};
const serializeAws_json1_1SqlAlias = (input, context) => {
    return {
        ...(input.Alias != null && { Alias: input.Alias }),
        ...(input.From != null && { From: input.From }),
    };
};
const serializeAws_json1_1SqlAliases = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1SqlAlias(entry, context);
    });
};
const serializeAws_json1_1StartBlueprintRunRequest = (input, context) => {
    return {
        ...(input.BlueprintName != null && { BlueprintName: input.BlueprintName }),
        ...(input.Parameters != null && { Parameters: input.Parameters }),
        ...(input.RoleArn != null && { RoleArn: input.RoleArn }),
    };
};
const serializeAws_json1_1StartCrawlerRequest = (input, context) => {
    return {
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1StartCrawlerScheduleRequest = (input, context) => {
    return {
        ...(input.CrawlerName != null && { CrawlerName: input.CrawlerName }),
    };
};
const serializeAws_json1_1StartDataQualityRuleRecommendationRunRequest = (input, context) => {
    return {
        ...(input.ClientToken != null && { ClientToken: input.ClientToken }),
        ...(input.CreatedRulesetName != null && { CreatedRulesetName: input.CreatedRulesetName }),
        ...(input.DataSource != null && { DataSource: serializeAws_json1_1DataSource(input.DataSource, context) }),
        ...(input.NumberOfWorkers != null && { NumberOfWorkers: input.NumberOfWorkers }),
        ...(input.Role != null && { Role: input.Role }),
        ...(input.Timeout != null && { Timeout: input.Timeout }),
    };
};
const serializeAws_json1_1StartDataQualityRulesetEvaluationRunRequest = (input, context) => {
    return {
        ...(input.AdditionalRunOptions != null && {
            AdditionalRunOptions: serializeAws_json1_1DataQualityEvaluationRunAdditionalRunOptions(input.AdditionalRunOptions, context),
        }),
        ...(input.ClientToken != null && { ClientToken: input.ClientToken }),
        ...(input.DataSource != null && { DataSource: serializeAws_json1_1DataSource(input.DataSource, context) }),
        ...(input.NumberOfWorkers != null && { NumberOfWorkers: input.NumberOfWorkers }),
        ...(input.Role != null && { Role: input.Role }),
        ...(input.RulesetNames != null && { RulesetNames: serializeAws_json1_1RulesetNames(input.RulesetNames, context) }),
        ...(input.Timeout != null && { Timeout: input.Timeout }),
    };
};
const serializeAws_json1_1StartExportLabelsTaskRunRequest = (input, context) => {
    return {
        ...(input.OutputS3Path != null && { OutputS3Path: input.OutputS3Path }),
        ...(input.TransformId != null && { TransformId: input.TransformId }),
    };
};
const serializeAws_json1_1StartImportLabelsTaskRunRequest = (input, context) => {
    return {
        ...(input.InputS3Path != null && { InputS3Path: input.InputS3Path }),
        ...(input.ReplaceAllLabels != null && { ReplaceAllLabels: input.ReplaceAllLabels }),
        ...(input.TransformId != null && { TransformId: input.TransformId }),
    };
};
const serializeAws_json1_1StartJobRunRequest = (input, context) => {
    return {
        ...(input.AllocatedCapacity != null && { AllocatedCapacity: input.AllocatedCapacity }),
        ...(input.Arguments != null && { Arguments: serializeAws_json1_1GenericMap(input.Arguments, context) }),
        ...(input.ExecutionClass != null && { ExecutionClass: input.ExecutionClass }),
        ...(input.JobName != null && { JobName: input.JobName }),
        ...(input.JobRunId != null && { JobRunId: input.JobRunId }),
        ...(input.MaxCapacity != null && { MaxCapacity: __serializeFloat(input.MaxCapacity) }),
        ...(input.NotificationProperty != null && {
            NotificationProperty: serializeAws_json1_1NotificationProperty(input.NotificationProperty, context),
        }),
        ...(input.NumberOfWorkers != null && { NumberOfWorkers: input.NumberOfWorkers }),
        ...(input.SecurityConfiguration != null && { SecurityConfiguration: input.SecurityConfiguration }),
        ...(input.Timeout != null && { Timeout: input.Timeout }),
        ...(input.WorkerType != null && { WorkerType: input.WorkerType }),
    };
};
const serializeAws_json1_1StartMLEvaluationTaskRunRequest = (input, context) => {
    return {
        ...(input.TransformId != null && { TransformId: input.TransformId }),
    };
};
const serializeAws_json1_1StartMLLabelingSetGenerationTaskRunRequest = (input, context) => {
    return {
        ...(input.OutputS3Path != null && { OutputS3Path: input.OutputS3Path }),
        ...(input.TransformId != null && { TransformId: input.TransformId }),
    };
};
const serializeAws_json1_1StartTriggerRequest = (input, context) => {
    return {
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1StartWorkflowRunRequest = (input, context) => {
    return {
        ...(input.Name != null && { Name: input.Name }),
        ...(input.RunProperties != null && {
            RunProperties: serializeAws_json1_1WorkflowRunProperties(input.RunProperties, context),
        }),
    };
};
const serializeAws_json1_1StopCrawlerRequest = (input, context) => {
    return {
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1StopCrawlerScheduleRequest = (input, context) => {
    return {
        ...(input.CrawlerName != null && { CrawlerName: input.CrawlerName }),
    };
};
const serializeAws_json1_1StopSessionRequest = (input, context) => {
    return {
        ...(input.Id != null && { Id: input.Id }),
        ...(input.RequestOrigin != null && { RequestOrigin: input.RequestOrigin }),
    };
};
const serializeAws_json1_1StopTriggerRequest = (input, context) => {
    return {
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1StopWorkflowRunRequest = (input, context) => {
    return {
        ...(input.Name != null && { Name: input.Name }),
        ...(input.RunId != null && { RunId: input.RunId }),
    };
};
const serializeAws_json1_1StorageDescriptor = (input, context) => {
    return {
        ...(input.AdditionalLocations != null && {
            AdditionalLocations: serializeAws_json1_1LocationStringList(input.AdditionalLocations, context),
        }),
        ...(input.BucketColumns != null && {
            BucketColumns: serializeAws_json1_1NameStringList(input.BucketColumns, context),
        }),
        ...(input.Columns != null && { Columns: serializeAws_json1_1ColumnList(input.Columns, context) }),
        ...(input.Compressed != null && { Compressed: input.Compressed }),
        ...(input.InputFormat != null && { InputFormat: input.InputFormat }),
        ...(input.Location != null && { Location: input.Location }),
        ...(input.NumberOfBuckets != null && { NumberOfBuckets: input.NumberOfBuckets }),
        ...(input.OutputFormat != null && { OutputFormat: input.OutputFormat }),
        ...(input.Parameters != null && { Parameters: serializeAws_json1_1ParametersMap(input.Parameters, context) }),
        ...(input.SchemaReference != null && {
            SchemaReference: serializeAws_json1_1SchemaReference(input.SchemaReference, context),
        }),
        ...(input.SerdeInfo != null && { SerdeInfo: serializeAws_json1_1SerDeInfo(input.SerdeInfo, context) }),
        ...(input.SkewedInfo != null && { SkewedInfo: serializeAws_json1_1SkewedInfo(input.SkewedInfo, context) }),
        ...(input.SortColumns != null && { SortColumns: serializeAws_json1_1OrderList(input.SortColumns, context) }),
        ...(input.StoredAsSubDirectories != null && { StoredAsSubDirectories: input.StoredAsSubDirectories }),
    };
};
const serializeAws_json1_1StreamingDataPreviewOptions = (input, context) => {
    return {
        ...(input.PollingTime != null && { PollingTime: input.PollingTime }),
        ...(input.RecordPollingLimit != null && { RecordPollingLimit: input.RecordPollingLimit }),
    };
};
const serializeAws_json1_1StringColumnStatisticsData = (input, context) => {
    return {
        ...(input.AverageLength != null && { AverageLength: __serializeFloat(input.AverageLength) }),
        ...(input.MaximumLength != null && { MaximumLength: input.MaximumLength }),
        ...(input.NumberOfDistinctValues != null && { NumberOfDistinctValues: input.NumberOfDistinctValues }),
        ...(input.NumberOfNulls != null && { NumberOfNulls: input.NumberOfNulls }),
    };
};
const serializeAws_json1_1StringList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1TableIdentifier = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1TableInput = (input, context) => {
    return {
        ...(input.Description != null && { Description: input.Description }),
        ...(input.LastAccessTime != null && { LastAccessTime: Math.round(input.LastAccessTime.getTime() / 1000) }),
        ...(input.LastAnalyzedTime != null && { LastAnalyzedTime: Math.round(input.LastAnalyzedTime.getTime() / 1000) }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Owner != null && { Owner: input.Owner }),
        ...(input.Parameters != null && { Parameters: serializeAws_json1_1ParametersMap(input.Parameters, context) }),
        ...(input.PartitionKeys != null && { PartitionKeys: serializeAws_json1_1ColumnList(input.PartitionKeys, context) }),
        ...(input.Retention != null && { Retention: input.Retention }),
        ...(input.StorageDescriptor != null && {
            StorageDescriptor: serializeAws_json1_1StorageDescriptor(input.StorageDescriptor, context),
        }),
        ...(input.TableType != null && { TableType: input.TableType }),
        ...(input.TargetTable != null && { TargetTable: serializeAws_json1_1TableIdentifier(input.TargetTable, context) }),
        ...(input.ViewExpandedText != null && { ViewExpandedText: input.ViewExpandedText }),
        ...(input.ViewOriginalText != null && { ViewOriginalText: input.ViewOriginalText }),
    };
};
const serializeAws_json1_1TagKeysList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1TagResourceRequest = (input, context) => {
    return {
        ...(input.ResourceArn != null && { ResourceArn: input.ResourceArn }),
        ...(input.TagsToAdd != null && { TagsToAdd: serializeAws_json1_1TagsMap(input.TagsToAdd, context) }),
    };
};
const serializeAws_json1_1TagsMap = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
const serializeAws_json1_1TaskRunFilterCriteria = (input, context) => {
    return {
        ...(input.StartedAfter != null && { StartedAfter: Math.round(input.StartedAfter.getTime() / 1000) }),
        ...(input.StartedBefore != null && { StartedBefore: Math.round(input.StartedBefore.getTime() / 1000) }),
        ...(input.Status != null && { Status: input.Status }),
        ...(input.TaskRunType != null && { TaskRunType: input.TaskRunType }),
    };
};
const serializeAws_json1_1TaskRunSortCriteria = (input, context) => {
    return {
        ...(input.Column != null && { Column: input.Column }),
        ...(input.SortDirection != null && { SortDirection: input.SortDirection }),
    };
};
const serializeAws_json1_1TransformConfigParameter = (input, context) => {
    return {
        ...(input.IsOptional != null && { IsOptional: input.IsOptional }),
        ...(input.ListType != null && { ListType: input.ListType }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Type != null && { Type: input.Type }),
        ...(input.ValidationMessage != null && { ValidationMessage: input.ValidationMessage }),
        ...(input.ValidationRule != null && { ValidationRule: input.ValidationRule }),
        ...(input.Value != null && { Value: serializeAws_json1_1EnclosedInStringProperties(input.Value, context) }),
    };
};
const serializeAws_json1_1TransformConfigParameterList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1TransformConfigParameter(entry, context);
    });
};
const serializeAws_json1_1TransformEncryption = (input, context) => {
    return {
        ...(input.MlUserDataEncryption != null && {
            MlUserDataEncryption: serializeAws_json1_1MLUserDataEncryption(input.MlUserDataEncryption, context),
        }),
        ...(input.TaskRunSecurityConfigurationName != null && {
            TaskRunSecurityConfigurationName: input.TaskRunSecurityConfigurationName,
        }),
    };
};
const serializeAws_json1_1TransformFilterCriteria = (input, context) => {
    return {
        ...(input.CreatedAfter != null && { CreatedAfter: Math.round(input.CreatedAfter.getTime() / 1000) }),
        ...(input.CreatedBefore != null && { CreatedBefore: Math.round(input.CreatedBefore.getTime() / 1000) }),
        ...(input.GlueVersion != null && { GlueVersion: input.GlueVersion }),
        ...(input.LastModifiedAfter != null && { LastModifiedAfter: Math.round(input.LastModifiedAfter.getTime() / 1000) }),
        ...(input.LastModifiedBefore != null && {
            LastModifiedBefore: Math.round(input.LastModifiedBefore.getTime() / 1000),
        }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Schema != null && { Schema: serializeAws_json1_1TransformSchema(input.Schema, context) }),
        ...(input.Status != null && { Status: input.Status }),
        ...(input.TransformType != null && { TransformType: input.TransformType }),
    };
};
const serializeAws_json1_1TransformParameters = (input, context) => {
    return {
        ...(input.FindMatchesParameters != null && {
            FindMatchesParameters: serializeAws_json1_1FindMatchesParameters(input.FindMatchesParameters, context),
        }),
        ...(input.TransformType != null && { TransformType: input.TransformType }),
    };
};
const serializeAws_json1_1TransformSchema = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1SchemaColumn(entry, context);
    });
};
const serializeAws_json1_1TransformSortCriteria = (input, context) => {
    return {
        ...(input.Column != null && { Column: input.Column }),
        ...(input.SortDirection != null && { SortDirection: input.SortDirection }),
    };
};
const serializeAws_json1_1TriggerNameList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1TriggerUpdate = (input, context) => {
    return {
        ...(input.Actions != null && { Actions: serializeAws_json1_1ActionList(input.Actions, context) }),
        ...(input.Description != null && { Description: input.Description }),
        ...(input.EventBatchingCondition != null && {
            EventBatchingCondition: serializeAws_json1_1EventBatchingCondition(input.EventBatchingCondition, context),
        }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Predicate != null && { Predicate: serializeAws_json1_1Predicate(input.Predicate, context) }),
        ...(input.Schedule != null && { Schedule: input.Schedule }),
    };
};
const serializeAws_json1_1TwoInputs = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1Union = (input, context) => {
    return {
        ...(input.Inputs != null && { Inputs: serializeAws_json1_1TwoInputs(input.Inputs, context) }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.UnionType != null && { UnionType: input.UnionType }),
    };
};
const serializeAws_json1_1UntagResourceRequest = (input, context) => {
    return {
        ...(input.ResourceArn != null && { ResourceArn: input.ResourceArn }),
        ...(input.TagsToRemove != null && { TagsToRemove: serializeAws_json1_1TagKeysList(input.TagsToRemove, context) }),
    };
};
const serializeAws_json1_1UpdateBlueprintRequest = (input, context) => {
    return {
        ...(input.BlueprintLocation != null && { BlueprintLocation: input.BlueprintLocation }),
        ...(input.Description != null && { Description: input.Description }),
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1UpdateClassifierRequest = (input, context) => {
    return {
        ...(input.CsvClassifier != null && {
            CsvClassifier: serializeAws_json1_1UpdateCsvClassifierRequest(input.CsvClassifier, context),
        }),
        ...(input.GrokClassifier != null && {
            GrokClassifier: serializeAws_json1_1UpdateGrokClassifierRequest(input.GrokClassifier, context),
        }),
        ...(input.JsonClassifier != null && {
            JsonClassifier: serializeAws_json1_1UpdateJsonClassifierRequest(input.JsonClassifier, context),
        }),
        ...(input.XMLClassifier != null && {
            XMLClassifier: serializeAws_json1_1UpdateXMLClassifierRequest(input.XMLClassifier, context),
        }),
    };
};
const serializeAws_json1_1UpdateColumnStatisticsForPartitionRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.ColumnStatisticsList != null && {
            ColumnStatisticsList: serializeAws_json1_1UpdateColumnStatisticsList(input.ColumnStatisticsList, context),
        }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.PartitionValues != null && {
            PartitionValues: serializeAws_json1_1ValueStringList(input.PartitionValues, context),
        }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const serializeAws_json1_1UpdateColumnStatisticsForTableRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.ColumnStatisticsList != null && {
            ColumnStatisticsList: serializeAws_json1_1UpdateColumnStatisticsList(input.ColumnStatisticsList, context),
        }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const serializeAws_json1_1UpdateColumnStatisticsList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return serializeAws_json1_1ColumnStatistics(entry, context);
    });
};
const serializeAws_json1_1UpdateConnectionRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.ConnectionInput != null && {
            ConnectionInput: serializeAws_json1_1ConnectionInput(input.ConnectionInput, context),
        }),
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1UpdateCrawlerRequest = (input, context) => {
    return {
        ...(input.Classifiers != null && {
            Classifiers: serializeAws_json1_1ClassifierNameList(input.Classifiers, context),
        }),
        ...(input.Configuration != null && { Configuration: input.Configuration }),
        ...(input.CrawlerSecurityConfiguration != null && {
            CrawlerSecurityConfiguration: input.CrawlerSecurityConfiguration,
        }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.Description != null && { Description: input.Description }),
        ...(input.LakeFormationConfiguration != null && {
            LakeFormationConfiguration: serializeAws_json1_1LakeFormationConfiguration(input.LakeFormationConfiguration, context),
        }),
        ...(input.LineageConfiguration != null && {
            LineageConfiguration: serializeAws_json1_1LineageConfiguration(input.LineageConfiguration, context),
        }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.RecrawlPolicy != null && {
            RecrawlPolicy: serializeAws_json1_1RecrawlPolicy(input.RecrawlPolicy, context),
        }),
        ...(input.Role != null && { Role: input.Role }),
        ...(input.Schedule != null && { Schedule: input.Schedule }),
        ...(input.SchemaChangePolicy != null && {
            SchemaChangePolicy: serializeAws_json1_1SchemaChangePolicy(input.SchemaChangePolicy, context),
        }),
        ...(input.TablePrefix != null && { TablePrefix: input.TablePrefix }),
        ...(input.Targets != null && { Targets: serializeAws_json1_1CrawlerTargets(input.Targets, context) }),
    };
};
const serializeAws_json1_1UpdateCrawlerScheduleRequest = (input, context) => {
    return {
        ...(input.CrawlerName != null && { CrawlerName: input.CrawlerName }),
        ...(input.Schedule != null && { Schedule: input.Schedule }),
    };
};
const serializeAws_json1_1UpdateCsvClassifierRequest = (input, context) => {
    return {
        ...(input.AllowSingleColumn != null && { AllowSingleColumn: input.AllowSingleColumn }),
        ...(input.ContainsHeader != null && { ContainsHeader: input.ContainsHeader }),
        ...(input.CustomDatatypeConfigured != null && { CustomDatatypeConfigured: input.CustomDatatypeConfigured }),
        ...(input.CustomDatatypes != null && {
            CustomDatatypes: serializeAws_json1_1CustomDatatypes(input.CustomDatatypes, context),
        }),
        ...(input.Delimiter != null && { Delimiter: input.Delimiter }),
        ...(input.DisableValueTrimming != null && { DisableValueTrimming: input.DisableValueTrimming }),
        ...(input.Header != null && { Header: serializeAws_json1_1CsvHeader(input.Header, context) }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.QuoteSymbol != null && { QuoteSymbol: input.QuoteSymbol }),
    };
};
const serializeAws_json1_1UpdateDatabaseRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.DatabaseInput != null && {
            DatabaseInput: serializeAws_json1_1DatabaseInput(input.DatabaseInput, context),
        }),
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1UpdateDataQualityRulesetRequest = (input, context) => {
    return {
        ...(input.Description != null && { Description: input.Description }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.Ruleset != null && { Ruleset: input.Ruleset }),
        ...(input.UpdatedName != null && { UpdatedName: input.UpdatedName }),
    };
};
const serializeAws_json1_1UpdateDevEndpointRequest = (input, context) => {
    return {
        ...(input.AddArguments != null && { AddArguments: serializeAws_json1_1MapValue(input.AddArguments, context) }),
        ...(input.AddPublicKeys != null && {
            AddPublicKeys: serializeAws_json1_1PublicKeysList(input.AddPublicKeys, context),
        }),
        ...(input.CustomLibraries != null && {
            CustomLibraries: serializeAws_json1_1DevEndpointCustomLibraries(input.CustomLibraries, context),
        }),
        ...(input.DeleteArguments != null && {
            DeleteArguments: serializeAws_json1_1StringList(input.DeleteArguments, context),
        }),
        ...(input.DeletePublicKeys != null && {
            DeletePublicKeys: serializeAws_json1_1PublicKeysList(input.DeletePublicKeys, context),
        }),
        ...(input.EndpointName != null && { EndpointName: input.EndpointName }),
        ...(input.PublicKey != null && { PublicKey: input.PublicKey }),
        ...(input.UpdateEtlLibraries != null && { UpdateEtlLibraries: input.UpdateEtlLibraries }),
    };
};
const serializeAws_json1_1UpdateGrokClassifierRequest = (input, context) => {
    return {
        ...(input.Classification != null && { Classification: input.Classification }),
        ...(input.CustomPatterns != null && { CustomPatterns: input.CustomPatterns }),
        ...(input.GrokPattern != null && { GrokPattern: input.GrokPattern }),
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1UpdateJobFromSourceControlRequest = (input, context) => {
    return {
        ...(input.AuthStrategy != null && { AuthStrategy: input.AuthStrategy }),
        ...(input.AuthToken != null && { AuthToken: input.AuthToken }),
        ...(input.BranchName != null && { BranchName: input.BranchName }),
        ...(input.CommitId != null && { CommitId: input.CommitId }),
        ...(input.Folder != null && { Folder: input.Folder }),
        ...(input.JobName != null && { JobName: input.JobName }),
        ...(input.Provider != null && { Provider: input.Provider }),
        ...(input.RepositoryName != null && { RepositoryName: input.RepositoryName }),
        ...(input.RepositoryOwner != null && { RepositoryOwner: input.RepositoryOwner }),
    };
};
const serializeAws_json1_1UpdateJobRequest = (input, context) => {
    return {
        ...(input.JobName != null && { JobName: input.JobName }),
        ...(input.JobUpdate != null && { JobUpdate: serializeAws_json1_1JobUpdate(input.JobUpdate, context) }),
    };
};
const serializeAws_json1_1UpdateJsonClassifierRequest = (input, context) => {
    return {
        ...(input.JsonPath != null && { JsonPath: input.JsonPath }),
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1UpdateMLTransformRequest = (input, context) => {
    return {
        ...(input.Description != null && { Description: input.Description }),
        ...(input.GlueVersion != null && { GlueVersion: input.GlueVersion }),
        ...(input.MaxCapacity != null && { MaxCapacity: __serializeFloat(input.MaxCapacity) }),
        ...(input.MaxRetries != null && { MaxRetries: input.MaxRetries }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.NumberOfWorkers != null && { NumberOfWorkers: input.NumberOfWorkers }),
        ...(input.Parameters != null && { Parameters: serializeAws_json1_1TransformParameters(input.Parameters, context) }),
        ...(input.Role != null && { Role: input.Role }),
        ...(input.Timeout != null && { Timeout: input.Timeout }),
        ...(input.TransformId != null && { TransformId: input.TransformId }),
        ...(input.WorkerType != null && { WorkerType: input.WorkerType }),
    };
};
const serializeAws_json1_1UpdatePartitionRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.PartitionInput != null && {
            PartitionInput: serializeAws_json1_1PartitionInput(input.PartitionInput, context),
        }),
        ...(input.PartitionValueList != null && {
            PartitionValueList: serializeAws_json1_1BoundedPartitionValueList(input.PartitionValueList, context),
        }),
        ...(input.TableName != null && { TableName: input.TableName }),
    };
};
const serializeAws_json1_1UpdateRegistryInput = (input, context) => {
    return {
        ...(input.Description != null && { Description: input.Description }),
        ...(input.RegistryId != null && { RegistryId: serializeAws_json1_1RegistryId(input.RegistryId, context) }),
    };
};
const serializeAws_json1_1UpdateSchemaInput = (input, context) => {
    return {
        ...(input.Compatibility != null && { Compatibility: input.Compatibility }),
        ...(input.Description != null && { Description: input.Description }),
        ...(input.SchemaId != null && { SchemaId: serializeAws_json1_1SchemaId(input.SchemaId, context) }),
        ...(input.SchemaVersionNumber != null && {
            SchemaVersionNumber: serializeAws_json1_1SchemaVersionNumber(input.SchemaVersionNumber, context),
        }),
    };
};
const serializeAws_json1_1UpdateSourceControlFromJobRequest = (input, context) => {
    return {
        ...(input.AuthStrategy != null && { AuthStrategy: input.AuthStrategy }),
        ...(input.AuthToken != null && { AuthToken: input.AuthToken }),
        ...(input.BranchName != null && { BranchName: input.BranchName }),
        ...(input.CommitId != null && { CommitId: input.CommitId }),
        ...(input.Folder != null && { Folder: input.Folder }),
        ...(input.JobName != null && { JobName: input.JobName }),
        ...(input.Provider != null && { Provider: input.Provider }),
        ...(input.RepositoryName != null && { RepositoryName: input.RepositoryName }),
        ...(input.RepositoryOwner != null && { RepositoryOwner: input.RepositoryOwner }),
    };
};
const serializeAws_json1_1UpdateTableRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.SkipArchive != null && { SkipArchive: input.SkipArchive }),
        ...(input.TableInput != null && { TableInput: serializeAws_json1_1TableInput(input.TableInput, context) }),
        ...(input.TransactionId != null && { TransactionId: input.TransactionId }),
        ...(input.VersionId != null && { VersionId: input.VersionId }),
    };
};
const serializeAws_json1_1UpdateTriggerRequest = (input, context) => {
    return {
        ...(input.Name != null && { Name: input.Name }),
        ...(input.TriggerUpdate != null && {
            TriggerUpdate: serializeAws_json1_1TriggerUpdate(input.TriggerUpdate, context),
        }),
    };
};
const serializeAws_json1_1UpdateUserDefinedFunctionRequest = (input, context) => {
    return {
        ...(input.CatalogId != null && { CatalogId: input.CatalogId }),
        ...(input.DatabaseName != null && { DatabaseName: input.DatabaseName }),
        ...(input.FunctionInput != null && {
            FunctionInput: serializeAws_json1_1UserDefinedFunctionInput(input.FunctionInput, context),
        }),
        ...(input.FunctionName != null && { FunctionName: input.FunctionName }),
    };
};
const serializeAws_json1_1UpdateWorkflowRequest = (input, context) => {
    return {
        ...(input.DefaultRunProperties != null && {
            DefaultRunProperties: serializeAws_json1_1WorkflowRunProperties(input.DefaultRunProperties, context),
        }),
        ...(input.Description != null && { Description: input.Description }),
        ...(input.MaxConcurrentRuns != null && { MaxConcurrentRuns: input.MaxConcurrentRuns }),
        ...(input.Name != null && { Name: input.Name }),
    };
};
const serializeAws_json1_1UpdateXMLClassifierRequest = (input, context) => {
    return {
        ...(input.Classification != null && { Classification: input.Classification }),
        ...(input.Name != null && { Name: input.Name }),
        ...(input.RowTag != null && { RowTag: input.RowTag }),
    };
};
const serializeAws_json1_1UpsertRedshiftTargetOptions = (input, context) => {
    return {
        ...(input.ConnectionName != null && { ConnectionName: input.ConnectionName }),
        ...(input.TableLocation != null && { TableLocation: input.TableLocation }),
        ...(input.UpsertKeys != null && {
            UpsertKeys: serializeAws_json1_1EnclosedInStringPropertiesMinOne(input.UpsertKeys, context),
        }),
    };
};
const serializeAws_json1_1UserDefinedFunctionInput = (input, context) => {
    return {
        ...(input.ClassName != null && { ClassName: input.ClassName }),
        ...(input.FunctionName != null && { FunctionName: input.FunctionName }),
        ...(input.OwnerName != null && { OwnerName: input.OwnerName }),
        ...(input.OwnerType != null && { OwnerType: input.OwnerType }),
        ...(input.ResourceUris != null && {
            ResourceUris: serializeAws_json1_1ResourceUriList(input.ResourceUris, context),
        }),
    };
};
const serializeAws_json1_1ValueStringList = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1WorkflowNames = (input, context) => {
    return input
        .filter((e) => e != null)
        .map((entry) => {
        return entry;
    });
};
const serializeAws_json1_1WorkflowRunProperties = (input, context) => {
    return Object.entries(input).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = value;
        return acc;
    }, {});
};
const deserializeAws_json1_1AccessDeniedException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_1Action = (output, context) => {
    return {
        Arguments: output.Arguments != null ? deserializeAws_json1_1GenericMap(output.Arguments, context) : undefined,
        CrawlerName: __expectString(output.CrawlerName),
        JobName: __expectString(output.JobName),
        NotificationProperty: output.NotificationProperty != null
            ? deserializeAws_json1_1NotificationProperty(output.NotificationProperty, context)
            : undefined,
        SecurityConfiguration: __expectString(output.SecurityConfiguration),
        Timeout: __expectInt32(output.Timeout),
    };
};
const deserializeAws_json1_1ActionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Action(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1AdditionalOptions = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = __expectString(value);
        return acc;
    }, {});
};
const deserializeAws_json1_1Aggregate = (output, context) => {
    return {
        Aggs: output.Aggs != null ? deserializeAws_json1_1AggregateOperations(output.Aggs, context) : undefined,
        Groups: output.Groups != null ? deserializeAws_json1_1GlueStudioPathList(output.Groups, context) : undefined,
        Inputs: output.Inputs != null ? deserializeAws_json1_1OneInput(output.Inputs, context) : undefined,
        Name: __expectString(output.Name),
    };
};
const deserializeAws_json1_1AggregateOperation = (output, context) => {
    return {
        AggFunc: __expectString(output.AggFunc),
        Column: output.Column != null ? deserializeAws_json1_1EnclosedInStringProperties(output.Column, context) : undefined,
    };
};
const deserializeAws_json1_1AggregateOperations = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1AggregateOperation(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1AlreadyExistsException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_1ApplyMapping = (output, context) => {
    return {
        Inputs: output.Inputs != null ? deserializeAws_json1_1OneInput(output.Inputs, context) : undefined,
        Mapping: output.Mapping != null ? deserializeAws_json1_1Mappings(output.Mapping, context) : undefined,
        Name: __expectString(output.Name),
    };
};
const deserializeAws_json1_1AthenaConnectorSource = (output, context) => {
    return {
        ConnectionName: __expectString(output.ConnectionName),
        ConnectionTable: __expectString(output.ConnectionTable),
        ConnectionType: __expectString(output.ConnectionType),
        ConnectorName: __expectString(output.ConnectorName),
        Name: __expectString(output.Name),
        OutputSchemas: output.OutputSchemas != null ? deserializeAws_json1_1GlueSchemas(output.OutputSchemas, context) : undefined,
        SchemaName: __expectString(output.SchemaName),
    };
};
const deserializeAws_json1_1BackfillError = (output, context) => {
    return {
        Code: __expectString(output.Code),
        Partitions: output.Partitions != null
            ? deserializeAws_json1_1BackfillErroredPartitionsList(output.Partitions, context)
            : undefined,
    };
};
const deserializeAws_json1_1BackfillErroredPartitionsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1PartitionValueList(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1BackfillErrors = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1BackfillError(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1BasicCatalogTarget = (output, context) => {
    return {
        Database: __expectString(output.Database),
        Inputs: output.Inputs != null ? deserializeAws_json1_1OneInput(output.Inputs, context) : undefined,
        Name: __expectString(output.Name),
        Table: __expectString(output.Table),
    };
};
const deserializeAws_json1_1BatchCreatePartitionResponse = (output, context) => {
    return {
        Errors: output.Errors != null ? deserializeAws_json1_1PartitionErrors(output.Errors, context) : undefined,
    };
};
const deserializeAws_json1_1BatchDeleteConnectionResponse = (output, context) => {
    return {
        Errors: output.Errors != null ? deserializeAws_json1_1ErrorByName(output.Errors, context) : undefined,
        Succeeded: output.Succeeded != null ? deserializeAws_json1_1NameStringList(output.Succeeded, context) : undefined,
    };
};
const deserializeAws_json1_1BatchDeletePartitionResponse = (output, context) => {
    return {
        Errors: output.Errors != null ? deserializeAws_json1_1PartitionErrors(output.Errors, context) : undefined,
    };
};
const deserializeAws_json1_1BatchDeleteTableResponse = (output, context) => {
    return {
        Errors: output.Errors != null ? deserializeAws_json1_1TableErrors(output.Errors, context) : undefined,
    };
};
const deserializeAws_json1_1BatchDeleteTableVersionResponse = (output, context) => {
    return {
        Errors: output.Errors != null ? deserializeAws_json1_1TableVersionErrors(output.Errors, context) : undefined,
    };
};
const deserializeAws_json1_1BatchGetBlueprintsResponse = (output, context) => {
    return {
        Blueprints: output.Blueprints != null ? deserializeAws_json1_1Blueprints(output.Blueprints, context) : undefined,
        MissingBlueprints: output.MissingBlueprints != null
            ? deserializeAws_json1_1BlueprintNames(output.MissingBlueprints, context)
            : undefined,
    };
};
const deserializeAws_json1_1BatchGetCrawlersResponse = (output, context) => {
    return {
        Crawlers: output.Crawlers != null ? deserializeAws_json1_1CrawlerList(output.Crawlers, context) : undefined,
        CrawlersNotFound: output.CrawlersNotFound != null
            ? deserializeAws_json1_1CrawlerNameList(output.CrawlersNotFound, context)
            : undefined,
    };
};
const deserializeAws_json1_1BatchGetCustomEntityTypesResponse = (output, context) => {
    return {
        CustomEntityTypes: output.CustomEntityTypes != null
            ? deserializeAws_json1_1CustomEntityTypes(output.CustomEntityTypes, context)
            : undefined,
        CustomEntityTypesNotFound: output.CustomEntityTypesNotFound != null
            ? deserializeAws_json1_1CustomEntityTypeNames(output.CustomEntityTypesNotFound, context)
            : undefined,
    };
};
const deserializeAws_json1_1BatchGetDataQualityResultResponse = (output, context) => {
    return {
        Results: output.Results != null ? deserializeAws_json1_1DataQualityResultsList(output.Results, context) : undefined,
        ResultsNotFound: output.ResultsNotFound != null
            ? deserializeAws_json1_1DataQualityResultIds(output.ResultsNotFound, context)
            : undefined,
    };
};
const deserializeAws_json1_1BatchGetDevEndpointsResponse = (output, context) => {
    return {
        DevEndpoints: output.DevEndpoints != null ? deserializeAws_json1_1DevEndpointList(output.DevEndpoints, context) : undefined,
        DevEndpointsNotFound: output.DevEndpointsNotFound != null
            ? deserializeAws_json1_1DevEndpointNames(output.DevEndpointsNotFound, context)
            : undefined,
    };
};
const deserializeAws_json1_1BatchGetJobsResponse = (output, context) => {
    return {
        Jobs: output.Jobs != null ? deserializeAws_json1_1JobList(output.Jobs, context) : undefined,
        JobsNotFound: output.JobsNotFound != null ? deserializeAws_json1_1JobNameList(output.JobsNotFound, context) : undefined,
    };
};
const deserializeAws_json1_1BatchGetPartitionResponse = (output, context) => {
    return {
        Partitions: output.Partitions != null ? deserializeAws_json1_1PartitionList(output.Partitions, context) : undefined,
        UnprocessedKeys: output.UnprocessedKeys != null
            ? deserializeAws_json1_1BatchGetPartitionValueList(output.UnprocessedKeys, context)
            : undefined,
    };
};
const deserializeAws_json1_1BatchGetPartitionValueList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1PartitionValueList(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1BatchGetTriggersResponse = (output, context) => {
    return {
        Triggers: output.Triggers != null ? deserializeAws_json1_1TriggerList(output.Triggers, context) : undefined,
        TriggersNotFound: output.TriggersNotFound != null
            ? deserializeAws_json1_1TriggerNameList(output.TriggersNotFound, context)
            : undefined,
    };
};
const deserializeAws_json1_1BatchGetWorkflowsResponse = (output, context) => {
    return {
        MissingWorkflows: output.MissingWorkflows != null
            ? deserializeAws_json1_1WorkflowNames(output.MissingWorkflows, context)
            : undefined,
        Workflows: output.Workflows != null ? deserializeAws_json1_1Workflows(output.Workflows, context) : undefined,
    };
};
const deserializeAws_json1_1BatchStopJobRunError = (output, context) => {
    return {
        ErrorDetail: output.ErrorDetail != null ? deserializeAws_json1_1ErrorDetail(output.ErrorDetail, context) : undefined,
        JobName: __expectString(output.JobName),
        JobRunId: __expectString(output.JobRunId),
    };
};
const deserializeAws_json1_1BatchStopJobRunErrorList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1BatchStopJobRunError(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1BatchStopJobRunResponse = (output, context) => {
    return {
        Errors: output.Errors != null ? deserializeAws_json1_1BatchStopJobRunErrorList(output.Errors, context) : undefined,
        SuccessfulSubmissions: output.SuccessfulSubmissions != null
            ? deserializeAws_json1_1BatchStopJobRunSuccessfulSubmissionList(output.SuccessfulSubmissions, context)
            : undefined,
    };
};
const deserializeAws_json1_1BatchStopJobRunSuccessfulSubmission = (output, context) => {
    return {
        JobName: __expectString(output.JobName),
        JobRunId: __expectString(output.JobRunId),
    };
};
const deserializeAws_json1_1BatchStopJobRunSuccessfulSubmissionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1BatchStopJobRunSuccessfulSubmission(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1BatchUpdatePartitionFailureEntry = (output, context) => {
    return {
        ErrorDetail: output.ErrorDetail != null ? deserializeAws_json1_1ErrorDetail(output.ErrorDetail, context) : undefined,
        PartitionValueList: output.PartitionValueList != null
            ? deserializeAws_json1_1BoundedPartitionValueList(output.PartitionValueList, context)
            : undefined,
    };
};
const deserializeAws_json1_1BatchUpdatePartitionFailureList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1BatchUpdatePartitionFailureEntry(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1BatchUpdatePartitionResponse = (output, context) => {
    return {
        Errors: output.Errors != null ? deserializeAws_json1_1BatchUpdatePartitionFailureList(output.Errors, context) : undefined,
    };
};
const deserializeAws_json1_1BinaryColumnStatisticsData = (output, context) => {
    return {
        AverageLength: __limitedParseDouble(output.AverageLength),
        MaximumLength: __expectLong(output.MaximumLength),
        NumberOfNulls: __expectLong(output.NumberOfNulls),
    };
};
const deserializeAws_json1_1Blueprint = (output, context) => {
    return {
        BlueprintLocation: __expectString(output.BlueprintLocation),
        BlueprintServiceLocation: __expectString(output.BlueprintServiceLocation),
        CreatedOn: output.CreatedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedOn))) : undefined,
        Description: __expectString(output.Description),
        ErrorMessage: __expectString(output.ErrorMessage),
        LastActiveDefinition: output.LastActiveDefinition != null
            ? deserializeAws_json1_1LastActiveDefinition(output.LastActiveDefinition, context)
            : undefined,
        LastModifiedOn: output.LastModifiedOn != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedOn)))
            : undefined,
        Name: __expectString(output.Name),
        ParameterSpec: __expectString(output.ParameterSpec),
        Status: __expectString(output.Status),
    };
};
const deserializeAws_json1_1BlueprintDetails = (output, context) => {
    return {
        BlueprintName: __expectString(output.BlueprintName),
        RunId: __expectString(output.RunId),
    };
};
const deserializeAws_json1_1BlueprintNames = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1BlueprintRun = (output, context) => {
    return {
        BlueprintName: __expectString(output.BlueprintName),
        CompletedOn: output.CompletedOn != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CompletedOn)))
            : undefined,
        ErrorMessage: __expectString(output.ErrorMessage),
        Parameters: __expectString(output.Parameters),
        RoleArn: __expectString(output.RoleArn),
        RollbackErrorMessage: __expectString(output.RollbackErrorMessage),
        RunId: __expectString(output.RunId),
        StartedOn: output.StartedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartedOn))) : undefined,
        State: __expectString(output.State),
        WorkflowName: __expectString(output.WorkflowName),
    };
};
const deserializeAws_json1_1BlueprintRuns = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1BlueprintRun(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1Blueprints = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Blueprint(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1BooleanColumnStatisticsData = (output, context) => {
    return {
        NumberOfFalses: __expectLong(output.NumberOfFalses),
        NumberOfNulls: __expectLong(output.NumberOfNulls),
        NumberOfTrues: __expectLong(output.NumberOfTrues),
    };
};
const deserializeAws_json1_1BoundedPartitionValueList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1CancelDataQualityRuleRecommendationRunResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1CancelDataQualityRulesetEvaluationRunResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1CancelMLTaskRunResponse = (output, context) => {
    return {
        Status: __expectString(output.Status),
        TaskRunId: __expectString(output.TaskRunId),
        TransformId: __expectString(output.TransformId),
    };
};
const deserializeAws_json1_1CancelStatementResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1CatalogHudiSource = (output, context) => {
    return {
        AdditionalHudiOptions: output.AdditionalHudiOptions != null
            ? deserializeAws_json1_1AdditionalOptions(output.AdditionalHudiOptions, context)
            : undefined,
        Database: __expectString(output.Database),
        Name: __expectString(output.Name),
        OutputSchemas: output.OutputSchemas != null ? deserializeAws_json1_1GlueSchemas(output.OutputSchemas, context) : undefined,
        Table: __expectString(output.Table),
    };
};
const deserializeAws_json1_1CatalogImportStatus = (output, context) => {
    return {
        ImportCompleted: __expectBoolean(output.ImportCompleted),
        ImportTime: output.ImportTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.ImportTime))) : undefined,
        ImportedBy: __expectString(output.ImportedBy),
    };
};
const deserializeAws_json1_1CatalogKafkaSource = (output, context) => {
    return {
        DataPreviewOptions: output.DataPreviewOptions != null
            ? deserializeAws_json1_1StreamingDataPreviewOptions(output.DataPreviewOptions, context)
            : undefined,
        Database: __expectString(output.Database),
        DetectSchema: __expectBoolean(output.DetectSchema),
        Name: __expectString(output.Name),
        StreamingOptions: output.StreamingOptions != null
            ? deserializeAws_json1_1KafkaStreamingSourceOptions(output.StreamingOptions, context)
            : undefined,
        Table: __expectString(output.Table),
        WindowSize: __expectInt32(output.WindowSize),
    };
};
const deserializeAws_json1_1CatalogKinesisSource = (output, context) => {
    return {
        DataPreviewOptions: output.DataPreviewOptions != null
            ? deserializeAws_json1_1StreamingDataPreviewOptions(output.DataPreviewOptions, context)
            : undefined,
        Database: __expectString(output.Database),
        DetectSchema: __expectBoolean(output.DetectSchema),
        Name: __expectString(output.Name),
        StreamingOptions: output.StreamingOptions != null
            ? deserializeAws_json1_1KinesisStreamingSourceOptions(output.StreamingOptions, context)
            : undefined,
        Table: __expectString(output.Table),
        WindowSize: __expectInt32(output.WindowSize),
    };
};
const deserializeAws_json1_1CatalogSchemaChangePolicy = (output, context) => {
    return {
        EnableUpdateCatalog: __expectBoolean(output.EnableUpdateCatalog),
        UpdateBehavior: __expectString(output.UpdateBehavior),
    };
};
const deserializeAws_json1_1CatalogSource = (output, context) => {
    return {
        Database: __expectString(output.Database),
        Name: __expectString(output.Name),
        Table: __expectString(output.Table),
    };
};
const deserializeAws_json1_1CatalogTablesList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1CatalogTarget = (output, context) => {
    return {
        ConnectionName: __expectString(output.ConnectionName),
        DatabaseName: __expectString(output.DatabaseName),
        DlqEventQueueArn: __expectString(output.DlqEventQueueArn),
        EventQueueArn: __expectString(output.EventQueueArn),
        Tables: output.Tables != null ? deserializeAws_json1_1CatalogTablesList(output.Tables, context) : undefined,
    };
};
const deserializeAws_json1_1CatalogTargetList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1CatalogTarget(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1CheckSchemaVersionValidityResponse = (output, context) => {
    return {
        Error: __expectString(output.Error),
        Valid: __expectBoolean(output.Valid),
    };
};
const deserializeAws_json1_1Classifier = (output, context) => {
    return {
        CsvClassifier: output.CsvClassifier != null ? deserializeAws_json1_1CsvClassifier(output.CsvClassifier, context) : undefined,
        GrokClassifier: output.GrokClassifier != null ? deserializeAws_json1_1GrokClassifier(output.GrokClassifier, context) : undefined,
        JsonClassifier: output.JsonClassifier != null ? deserializeAws_json1_1JsonClassifier(output.JsonClassifier, context) : undefined,
        XMLClassifier: output.XMLClassifier != null ? deserializeAws_json1_1XMLClassifier(output.XMLClassifier, context) : undefined,
    };
};
const deserializeAws_json1_1ClassifierList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Classifier(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1ClassifierNameList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1CloudWatchEncryption = (output, context) => {
    return {
        CloudWatchEncryptionMode: __expectString(output.CloudWatchEncryptionMode),
        KmsKeyArn: __expectString(output.KmsKeyArn),
    };
};
const deserializeAws_json1_1CodeGenConfigurationNode = (output, context) => {
    return {
        Aggregate: output.Aggregate != null ? deserializeAws_json1_1Aggregate(output.Aggregate, context) : undefined,
        ApplyMapping: output.ApplyMapping != null ? deserializeAws_json1_1ApplyMapping(output.ApplyMapping, context) : undefined,
        AthenaConnectorSource: output.AthenaConnectorSource != null
            ? deserializeAws_json1_1AthenaConnectorSource(output.AthenaConnectorSource, context)
            : undefined,
        CatalogHudiSource: output.CatalogHudiSource != null
            ? deserializeAws_json1_1CatalogHudiSource(output.CatalogHudiSource, context)
            : undefined,
        CatalogKafkaSource: output.CatalogKafkaSource != null
            ? deserializeAws_json1_1CatalogKafkaSource(output.CatalogKafkaSource, context)
            : undefined,
        CatalogKinesisSource: output.CatalogKinesisSource != null
            ? deserializeAws_json1_1CatalogKinesisSource(output.CatalogKinesisSource, context)
            : undefined,
        CatalogSource: output.CatalogSource != null ? deserializeAws_json1_1CatalogSource(output.CatalogSource, context) : undefined,
        CatalogTarget: output.CatalogTarget != null
            ? deserializeAws_json1_1BasicCatalogTarget(output.CatalogTarget, context)
            : undefined,
        CustomCode: output.CustomCode != null ? deserializeAws_json1_1CustomCode(output.CustomCode, context) : undefined,
        DirectJDBCSource: output.DirectJDBCSource != null
            ? deserializeAws_json1_1DirectJDBCSource(output.DirectJDBCSource, context)
            : undefined,
        DirectKafkaSource: output.DirectKafkaSource != null
            ? deserializeAws_json1_1DirectKafkaSource(output.DirectKafkaSource, context)
            : undefined,
        DirectKinesisSource: output.DirectKinesisSource != null
            ? deserializeAws_json1_1DirectKinesisSource(output.DirectKinesisSource, context)
            : undefined,
        DropDuplicates: output.DropDuplicates != null ? deserializeAws_json1_1DropDuplicates(output.DropDuplicates, context) : undefined,
        DropFields: output.DropFields != null ? deserializeAws_json1_1DropFields(output.DropFields, context) : undefined,
        DropNullFields: output.DropNullFields != null ? deserializeAws_json1_1DropNullFields(output.DropNullFields, context) : undefined,
        DynamicTransform: output.DynamicTransform != null
            ? deserializeAws_json1_1DynamicTransform(output.DynamicTransform, context)
            : undefined,
        DynamoDBCatalogSource: output.DynamoDBCatalogSource != null
            ? deserializeAws_json1_1DynamoDBCatalogSource(output.DynamoDBCatalogSource, context)
            : undefined,
        EvaluateDataQuality: output.EvaluateDataQuality != null
            ? deserializeAws_json1_1EvaluateDataQuality(output.EvaluateDataQuality, context)
            : undefined,
        FillMissingValues: output.FillMissingValues != null
            ? deserializeAws_json1_1FillMissingValues(output.FillMissingValues, context)
            : undefined,
        Filter: output.Filter != null ? deserializeAws_json1_1Filter(output.Filter, context) : undefined,
        GovernedCatalogSource: output.GovernedCatalogSource != null
            ? deserializeAws_json1_1GovernedCatalogSource(output.GovernedCatalogSource, context)
            : undefined,
        GovernedCatalogTarget: output.GovernedCatalogTarget != null
            ? deserializeAws_json1_1GovernedCatalogTarget(output.GovernedCatalogTarget, context)
            : undefined,
        JDBCConnectorSource: output.JDBCConnectorSource != null
            ? deserializeAws_json1_1JDBCConnectorSource(output.JDBCConnectorSource, context)
            : undefined,
        JDBCConnectorTarget: output.JDBCConnectorTarget != null
            ? deserializeAws_json1_1JDBCConnectorTarget(output.JDBCConnectorTarget, context)
            : undefined,
        Join: output.Join != null ? deserializeAws_json1_1Join(output.Join, context) : undefined,
        Merge: output.Merge != null ? deserializeAws_json1_1Merge(output.Merge, context) : undefined,
        MicrosoftSQLServerCatalogSource: output.MicrosoftSQLServerCatalogSource != null
            ? deserializeAws_json1_1MicrosoftSQLServerCatalogSource(output.MicrosoftSQLServerCatalogSource, context)
            : undefined,
        MicrosoftSQLServerCatalogTarget: output.MicrosoftSQLServerCatalogTarget != null
            ? deserializeAws_json1_1MicrosoftSQLServerCatalogTarget(output.MicrosoftSQLServerCatalogTarget, context)
            : undefined,
        MySQLCatalogSource: output.MySQLCatalogSource != null
            ? deserializeAws_json1_1MySQLCatalogSource(output.MySQLCatalogSource, context)
            : undefined,
        MySQLCatalogTarget: output.MySQLCatalogTarget != null
            ? deserializeAws_json1_1MySQLCatalogTarget(output.MySQLCatalogTarget, context)
            : undefined,
        OracleSQLCatalogSource: output.OracleSQLCatalogSource != null
            ? deserializeAws_json1_1OracleSQLCatalogSource(output.OracleSQLCatalogSource, context)
            : undefined,
        OracleSQLCatalogTarget: output.OracleSQLCatalogTarget != null
            ? deserializeAws_json1_1OracleSQLCatalogTarget(output.OracleSQLCatalogTarget, context)
            : undefined,
        PIIDetection: output.PIIDetection != null ? deserializeAws_json1_1PIIDetection(output.PIIDetection, context) : undefined,
        PostgreSQLCatalogSource: output.PostgreSQLCatalogSource != null
            ? deserializeAws_json1_1PostgreSQLCatalogSource(output.PostgreSQLCatalogSource, context)
            : undefined,
        PostgreSQLCatalogTarget: output.PostgreSQLCatalogTarget != null
            ? deserializeAws_json1_1PostgreSQLCatalogTarget(output.PostgreSQLCatalogTarget, context)
            : undefined,
        RedshiftSource: output.RedshiftSource != null ? deserializeAws_json1_1RedshiftSource(output.RedshiftSource, context) : undefined,
        RedshiftTarget: output.RedshiftTarget != null ? deserializeAws_json1_1RedshiftTarget(output.RedshiftTarget, context) : undefined,
        RelationalCatalogSource: output.RelationalCatalogSource != null
            ? deserializeAws_json1_1RelationalCatalogSource(output.RelationalCatalogSource, context)
            : undefined,
        RenameField: output.RenameField != null ? deserializeAws_json1_1RenameField(output.RenameField, context) : undefined,
        S3CatalogHudiSource: output.S3CatalogHudiSource != null
            ? deserializeAws_json1_1S3CatalogHudiSource(output.S3CatalogHudiSource, context)
            : undefined,
        S3CatalogSource: output.S3CatalogSource != null
            ? deserializeAws_json1_1S3CatalogSource(output.S3CatalogSource, context)
            : undefined,
        S3CatalogTarget: output.S3CatalogTarget != null
            ? deserializeAws_json1_1S3CatalogTarget(output.S3CatalogTarget, context)
            : undefined,
        S3CsvSource: output.S3CsvSource != null ? deserializeAws_json1_1S3CsvSource(output.S3CsvSource, context) : undefined,
        S3DirectTarget: output.S3DirectTarget != null ? deserializeAws_json1_1S3DirectTarget(output.S3DirectTarget, context) : undefined,
        S3GlueParquetTarget: output.S3GlueParquetTarget != null
            ? deserializeAws_json1_1S3GlueParquetTarget(output.S3GlueParquetTarget, context)
            : undefined,
        S3HudiCatalogTarget: output.S3HudiCatalogTarget != null
            ? deserializeAws_json1_1S3HudiCatalogTarget(output.S3HudiCatalogTarget, context)
            : undefined,
        S3HudiDirectTarget: output.S3HudiDirectTarget != null
            ? deserializeAws_json1_1S3HudiDirectTarget(output.S3HudiDirectTarget, context)
            : undefined,
        S3HudiSource: output.S3HudiSource != null ? deserializeAws_json1_1S3HudiSource(output.S3HudiSource, context) : undefined,
        S3JsonSource: output.S3JsonSource != null ? deserializeAws_json1_1S3JsonSource(output.S3JsonSource, context) : undefined,
        S3ParquetSource: output.S3ParquetSource != null
            ? deserializeAws_json1_1S3ParquetSource(output.S3ParquetSource, context)
            : undefined,
        SelectFields: output.SelectFields != null ? deserializeAws_json1_1SelectFields(output.SelectFields, context) : undefined,
        SelectFromCollection: output.SelectFromCollection != null
            ? deserializeAws_json1_1SelectFromCollection(output.SelectFromCollection, context)
            : undefined,
        SparkConnectorSource: output.SparkConnectorSource != null
            ? deserializeAws_json1_1SparkConnectorSource(output.SparkConnectorSource, context)
            : undefined,
        SparkConnectorTarget: output.SparkConnectorTarget != null
            ? deserializeAws_json1_1SparkConnectorTarget(output.SparkConnectorTarget, context)
            : undefined,
        SparkSQL: output.SparkSQL != null ? deserializeAws_json1_1SparkSQL(output.SparkSQL, context) : undefined,
        Spigot: output.Spigot != null ? deserializeAws_json1_1Spigot(output.Spigot, context) : undefined,
        SplitFields: output.SplitFields != null ? deserializeAws_json1_1SplitFields(output.SplitFields, context) : undefined,
        Union: output.Union != null ? deserializeAws_json1_1Union(output.Union, context) : undefined,
    };
};
const deserializeAws_json1_1CodeGenConfigurationNodes = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = deserializeAws_json1_1CodeGenConfigurationNode(value, context);
        return acc;
    }, {});
};
const deserializeAws_json1_1CodeGenEdge = (output, context) => {
    return {
        Source: __expectString(output.Source),
        Target: __expectString(output.Target),
        TargetParameter: __expectString(output.TargetParameter),
    };
};
const deserializeAws_json1_1CodeGenNode = (output, context) => {
    return {
        Args: output.Args != null ? deserializeAws_json1_1CodeGenNodeArgs(output.Args, context) : undefined,
        Id: __expectString(output.Id),
        LineNumber: __expectInt32(output.LineNumber),
        NodeType: __expectString(output.NodeType),
    };
};
const deserializeAws_json1_1CodeGenNodeArg = (output, context) => {
    return {
        Name: __expectString(output.Name),
        Param: __expectBoolean(output.Param),
        Value: __expectString(output.Value),
    };
};
const deserializeAws_json1_1CodeGenNodeArgs = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1CodeGenNodeArg(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1Column = (output, context) => {
    return {
        Comment: __expectString(output.Comment),
        Name: __expectString(output.Name),
        Parameters: output.Parameters != null ? deserializeAws_json1_1ParametersMap(output.Parameters, context) : undefined,
        Type: __expectString(output.Type),
    };
};
const deserializeAws_json1_1ColumnError = (output, context) => {
    return {
        ColumnName: __expectString(output.ColumnName),
        Error: output.Error != null ? deserializeAws_json1_1ErrorDetail(output.Error, context) : undefined,
    };
};
const deserializeAws_json1_1ColumnErrors = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1ColumnError(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1ColumnImportance = (output, context) => {
    return {
        ColumnName: __expectString(output.ColumnName),
        Importance: __limitedParseDouble(output.Importance),
    };
};
const deserializeAws_json1_1ColumnImportanceList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1ColumnImportance(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1ColumnList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Column(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1ColumnRowFilter = (output, context) => {
    return {
        ColumnName: __expectString(output.ColumnName),
        RowFilterExpression: __expectString(output.RowFilterExpression),
    };
};
const deserializeAws_json1_1ColumnRowFilterList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1ColumnRowFilter(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1ColumnStatistics = (output, context) => {
    return {
        AnalyzedTime: output.AnalyzedTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.AnalyzedTime)))
            : undefined,
        ColumnName: __expectString(output.ColumnName),
        ColumnType: __expectString(output.ColumnType),
        StatisticsData: output.StatisticsData != null
            ? deserializeAws_json1_1ColumnStatisticsData(output.StatisticsData, context)
            : undefined,
    };
};
const deserializeAws_json1_1ColumnStatisticsData = (output, context) => {
    return {
        BinaryColumnStatisticsData: output.BinaryColumnStatisticsData != null
            ? deserializeAws_json1_1BinaryColumnStatisticsData(output.BinaryColumnStatisticsData, context)
            : undefined,
        BooleanColumnStatisticsData: output.BooleanColumnStatisticsData != null
            ? deserializeAws_json1_1BooleanColumnStatisticsData(output.BooleanColumnStatisticsData, context)
            : undefined,
        DateColumnStatisticsData: output.DateColumnStatisticsData != null
            ? deserializeAws_json1_1DateColumnStatisticsData(output.DateColumnStatisticsData, context)
            : undefined,
        DecimalColumnStatisticsData: output.DecimalColumnStatisticsData != null
            ? deserializeAws_json1_1DecimalColumnStatisticsData(output.DecimalColumnStatisticsData, context)
            : undefined,
        DoubleColumnStatisticsData: output.DoubleColumnStatisticsData != null
            ? deserializeAws_json1_1DoubleColumnStatisticsData(output.DoubleColumnStatisticsData, context)
            : undefined,
        LongColumnStatisticsData: output.LongColumnStatisticsData != null
            ? deserializeAws_json1_1LongColumnStatisticsData(output.LongColumnStatisticsData, context)
            : undefined,
        StringColumnStatisticsData: output.StringColumnStatisticsData != null
            ? deserializeAws_json1_1StringColumnStatisticsData(output.StringColumnStatisticsData, context)
            : undefined,
        Type: __expectString(output.Type),
    };
};
const deserializeAws_json1_1ColumnStatisticsError = (output, context) => {
    return {
        ColumnStatistics: output.ColumnStatistics != null
            ? deserializeAws_json1_1ColumnStatistics(output.ColumnStatistics, context)
            : undefined,
        Error: output.Error != null ? deserializeAws_json1_1ErrorDetail(output.Error, context) : undefined,
    };
};
const deserializeAws_json1_1ColumnStatisticsErrors = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1ColumnStatisticsError(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1ColumnStatisticsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1ColumnStatistics(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1ColumnValueStringList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1ConcurrentModificationException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_1ConcurrentRunsExceededException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_1Condition = (output, context) => {
    return {
        CrawlState: __expectString(output.CrawlState),
        CrawlerName: __expectString(output.CrawlerName),
        JobName: __expectString(output.JobName),
        LogicalOperator: __expectString(output.LogicalOperator),
        State: __expectString(output.State),
    };
};
const deserializeAws_json1_1ConditionCheckFailureException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_1ConditionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Condition(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1ConflictException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_1ConfusionMatrix = (output, context) => {
    return {
        NumFalseNegatives: __expectLong(output.NumFalseNegatives),
        NumFalsePositives: __expectLong(output.NumFalsePositives),
        NumTrueNegatives: __expectLong(output.NumTrueNegatives),
        NumTruePositives: __expectLong(output.NumTruePositives),
    };
};
const deserializeAws_json1_1Connection = (output, context) => {
    return {
        ConnectionProperties: output.ConnectionProperties != null
            ? deserializeAws_json1_1ConnectionProperties(output.ConnectionProperties, context)
            : undefined,
        ConnectionType: __expectString(output.ConnectionType),
        CreationTime: output.CreationTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreationTime)))
            : undefined,
        Description: __expectString(output.Description),
        LastUpdatedBy: __expectString(output.LastUpdatedBy),
        LastUpdatedTime: output.LastUpdatedTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastUpdatedTime)))
            : undefined,
        MatchCriteria: output.MatchCriteria != null ? deserializeAws_json1_1MatchCriteria(output.MatchCriteria, context) : undefined,
        Name: __expectString(output.Name),
        PhysicalConnectionRequirements: output.PhysicalConnectionRequirements != null
            ? deserializeAws_json1_1PhysicalConnectionRequirements(output.PhysicalConnectionRequirements, context)
            : undefined,
    };
};
const deserializeAws_json1_1ConnectionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Connection(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1ConnectionPasswordEncryption = (output, context) => {
    return {
        AwsKmsKeyId: __expectString(output.AwsKmsKeyId),
        ReturnConnectionPasswordEncrypted: __expectBoolean(output.ReturnConnectionPasswordEncrypted),
    };
};
const deserializeAws_json1_1ConnectionProperties = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = __expectString(value);
        return acc;
    }, {});
};
const deserializeAws_json1_1ConnectionsList = (output, context) => {
    return {
        Connections: output.Connections != null
            ? deserializeAws_json1_1OrchestrationStringList(output.Connections, context)
            : undefined,
    };
};
const deserializeAws_json1_1ContextWords = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1Crawl = (output, context) => {
    return {
        CompletedOn: output.CompletedOn != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CompletedOn)))
            : undefined,
        ErrorMessage: __expectString(output.ErrorMessage),
        LogGroup: __expectString(output.LogGroup),
        LogStream: __expectString(output.LogStream),
        StartedOn: output.StartedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartedOn))) : undefined,
        State: __expectString(output.State),
    };
};
const deserializeAws_json1_1Crawler = (output, context) => {
    return {
        Classifiers: output.Classifiers != null ? deserializeAws_json1_1ClassifierNameList(output.Classifiers, context) : undefined,
        Configuration: __expectString(output.Configuration),
        CrawlElapsedTime: __expectLong(output.CrawlElapsedTime),
        CrawlerSecurityConfiguration: __expectString(output.CrawlerSecurityConfiguration),
        CreationTime: output.CreationTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreationTime)))
            : undefined,
        DatabaseName: __expectString(output.DatabaseName),
        Description: __expectString(output.Description),
        LakeFormationConfiguration: output.LakeFormationConfiguration != null
            ? deserializeAws_json1_1LakeFormationConfiguration(output.LakeFormationConfiguration, context)
            : undefined,
        LastCrawl: output.LastCrawl != null ? deserializeAws_json1_1LastCrawlInfo(output.LastCrawl, context) : undefined,
        LastUpdated: output.LastUpdated != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastUpdated)))
            : undefined,
        LineageConfiguration: output.LineageConfiguration != null
            ? deserializeAws_json1_1LineageConfiguration(output.LineageConfiguration, context)
            : undefined,
        Name: __expectString(output.Name),
        RecrawlPolicy: output.RecrawlPolicy != null ? deserializeAws_json1_1RecrawlPolicy(output.RecrawlPolicy, context) : undefined,
        Role: __expectString(output.Role),
        Schedule: output.Schedule != null ? deserializeAws_json1_1Schedule(output.Schedule, context) : undefined,
        SchemaChangePolicy: output.SchemaChangePolicy != null
            ? deserializeAws_json1_1SchemaChangePolicy(output.SchemaChangePolicy, context)
            : undefined,
        State: __expectString(output.State),
        TablePrefix: __expectString(output.TablePrefix),
        Targets: output.Targets != null ? deserializeAws_json1_1CrawlerTargets(output.Targets, context) : undefined,
        Version: __expectLong(output.Version),
    };
};
const deserializeAws_json1_1CrawlerHistory = (output, context) => {
    return {
        CrawlId: __expectString(output.CrawlId),
        DPUHour: __limitedParseDouble(output.DPUHour),
        EndTime: output.EndTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.EndTime))) : undefined,
        ErrorMessage: __expectString(output.ErrorMessage),
        LogGroup: __expectString(output.LogGroup),
        LogStream: __expectString(output.LogStream),
        MessagePrefix: __expectString(output.MessagePrefix),
        StartTime: output.StartTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartTime))) : undefined,
        State: __expectString(output.State),
        Summary: __expectString(output.Summary),
    };
};
const deserializeAws_json1_1CrawlerHistoryList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1CrawlerHistory(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1CrawlerList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Crawler(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1CrawlerMetrics = (output, context) => {
    return {
        CrawlerName: __expectString(output.CrawlerName),
        LastRuntimeSeconds: __limitedParseDouble(output.LastRuntimeSeconds),
        MedianRuntimeSeconds: __limitedParseDouble(output.MedianRuntimeSeconds),
        StillEstimating: __expectBoolean(output.StillEstimating),
        TablesCreated: __expectInt32(output.TablesCreated),
        TablesDeleted: __expectInt32(output.TablesDeleted),
        TablesUpdated: __expectInt32(output.TablesUpdated),
        TimeLeftSeconds: __limitedParseDouble(output.TimeLeftSeconds),
    };
};
const deserializeAws_json1_1CrawlerMetricsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1CrawlerMetrics(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1CrawlerNameList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1CrawlerNodeDetails = (output, context) => {
    return {
        Crawls: output.Crawls != null ? deserializeAws_json1_1CrawlList(output.Crawls, context) : undefined,
    };
};
const deserializeAws_json1_1CrawlerNotRunningException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_1CrawlerRunningException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_1CrawlerStoppingException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_1CrawlerTargets = (output, context) => {
    return {
        CatalogTargets: output.CatalogTargets != null
            ? deserializeAws_json1_1CatalogTargetList(output.CatalogTargets, context)
            : undefined,
        DeltaTargets: output.DeltaTargets != null ? deserializeAws_json1_1DeltaTargetList(output.DeltaTargets, context) : undefined,
        DynamoDBTargets: output.DynamoDBTargets != null
            ? deserializeAws_json1_1DynamoDBTargetList(output.DynamoDBTargets, context)
            : undefined,
        JdbcTargets: output.JdbcTargets != null ? deserializeAws_json1_1JdbcTargetList(output.JdbcTargets, context) : undefined,
        MongoDBTargets: output.MongoDBTargets != null
            ? deserializeAws_json1_1MongoDBTargetList(output.MongoDBTargets, context)
            : undefined,
        S3Targets: output.S3Targets != null ? deserializeAws_json1_1S3TargetList(output.S3Targets, context) : undefined,
    };
};
const deserializeAws_json1_1CrawlList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Crawl(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1CreateBlueprintResponse = (output, context) => {
    return {
        Name: __expectString(output.Name),
    };
};
const deserializeAws_json1_1CreateClassifierResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1CreateConnectionResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1CreateCrawlerResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1CreateCustomEntityTypeResponse = (output, context) => {
    return {
        Name: __expectString(output.Name),
    };
};
const deserializeAws_json1_1CreateDatabaseResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1CreateDataQualityRulesetResponse = (output, context) => {
    return {
        Name: __expectString(output.Name),
    };
};
const deserializeAws_json1_1CreateDevEndpointResponse = (output, context) => {
    return {
        Arguments: output.Arguments != null ? deserializeAws_json1_1MapValue(output.Arguments, context) : undefined,
        AvailabilityZone: __expectString(output.AvailabilityZone),
        CreatedTimestamp: output.CreatedTimestamp != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedTimestamp)))
            : undefined,
        EndpointName: __expectString(output.EndpointName),
        ExtraJarsS3Path: __expectString(output.ExtraJarsS3Path),
        ExtraPythonLibsS3Path: __expectString(output.ExtraPythonLibsS3Path),
        FailureReason: __expectString(output.FailureReason),
        GlueVersion: __expectString(output.GlueVersion),
        NumberOfNodes: __expectInt32(output.NumberOfNodes),
        NumberOfWorkers: __expectInt32(output.NumberOfWorkers),
        RoleArn: __expectString(output.RoleArn),
        SecurityConfiguration: __expectString(output.SecurityConfiguration),
        SecurityGroupIds: output.SecurityGroupIds != null ? deserializeAws_json1_1StringList(output.SecurityGroupIds, context) : undefined,
        Status: __expectString(output.Status),
        SubnetId: __expectString(output.SubnetId),
        VpcId: __expectString(output.VpcId),
        WorkerType: __expectString(output.WorkerType),
        YarnEndpointAddress: __expectString(output.YarnEndpointAddress),
        ZeppelinRemoteSparkInterpreterPort: __expectInt32(output.ZeppelinRemoteSparkInterpreterPort),
    };
};
const deserializeAws_json1_1CreateJobResponse = (output, context) => {
    return {
        Name: __expectString(output.Name),
    };
};
const deserializeAws_json1_1CreateMLTransformResponse = (output, context) => {
    return {
        TransformId: __expectString(output.TransformId),
    };
};
const deserializeAws_json1_1CreatePartitionIndexResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1CreatePartitionResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1CreateRegistryResponse = (output, context) => {
    return {
        Description: __expectString(output.Description),
        RegistryArn: __expectString(output.RegistryArn),
        RegistryName: __expectString(output.RegistryName),
        Tags: output.Tags != null ? deserializeAws_json1_1TagsMap(output.Tags, context) : undefined,
    };
};
const deserializeAws_json1_1CreateSchemaResponse = (output, context) => {
    return {
        Compatibility: __expectString(output.Compatibility),
        DataFormat: __expectString(output.DataFormat),
        Description: __expectString(output.Description),
        LatestSchemaVersion: __expectLong(output.LatestSchemaVersion),
        NextSchemaVersion: __expectLong(output.NextSchemaVersion),
        RegistryArn: __expectString(output.RegistryArn),
        RegistryName: __expectString(output.RegistryName),
        SchemaArn: __expectString(output.SchemaArn),
        SchemaCheckpoint: __expectLong(output.SchemaCheckpoint),
        SchemaName: __expectString(output.SchemaName),
        SchemaStatus: __expectString(output.SchemaStatus),
        SchemaVersionId: __expectString(output.SchemaVersionId),
        SchemaVersionStatus: __expectString(output.SchemaVersionStatus),
        Tags: output.Tags != null ? deserializeAws_json1_1TagsMap(output.Tags, context) : undefined,
    };
};
const deserializeAws_json1_1CreateScriptResponse = (output, context) => {
    return {
        PythonScript: __expectString(output.PythonScript),
        ScalaCode: __expectString(output.ScalaCode),
    };
};
const deserializeAws_json1_1CreateSecurityConfigurationResponse = (output, context) => {
    return {
        CreatedTimestamp: output.CreatedTimestamp != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedTimestamp)))
            : undefined,
        Name: __expectString(output.Name),
    };
};
const deserializeAws_json1_1CreateSessionResponse = (output, context) => {
    return {
        Session: output.Session != null ? deserializeAws_json1_1Session(output.Session, context) : undefined,
    };
};
const deserializeAws_json1_1CreateTableResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1CreateTriggerResponse = (output, context) => {
    return {
        Name: __expectString(output.Name),
    };
};
const deserializeAws_json1_1CreateUserDefinedFunctionResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1CreateWorkflowResponse = (output, context) => {
    return {
        Name: __expectString(output.Name),
    };
};
const deserializeAws_json1_1CsvClassifier = (output, context) => {
    return {
        AllowSingleColumn: __expectBoolean(output.AllowSingleColumn),
        ContainsHeader: __expectString(output.ContainsHeader),
        CreationTime: output.CreationTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreationTime)))
            : undefined,
        CustomDatatypeConfigured: __expectBoolean(output.CustomDatatypeConfigured),
        CustomDatatypes: output.CustomDatatypes != null
            ? deserializeAws_json1_1CustomDatatypes(output.CustomDatatypes, context)
            : undefined,
        Delimiter: __expectString(output.Delimiter),
        DisableValueTrimming: __expectBoolean(output.DisableValueTrimming),
        Header: output.Header != null ? deserializeAws_json1_1CsvHeader(output.Header, context) : undefined,
        LastUpdated: output.LastUpdated != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastUpdated)))
            : undefined,
        Name: __expectString(output.Name),
        QuoteSymbol: __expectString(output.QuoteSymbol),
        Version: __expectLong(output.Version),
    };
};
const deserializeAws_json1_1CsvHeader = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1CustomCode = (output, context) => {
    return {
        ClassName: __expectString(output.ClassName),
        Code: __expectString(output.Code),
        Inputs: output.Inputs != null ? deserializeAws_json1_1ManyInputs(output.Inputs, context) : undefined,
        Name: __expectString(output.Name),
        OutputSchemas: output.OutputSchemas != null ? deserializeAws_json1_1GlueSchemas(output.OutputSchemas, context) : undefined,
    };
};
const deserializeAws_json1_1CustomDatatypes = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1CustomEntityType = (output, context) => {
    return {
        ContextWords: output.ContextWords != null ? deserializeAws_json1_1ContextWords(output.ContextWords, context) : undefined,
        Name: __expectString(output.Name),
        RegexString: __expectString(output.RegexString),
    };
};
const deserializeAws_json1_1CustomEntityTypeNames = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1CustomEntityTypes = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1CustomEntityType(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1DagEdges = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1CodeGenEdge(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1DagNodes = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1CodeGenNode(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1Database = (output, context) => {
    return {
        CatalogId: __expectString(output.CatalogId),
        CreateTableDefaultPermissions: output.CreateTableDefaultPermissions != null
            ? deserializeAws_json1_1PrincipalPermissionsList(output.CreateTableDefaultPermissions, context)
            : undefined,
        CreateTime: output.CreateTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreateTime))) : undefined,
        Description: __expectString(output.Description),
        LocationUri: __expectString(output.LocationUri),
        Name: __expectString(output.Name),
        Parameters: output.Parameters != null ? deserializeAws_json1_1ParametersMap(output.Parameters, context) : undefined,
        TargetDatabase: output.TargetDatabase != null
            ? deserializeAws_json1_1DatabaseIdentifier(output.TargetDatabase, context)
            : undefined,
    };
};
const deserializeAws_json1_1DatabaseIdentifier = (output, context) => {
    return {
        CatalogId: __expectString(output.CatalogId),
        DatabaseName: __expectString(output.DatabaseName),
    };
};
const deserializeAws_json1_1DatabaseList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Database(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1DataCatalogEncryptionSettings = (output, context) => {
    return {
        ConnectionPasswordEncryption: output.ConnectionPasswordEncryption != null
            ? deserializeAws_json1_1ConnectionPasswordEncryption(output.ConnectionPasswordEncryption, context)
            : undefined,
        EncryptionAtRest: output.EncryptionAtRest != null
            ? deserializeAws_json1_1EncryptionAtRest(output.EncryptionAtRest, context)
            : undefined,
    };
};
const deserializeAws_json1_1DataLakePrincipal = (output, context) => {
    return {
        DataLakePrincipalIdentifier: __expectString(output.DataLakePrincipalIdentifier),
    };
};
const deserializeAws_json1_1DataQualityEvaluationRunAdditionalRunOptions = (output, context) => {
    return {
        CloudWatchMetricsEnabled: __expectBoolean(output.CloudWatchMetricsEnabled),
        ResultsS3Prefix: __expectString(output.ResultsS3Prefix),
    };
};
const deserializeAws_json1_1DataQualityResult = (output, context) => {
    return {
        CompletedOn: output.CompletedOn != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CompletedOn)))
            : undefined,
        DataSource: output.DataSource != null ? deserializeAws_json1_1DataSource(output.DataSource, context) : undefined,
        EvaluationContext: __expectString(output.EvaluationContext),
        JobName: __expectString(output.JobName),
        JobRunId: __expectString(output.JobRunId),
        ResultId: __expectString(output.ResultId),
        RuleResults: output.RuleResults != null
            ? deserializeAws_json1_1DataQualityRuleResults(output.RuleResults, context)
            : undefined,
        RulesetEvaluationRunId: __expectString(output.RulesetEvaluationRunId),
        RulesetName: __expectString(output.RulesetName),
        Score: __limitedParseDouble(output.Score),
        StartedOn: output.StartedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartedOn))) : undefined,
    };
};
const deserializeAws_json1_1DataQualityResultDescription = (output, context) => {
    return {
        DataSource: output.DataSource != null ? deserializeAws_json1_1DataSource(output.DataSource, context) : undefined,
        JobName: __expectString(output.JobName),
        JobRunId: __expectString(output.JobRunId),
        ResultId: __expectString(output.ResultId),
        StartedOn: output.StartedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartedOn))) : undefined,
    };
};
const deserializeAws_json1_1DataQualityResultDescriptionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1DataQualityResultDescription(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1DataQualityResultIdList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1DataQualityResultIds = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1DataQualityResultsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1DataQualityResult(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1DataQualityRuleRecommendationRunDescription = (output, context) => {
    return {
        DataSource: output.DataSource != null ? deserializeAws_json1_1DataSource(output.DataSource, context) : undefined,
        RunId: __expectString(output.RunId),
        StartedOn: output.StartedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartedOn))) : undefined,
        Status: __expectString(output.Status),
    };
};
const deserializeAws_json1_1DataQualityRuleRecommendationRunList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1DataQualityRuleRecommendationRunDescription(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1DataQualityRuleResult = (output, context) => {
    return {
        Description: __expectString(output.Description),
        EvaluationMessage: __expectString(output.EvaluationMessage),
        Name: __expectString(output.Name),
        Result: __expectString(output.Result),
    };
};
const deserializeAws_json1_1DataQualityRuleResults = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1DataQualityRuleResult(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1DataQualityRulesetEvaluationRunDescription = (output, context) => {
    return {
        DataSource: output.DataSource != null ? deserializeAws_json1_1DataSource(output.DataSource, context) : undefined,
        RunId: __expectString(output.RunId),
        StartedOn: output.StartedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartedOn))) : undefined,
        Status: __expectString(output.Status),
    };
};
const deserializeAws_json1_1DataQualityRulesetEvaluationRunList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1DataQualityRulesetEvaluationRunDescription(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1DataQualityRulesetList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1DataQualityRulesetListDetails(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1DataQualityRulesetListDetails = (output, context) => {
    return {
        CreatedOn: output.CreatedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedOn))) : undefined,
        Description: __expectString(output.Description),
        LastModifiedOn: output.LastModifiedOn != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedOn)))
            : undefined,
        Name: __expectString(output.Name),
        RecommendationRunId: __expectString(output.RecommendationRunId),
        RuleCount: __expectInt32(output.RuleCount),
        TargetTable: output.TargetTable != null
            ? deserializeAws_json1_1DataQualityTargetTable(output.TargetTable, context)
            : undefined,
    };
};
const deserializeAws_json1_1DataQualityTargetTable = (output, context) => {
    return {
        DatabaseName: __expectString(output.DatabaseName),
        TableName: __expectString(output.TableName),
    };
};
const deserializeAws_json1_1DataSource = (output, context) => {
    return {
        GlueTable: output.GlueTable != null ? deserializeAws_json1_1GlueTable(output.GlueTable, context) : undefined,
    };
};
const deserializeAws_json1_1Datatype = (output, context) => {
    return {
        Id: __expectString(output.Id),
        Label: __expectString(output.Label),
    };
};
const deserializeAws_json1_1DateColumnStatisticsData = (output, context) => {
    return {
        MaximumValue: output.MaximumValue != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.MaximumValue)))
            : undefined,
        MinimumValue: output.MinimumValue != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.MinimumValue)))
            : undefined,
        NumberOfDistinctValues: __expectLong(output.NumberOfDistinctValues),
        NumberOfNulls: __expectLong(output.NumberOfNulls),
    };
};
const deserializeAws_json1_1DecimalColumnStatisticsData = (output, context) => {
    return {
        MaximumValue: output.MaximumValue != null ? deserializeAws_json1_1DecimalNumber(output.MaximumValue, context) : undefined,
        MinimumValue: output.MinimumValue != null ? deserializeAws_json1_1DecimalNumber(output.MinimumValue, context) : undefined,
        NumberOfDistinctValues: __expectLong(output.NumberOfDistinctValues),
        NumberOfNulls: __expectLong(output.NumberOfNulls),
    };
};
const deserializeAws_json1_1DecimalNumber = (output, context) => {
    return {
        Scale: __expectInt32(output.Scale),
        UnscaledValue: output.UnscaledValue != null ? context.base64Decoder(output.UnscaledValue) : undefined,
    };
};
const deserializeAws_json1_1DeleteBlueprintResponse = (output, context) => {
    return {
        Name: __expectString(output.Name),
    };
};
const deserializeAws_json1_1DeleteClassifierResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1DeleteColumnStatisticsForPartitionResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1DeleteColumnStatisticsForTableResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1DeleteConnectionResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1DeleteCrawlerResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1DeleteCustomEntityTypeResponse = (output, context) => {
    return {
        Name: __expectString(output.Name),
    };
};
const deserializeAws_json1_1DeleteDatabaseResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1DeleteDataQualityRulesetResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1DeleteDevEndpointResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1DeleteJobResponse = (output, context) => {
    return {
        JobName: __expectString(output.JobName),
    };
};
const deserializeAws_json1_1DeleteMLTransformResponse = (output, context) => {
    return {
        TransformId: __expectString(output.TransformId),
    };
};
const deserializeAws_json1_1DeletePartitionIndexResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1DeletePartitionResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1DeleteRegistryResponse = (output, context) => {
    return {
        RegistryArn: __expectString(output.RegistryArn),
        RegistryName: __expectString(output.RegistryName),
        Status: __expectString(output.Status),
    };
};
const deserializeAws_json1_1DeleteResourcePolicyResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1DeleteSchemaResponse = (output, context) => {
    return {
        SchemaArn: __expectString(output.SchemaArn),
        SchemaName: __expectString(output.SchemaName),
        Status: __expectString(output.Status),
    };
};
const deserializeAws_json1_1DeleteSchemaVersionsResponse = (output, context) => {
    return {
        SchemaVersionErrors: output.SchemaVersionErrors != null
            ? deserializeAws_json1_1SchemaVersionErrorList(output.SchemaVersionErrors, context)
            : undefined,
    };
};
const deserializeAws_json1_1DeleteSecurityConfigurationResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1DeleteSessionResponse = (output, context) => {
    return {
        Id: __expectString(output.Id),
    };
};
const deserializeAws_json1_1DeleteTableResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1DeleteTableVersionResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1DeleteTriggerResponse = (output, context) => {
    return {
        Name: __expectString(output.Name),
    };
};
const deserializeAws_json1_1DeleteUserDefinedFunctionResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1DeleteWorkflowResponse = (output, context) => {
    return {
        Name: __expectString(output.Name),
    };
};
const deserializeAws_json1_1DeltaTarget = (output, context) => {
    return {
        ConnectionName: __expectString(output.ConnectionName),
        CreateNativeDeltaTable: __expectBoolean(output.CreateNativeDeltaTable),
        DeltaTables: output.DeltaTables != null ? deserializeAws_json1_1PathList(output.DeltaTables, context) : undefined,
        WriteManifest: __expectBoolean(output.WriteManifest),
    };
};
const deserializeAws_json1_1DeltaTargetList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1DeltaTarget(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1DevEndpoint = (output, context) => {
    return {
        Arguments: output.Arguments != null ? deserializeAws_json1_1MapValue(output.Arguments, context) : undefined,
        AvailabilityZone: __expectString(output.AvailabilityZone),
        CreatedTimestamp: output.CreatedTimestamp != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedTimestamp)))
            : undefined,
        EndpointName: __expectString(output.EndpointName),
        ExtraJarsS3Path: __expectString(output.ExtraJarsS3Path),
        ExtraPythonLibsS3Path: __expectString(output.ExtraPythonLibsS3Path),
        FailureReason: __expectString(output.FailureReason),
        GlueVersion: __expectString(output.GlueVersion),
        LastModifiedTimestamp: output.LastModifiedTimestamp != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedTimestamp)))
            : undefined,
        LastUpdateStatus: __expectString(output.LastUpdateStatus),
        NumberOfNodes: __expectInt32(output.NumberOfNodes),
        NumberOfWorkers: __expectInt32(output.NumberOfWorkers),
        PrivateAddress: __expectString(output.PrivateAddress),
        PublicAddress: __expectString(output.PublicAddress),
        PublicKey: __expectString(output.PublicKey),
        PublicKeys: output.PublicKeys != null ? deserializeAws_json1_1PublicKeysList(output.PublicKeys, context) : undefined,
        RoleArn: __expectString(output.RoleArn),
        SecurityConfiguration: __expectString(output.SecurityConfiguration),
        SecurityGroupIds: output.SecurityGroupIds != null ? deserializeAws_json1_1StringList(output.SecurityGroupIds, context) : undefined,
        Status: __expectString(output.Status),
        SubnetId: __expectString(output.SubnetId),
        VpcId: __expectString(output.VpcId),
        WorkerType: __expectString(output.WorkerType),
        YarnEndpointAddress: __expectString(output.YarnEndpointAddress),
        ZeppelinRemoteSparkInterpreterPort: __expectInt32(output.ZeppelinRemoteSparkInterpreterPort),
    };
};
const deserializeAws_json1_1DevEndpointList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1DevEndpoint(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1DevEndpointNameList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1DevEndpointNames = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1DirectJDBCSource = (output, context) => {
    return {
        ConnectionName: __expectString(output.ConnectionName),
        ConnectionType: __expectString(output.ConnectionType),
        Database: __expectString(output.Database),
        Name: __expectString(output.Name),
        RedshiftTmpDir: __expectString(output.RedshiftTmpDir),
        Table: __expectString(output.Table),
    };
};
const deserializeAws_json1_1DirectKafkaSource = (output, context) => {
    return {
        DataPreviewOptions: output.DataPreviewOptions != null
            ? deserializeAws_json1_1StreamingDataPreviewOptions(output.DataPreviewOptions, context)
            : undefined,
        DetectSchema: __expectBoolean(output.DetectSchema),
        Name: __expectString(output.Name),
        StreamingOptions: output.StreamingOptions != null
            ? deserializeAws_json1_1KafkaStreamingSourceOptions(output.StreamingOptions, context)
            : undefined,
        WindowSize: __expectInt32(output.WindowSize),
    };
};
const deserializeAws_json1_1DirectKinesisSource = (output, context) => {
    return {
        DataPreviewOptions: output.DataPreviewOptions != null
            ? deserializeAws_json1_1StreamingDataPreviewOptions(output.DataPreviewOptions, context)
            : undefined,
        DetectSchema: __expectBoolean(output.DetectSchema),
        Name: __expectString(output.Name),
        StreamingOptions: output.StreamingOptions != null
            ? deserializeAws_json1_1KinesisStreamingSourceOptions(output.StreamingOptions, context)
            : undefined,
        WindowSize: __expectInt32(output.WindowSize),
    };
};
const deserializeAws_json1_1DirectSchemaChangePolicy = (output, context) => {
    return {
        Database: __expectString(output.Database),
        EnableUpdateCatalog: __expectBoolean(output.EnableUpdateCatalog),
        Table: __expectString(output.Table),
        UpdateBehavior: __expectString(output.UpdateBehavior),
    };
};
const deserializeAws_json1_1DoubleColumnStatisticsData = (output, context) => {
    return {
        MaximumValue: __limitedParseDouble(output.MaximumValue),
        MinimumValue: __limitedParseDouble(output.MinimumValue),
        NumberOfDistinctValues: __expectLong(output.NumberOfDistinctValues),
        NumberOfNulls: __expectLong(output.NumberOfNulls),
    };
};
const deserializeAws_json1_1DQResultsPublishingOptions = (output, context) => {
    return {
        CloudWatchMetricsEnabled: __expectBoolean(output.CloudWatchMetricsEnabled),
        EvaluationContext: __expectString(output.EvaluationContext),
        ResultsPublishingEnabled: __expectBoolean(output.ResultsPublishingEnabled),
        ResultsS3Prefix: __expectString(output.ResultsS3Prefix),
    };
};
const deserializeAws_json1_1DQStopJobOnFailureOptions = (output, context) => {
    return {
        StopJobOnFailureTiming: __expectString(output.StopJobOnFailureTiming),
    };
};
const deserializeAws_json1_1DropDuplicates = (output, context) => {
    return {
        Columns: output.Columns != null ? deserializeAws_json1_1LimitedPathList(output.Columns, context) : undefined,
        Inputs: output.Inputs != null ? deserializeAws_json1_1OneInput(output.Inputs, context) : undefined,
        Name: __expectString(output.Name),
    };
};
const deserializeAws_json1_1DropFields = (output, context) => {
    return {
        Inputs: output.Inputs != null ? deserializeAws_json1_1OneInput(output.Inputs, context) : undefined,
        Name: __expectString(output.Name),
        Paths: output.Paths != null ? deserializeAws_json1_1GlueStudioPathList(output.Paths, context) : undefined,
    };
};
const deserializeAws_json1_1DropNullFields = (output, context) => {
    return {
        Inputs: output.Inputs != null ? deserializeAws_json1_1OneInput(output.Inputs, context) : undefined,
        Name: __expectString(output.Name),
        NullCheckBoxList: output.NullCheckBoxList != null
            ? deserializeAws_json1_1NullCheckBoxList(output.NullCheckBoxList, context)
            : undefined,
        NullTextList: output.NullTextList != null ? deserializeAws_json1_1NullValueFields(output.NullTextList, context) : undefined,
    };
};
const deserializeAws_json1_1DynamicTransform = (output, context) => {
    return {
        FunctionName: __expectString(output.FunctionName),
        Inputs: output.Inputs != null ? deserializeAws_json1_1OneInput(output.Inputs, context) : undefined,
        Name: __expectString(output.Name),
        Parameters: output.Parameters != null
            ? deserializeAws_json1_1TransformConfigParameterList(output.Parameters, context)
            : undefined,
        Path: __expectString(output.Path),
        TransformName: __expectString(output.TransformName),
        Version: __expectString(output.Version),
    };
};
const deserializeAws_json1_1DynamoDBCatalogSource = (output, context) => {
    return {
        Database: __expectString(output.Database),
        Name: __expectString(output.Name),
        Table: __expectString(output.Table),
    };
};
const deserializeAws_json1_1DynamoDBTarget = (output, context) => {
    return {
        Path: __expectString(output.Path),
        scanAll: __expectBoolean(output.scanAll),
        scanRate: __limitedParseDouble(output.scanRate),
    };
};
const deserializeAws_json1_1DynamoDBTargetList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1DynamoDBTarget(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1Edge = (output, context) => {
    return {
        DestinationId: __expectString(output.DestinationId),
        SourceId: __expectString(output.SourceId),
    };
};
const deserializeAws_json1_1EdgeList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Edge(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1EnableAdditionalMetadata = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1EnclosedInStringProperties = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1EnclosedInStringPropertiesMinOne = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1EncryptionAtRest = (output, context) => {
    return {
        CatalogEncryptionMode: __expectString(output.CatalogEncryptionMode),
        SseAwsKmsKeyId: __expectString(output.SseAwsKmsKeyId),
    };
};
const deserializeAws_json1_1EncryptionConfiguration = (output, context) => {
    return {
        CloudWatchEncryption: output.CloudWatchEncryption != null
            ? deserializeAws_json1_1CloudWatchEncryption(output.CloudWatchEncryption, context)
            : undefined,
        JobBookmarksEncryption: output.JobBookmarksEncryption != null
            ? deserializeAws_json1_1JobBookmarksEncryption(output.JobBookmarksEncryption, context)
            : undefined,
        S3Encryption: output.S3Encryption != null ? deserializeAws_json1_1S3EncryptionList(output.S3Encryption, context) : undefined,
    };
};
const deserializeAws_json1_1EntityNotFoundException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_1ErrorByName = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = deserializeAws_json1_1ErrorDetail(value, context);
        return acc;
    }, {});
};
const deserializeAws_json1_1ErrorDetail = (output, context) => {
    return {
        ErrorCode: __expectString(output.ErrorCode),
        ErrorMessage: __expectString(output.ErrorMessage),
    };
};
const deserializeAws_json1_1ErrorDetails = (output, context) => {
    return {
        ErrorCode: __expectString(output.ErrorCode),
        ErrorMessage: __expectString(output.ErrorMessage),
    };
};
const deserializeAws_json1_1EvaluateDataQuality = (output, context) => {
    return {
        Inputs: output.Inputs != null ? deserializeAws_json1_1OneInput(output.Inputs, context) : undefined,
        Name: __expectString(output.Name),
        Output: __expectString(output.Output),
        PublishingOptions: output.PublishingOptions != null
            ? deserializeAws_json1_1DQResultsPublishingOptions(output.PublishingOptions, context)
            : undefined,
        Ruleset: __expectString(output.Ruleset),
        StopJobOnFailureOptions: output.StopJobOnFailureOptions != null
            ? deserializeAws_json1_1DQStopJobOnFailureOptions(output.StopJobOnFailureOptions, context)
            : undefined,
    };
};
const deserializeAws_json1_1EvaluationMetrics = (output, context) => {
    return {
        FindMatchesMetrics: output.FindMatchesMetrics != null
            ? deserializeAws_json1_1FindMatchesMetrics(output.FindMatchesMetrics, context)
            : undefined,
        TransformType: __expectString(output.TransformType),
    };
};
const deserializeAws_json1_1EventBatchingCondition = (output, context) => {
    return {
        BatchSize: __expectInt32(output.BatchSize),
        BatchWindow: __expectInt32(output.BatchWindow),
    };
};
const deserializeAws_json1_1ExecutionProperty = (output, context) => {
    return {
        MaxConcurrentRuns: __expectInt32(output.MaxConcurrentRuns),
    };
};
const deserializeAws_json1_1ExportLabelsTaskRunProperties = (output, context) => {
    return {
        OutputS3Path: __expectString(output.OutputS3Path),
    };
};
const deserializeAws_json1_1FillMissingValues = (output, context) => {
    return {
        FilledPath: __expectString(output.FilledPath),
        ImputedPath: __expectString(output.ImputedPath),
        Inputs: output.Inputs != null ? deserializeAws_json1_1OneInput(output.Inputs, context) : undefined,
        Name: __expectString(output.Name),
    };
};
const deserializeAws_json1_1Filter = (output, context) => {
    return {
        Filters: output.Filters != null ? deserializeAws_json1_1FilterExpressions(output.Filters, context) : undefined,
        Inputs: output.Inputs != null ? deserializeAws_json1_1OneInput(output.Inputs, context) : undefined,
        LogicalOperator: __expectString(output.LogicalOperator),
        Name: __expectString(output.Name),
    };
};
const deserializeAws_json1_1FilterExpression = (output, context) => {
    return {
        Negated: __expectBoolean(output.Negated),
        Operation: __expectString(output.Operation),
        Values: output.Values != null ? deserializeAws_json1_1FilterValues(output.Values, context) : undefined,
    };
};
const deserializeAws_json1_1FilterExpressions = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1FilterExpression(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1FilterValue = (output, context) => {
    return {
        Type: __expectString(output.Type),
        Value: output.Value != null ? deserializeAws_json1_1EnclosedInStringProperties(output.Value, context) : undefined,
    };
};
const deserializeAws_json1_1FilterValues = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1FilterValue(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1FindMatchesMetrics = (output, context) => {
    return {
        AreaUnderPRCurve: __limitedParseDouble(output.AreaUnderPRCurve),
        ColumnImportances: output.ColumnImportances != null
            ? deserializeAws_json1_1ColumnImportanceList(output.ColumnImportances, context)
            : undefined,
        ConfusionMatrix: output.ConfusionMatrix != null
            ? deserializeAws_json1_1ConfusionMatrix(output.ConfusionMatrix, context)
            : undefined,
        F1: __limitedParseDouble(output.F1),
        Precision: __limitedParseDouble(output.Precision),
        Recall: __limitedParseDouble(output.Recall),
    };
};
const deserializeAws_json1_1FindMatchesParameters = (output, context) => {
    return {
        AccuracyCostTradeoff: __limitedParseDouble(output.AccuracyCostTradeoff),
        EnforceProvidedLabels: __expectBoolean(output.EnforceProvidedLabels),
        PrecisionRecallTradeoff: __limitedParseDouble(output.PrecisionRecallTradeoff),
        PrimaryKeyColumnName: __expectString(output.PrimaryKeyColumnName),
    };
};
const deserializeAws_json1_1FindMatchesTaskRunProperties = (output, context) => {
    return {
        JobId: __expectString(output.JobId),
        JobName: __expectString(output.JobName),
        JobRunId: __expectString(output.JobRunId),
    };
};
const deserializeAws_json1_1GenericMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = __expectString(value);
        return acc;
    }, {});
};
const deserializeAws_json1_1GetBlueprintResponse = (output, context) => {
    return {
        Blueprint: output.Blueprint != null ? deserializeAws_json1_1Blueprint(output.Blueprint, context) : undefined,
    };
};
const deserializeAws_json1_1GetBlueprintRunResponse = (output, context) => {
    return {
        BlueprintRun: output.BlueprintRun != null ? deserializeAws_json1_1BlueprintRun(output.BlueprintRun, context) : undefined,
    };
};
const deserializeAws_json1_1GetBlueprintRunsResponse = (output, context) => {
    return {
        BlueprintRuns: output.BlueprintRuns != null ? deserializeAws_json1_1BlueprintRuns(output.BlueprintRuns, context) : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const deserializeAws_json1_1GetCatalogImportStatusResponse = (output, context) => {
    return {
        ImportStatus: output.ImportStatus != null ? deserializeAws_json1_1CatalogImportStatus(output.ImportStatus, context) : undefined,
    };
};
const deserializeAws_json1_1GetClassifierResponse = (output, context) => {
    return {
        Classifier: output.Classifier != null ? deserializeAws_json1_1Classifier(output.Classifier, context) : undefined,
    };
};
const deserializeAws_json1_1GetClassifiersResponse = (output, context) => {
    return {
        Classifiers: output.Classifiers != null ? deserializeAws_json1_1ClassifierList(output.Classifiers, context) : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const deserializeAws_json1_1GetColumnStatisticsForPartitionResponse = (output, context) => {
    return {
        ColumnStatisticsList: output.ColumnStatisticsList != null
            ? deserializeAws_json1_1ColumnStatisticsList(output.ColumnStatisticsList, context)
            : undefined,
        Errors: output.Errors != null ? deserializeAws_json1_1ColumnErrors(output.Errors, context) : undefined,
    };
};
const deserializeAws_json1_1GetColumnStatisticsForTableResponse = (output, context) => {
    return {
        ColumnStatisticsList: output.ColumnStatisticsList != null
            ? deserializeAws_json1_1ColumnStatisticsList(output.ColumnStatisticsList, context)
            : undefined,
        Errors: output.Errors != null ? deserializeAws_json1_1ColumnErrors(output.Errors, context) : undefined,
    };
};
const deserializeAws_json1_1GetConnectionResponse = (output, context) => {
    return {
        Connection: output.Connection != null ? deserializeAws_json1_1Connection(output.Connection, context) : undefined,
    };
};
const deserializeAws_json1_1GetConnectionsResponse = (output, context) => {
    return {
        ConnectionList: output.ConnectionList != null ? deserializeAws_json1_1ConnectionList(output.ConnectionList, context) : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const deserializeAws_json1_1GetCrawlerMetricsResponse = (output, context) => {
    return {
        CrawlerMetricsList: output.CrawlerMetricsList != null
            ? deserializeAws_json1_1CrawlerMetricsList(output.CrawlerMetricsList, context)
            : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const deserializeAws_json1_1GetCrawlerResponse = (output, context) => {
    return {
        Crawler: output.Crawler != null ? deserializeAws_json1_1Crawler(output.Crawler, context) : undefined,
    };
};
const deserializeAws_json1_1GetCrawlersResponse = (output, context) => {
    return {
        Crawlers: output.Crawlers != null ? deserializeAws_json1_1CrawlerList(output.Crawlers, context) : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const deserializeAws_json1_1GetCustomEntityTypeResponse = (output, context) => {
    return {
        ContextWords: output.ContextWords != null ? deserializeAws_json1_1ContextWords(output.ContextWords, context) : undefined,
        Name: __expectString(output.Name),
        RegexString: __expectString(output.RegexString),
    };
};
const deserializeAws_json1_1GetDatabaseResponse = (output, context) => {
    return {
        Database: output.Database != null ? deserializeAws_json1_1Database(output.Database, context) : undefined,
    };
};
const deserializeAws_json1_1GetDatabasesResponse = (output, context) => {
    return {
        DatabaseList: output.DatabaseList != null ? deserializeAws_json1_1DatabaseList(output.DatabaseList, context) : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const deserializeAws_json1_1GetDataCatalogEncryptionSettingsResponse = (output, context) => {
    return {
        DataCatalogEncryptionSettings: output.DataCatalogEncryptionSettings != null
            ? deserializeAws_json1_1DataCatalogEncryptionSettings(output.DataCatalogEncryptionSettings, context)
            : undefined,
    };
};
const deserializeAws_json1_1GetDataflowGraphResponse = (output, context) => {
    return {
        DagEdges: output.DagEdges != null ? deserializeAws_json1_1DagEdges(output.DagEdges, context) : undefined,
        DagNodes: output.DagNodes != null ? deserializeAws_json1_1DagNodes(output.DagNodes, context) : undefined,
    };
};
const deserializeAws_json1_1GetDataQualityResultResponse = (output, context) => {
    return {
        CompletedOn: output.CompletedOn != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CompletedOn)))
            : undefined,
        DataSource: output.DataSource != null ? deserializeAws_json1_1DataSource(output.DataSource, context) : undefined,
        EvaluationContext: __expectString(output.EvaluationContext),
        JobName: __expectString(output.JobName),
        JobRunId: __expectString(output.JobRunId),
        ResultId: __expectString(output.ResultId),
        RuleResults: output.RuleResults != null
            ? deserializeAws_json1_1DataQualityRuleResults(output.RuleResults, context)
            : undefined,
        RulesetEvaluationRunId: __expectString(output.RulesetEvaluationRunId),
        RulesetName: __expectString(output.RulesetName),
        Score: __limitedParseDouble(output.Score),
        StartedOn: output.StartedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartedOn))) : undefined,
    };
};
const deserializeAws_json1_1GetDataQualityRuleRecommendationRunResponse = (output, context) => {
    return {
        CompletedOn: output.CompletedOn != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CompletedOn)))
            : undefined,
        CreatedRulesetName: __expectString(output.CreatedRulesetName),
        DataSource: output.DataSource != null ? deserializeAws_json1_1DataSource(output.DataSource, context) : undefined,
        ErrorString: __expectString(output.ErrorString),
        ExecutionTime: __expectInt32(output.ExecutionTime),
        LastModifiedOn: output.LastModifiedOn != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedOn)))
            : undefined,
        NumberOfWorkers: __expectInt32(output.NumberOfWorkers),
        RecommendedRuleset: __expectString(output.RecommendedRuleset),
        Role: __expectString(output.Role),
        RunId: __expectString(output.RunId),
        StartedOn: output.StartedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartedOn))) : undefined,
        Status: __expectString(output.Status),
        Timeout: __expectInt32(output.Timeout),
    };
};
const deserializeAws_json1_1GetDataQualityRulesetEvaluationRunResponse = (output, context) => {
    return {
        AdditionalRunOptions: output.AdditionalRunOptions != null
            ? deserializeAws_json1_1DataQualityEvaluationRunAdditionalRunOptions(output.AdditionalRunOptions, context)
            : undefined,
        CompletedOn: output.CompletedOn != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CompletedOn)))
            : undefined,
        DataSource: output.DataSource != null ? deserializeAws_json1_1DataSource(output.DataSource, context) : undefined,
        ErrorString: __expectString(output.ErrorString),
        ExecutionTime: __expectInt32(output.ExecutionTime),
        LastModifiedOn: output.LastModifiedOn != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedOn)))
            : undefined,
        NumberOfWorkers: __expectInt32(output.NumberOfWorkers),
        ResultIds: output.ResultIds != null ? deserializeAws_json1_1DataQualityResultIdList(output.ResultIds, context) : undefined,
        Role: __expectString(output.Role),
        RulesetNames: output.RulesetNames != null ? deserializeAws_json1_1RulesetNames(output.RulesetNames, context) : undefined,
        RunId: __expectString(output.RunId),
        StartedOn: output.StartedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartedOn))) : undefined,
        Status: __expectString(output.Status),
        Timeout: __expectInt32(output.Timeout),
    };
};
const deserializeAws_json1_1GetDataQualityRulesetResponse = (output, context) => {
    return {
        CreatedOn: output.CreatedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedOn))) : undefined,
        Description: __expectString(output.Description),
        LastModifiedOn: output.LastModifiedOn != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedOn)))
            : undefined,
        Name: __expectString(output.Name),
        RecommendationRunId: __expectString(output.RecommendationRunId),
        Ruleset: __expectString(output.Ruleset),
        TargetTable: output.TargetTable != null
            ? deserializeAws_json1_1DataQualityTargetTable(output.TargetTable, context)
            : undefined,
    };
};
const deserializeAws_json1_1GetDevEndpointResponse = (output, context) => {
    return {
        DevEndpoint: output.DevEndpoint != null ? deserializeAws_json1_1DevEndpoint(output.DevEndpoint, context) : undefined,
    };
};
const deserializeAws_json1_1GetDevEndpointsResponse = (output, context) => {
    return {
        DevEndpoints: output.DevEndpoints != null ? deserializeAws_json1_1DevEndpointList(output.DevEndpoints, context) : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const deserializeAws_json1_1GetJobBookmarkResponse = (output, context) => {
    return {
        JobBookmarkEntry: output.JobBookmarkEntry != null
            ? deserializeAws_json1_1JobBookmarkEntry(output.JobBookmarkEntry, context)
            : undefined,
    };
};
const deserializeAws_json1_1GetJobResponse = (output, context) => {
    return {
        Job: output.Job != null ? deserializeAws_json1_1Job(output.Job, context) : undefined,
    };
};
const deserializeAws_json1_1GetJobRunResponse = (output, context) => {
    return {
        JobRun: output.JobRun != null ? deserializeAws_json1_1JobRun(output.JobRun, context) : undefined,
    };
};
const deserializeAws_json1_1GetJobRunsResponse = (output, context) => {
    return {
        JobRuns: output.JobRuns != null ? deserializeAws_json1_1JobRunList(output.JobRuns, context) : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const deserializeAws_json1_1GetJobsResponse = (output, context) => {
    return {
        Jobs: output.Jobs != null ? deserializeAws_json1_1JobList(output.Jobs, context) : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const deserializeAws_json1_1GetMappingResponse = (output, context) => {
    return {
        Mapping: output.Mapping != null ? deserializeAws_json1_1MappingList(output.Mapping, context) : undefined,
    };
};
const deserializeAws_json1_1GetMLTaskRunResponse = (output, context) => {
    return {
        CompletedOn: output.CompletedOn != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CompletedOn)))
            : undefined,
        ErrorString: __expectString(output.ErrorString),
        ExecutionTime: __expectInt32(output.ExecutionTime),
        LastModifiedOn: output.LastModifiedOn != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedOn)))
            : undefined,
        LogGroupName: __expectString(output.LogGroupName),
        Properties: output.Properties != null ? deserializeAws_json1_1TaskRunProperties(output.Properties, context) : undefined,
        StartedOn: output.StartedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartedOn))) : undefined,
        Status: __expectString(output.Status),
        TaskRunId: __expectString(output.TaskRunId),
        TransformId: __expectString(output.TransformId),
    };
};
const deserializeAws_json1_1GetMLTaskRunsResponse = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        TaskRuns: output.TaskRuns != null ? deserializeAws_json1_1TaskRunList(output.TaskRuns, context) : undefined,
    };
};
const deserializeAws_json1_1GetMLTransformResponse = (output, context) => {
    return {
        CreatedOn: output.CreatedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedOn))) : undefined,
        Description: __expectString(output.Description),
        EvaluationMetrics: output.EvaluationMetrics != null
            ? deserializeAws_json1_1EvaluationMetrics(output.EvaluationMetrics, context)
            : undefined,
        GlueVersion: __expectString(output.GlueVersion),
        InputRecordTables: output.InputRecordTables != null
            ? deserializeAws_json1_1GlueTables(output.InputRecordTables, context)
            : undefined,
        LabelCount: __expectInt32(output.LabelCount),
        LastModifiedOn: output.LastModifiedOn != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedOn)))
            : undefined,
        MaxCapacity: __limitedParseDouble(output.MaxCapacity),
        MaxRetries: __expectInt32(output.MaxRetries),
        Name: __expectString(output.Name),
        NumberOfWorkers: __expectInt32(output.NumberOfWorkers),
        Parameters: output.Parameters != null ? deserializeAws_json1_1TransformParameters(output.Parameters, context) : undefined,
        Role: __expectString(output.Role),
        Schema: output.Schema != null ? deserializeAws_json1_1TransformSchema(output.Schema, context) : undefined,
        Status: __expectString(output.Status),
        Timeout: __expectInt32(output.Timeout),
        TransformEncryption: output.TransformEncryption != null
            ? deserializeAws_json1_1TransformEncryption(output.TransformEncryption, context)
            : undefined,
        TransformId: __expectString(output.TransformId),
        WorkerType: __expectString(output.WorkerType),
    };
};
const deserializeAws_json1_1GetMLTransformsResponse = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        Transforms: output.Transforms != null ? deserializeAws_json1_1TransformList(output.Transforms, context) : undefined,
    };
};
const deserializeAws_json1_1GetPartitionIndexesResponse = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        PartitionIndexDescriptorList: output.PartitionIndexDescriptorList != null
            ? deserializeAws_json1_1PartitionIndexDescriptorList(output.PartitionIndexDescriptorList, context)
            : undefined,
    };
};
const deserializeAws_json1_1GetPartitionResponse = (output, context) => {
    return {
        Partition: output.Partition != null ? deserializeAws_json1_1Partition(output.Partition, context) : undefined,
    };
};
const deserializeAws_json1_1GetPartitionsResponse = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        Partitions: output.Partitions != null ? deserializeAws_json1_1PartitionList(output.Partitions, context) : undefined,
    };
};
const deserializeAws_json1_1GetPlanResponse = (output, context) => {
    return {
        PythonScript: __expectString(output.PythonScript),
        ScalaCode: __expectString(output.ScalaCode),
    };
};
const deserializeAws_json1_1GetRegistryResponse = (output, context) => {
    return {
        CreatedTime: __expectString(output.CreatedTime),
        Description: __expectString(output.Description),
        RegistryArn: __expectString(output.RegistryArn),
        RegistryName: __expectString(output.RegistryName),
        Status: __expectString(output.Status),
        UpdatedTime: __expectString(output.UpdatedTime),
    };
};
const deserializeAws_json1_1GetResourcePoliciesResponse = (output, context) => {
    return {
        GetResourcePoliciesResponseList: output.GetResourcePoliciesResponseList != null
            ? deserializeAws_json1_1GetResourcePoliciesResponseList(output.GetResourcePoliciesResponseList, context)
            : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const deserializeAws_json1_1GetResourcePoliciesResponseList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1GluePolicy(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1GetResourcePolicyResponse = (output, context) => {
    return {
        CreateTime: output.CreateTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreateTime))) : undefined,
        PolicyHash: __expectString(output.PolicyHash),
        PolicyInJson: __expectString(output.PolicyInJson),
        UpdateTime: output.UpdateTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.UpdateTime))) : undefined,
    };
};
const deserializeAws_json1_1GetSchemaByDefinitionResponse = (output, context) => {
    return {
        CreatedTime: __expectString(output.CreatedTime),
        DataFormat: __expectString(output.DataFormat),
        SchemaArn: __expectString(output.SchemaArn),
        SchemaVersionId: __expectString(output.SchemaVersionId),
        Status: __expectString(output.Status),
    };
};
const deserializeAws_json1_1GetSchemaResponse = (output, context) => {
    return {
        Compatibility: __expectString(output.Compatibility),
        CreatedTime: __expectString(output.CreatedTime),
        DataFormat: __expectString(output.DataFormat),
        Description: __expectString(output.Description),
        LatestSchemaVersion: __expectLong(output.LatestSchemaVersion),
        NextSchemaVersion: __expectLong(output.NextSchemaVersion),
        RegistryArn: __expectString(output.RegistryArn),
        RegistryName: __expectString(output.RegistryName),
        SchemaArn: __expectString(output.SchemaArn),
        SchemaCheckpoint: __expectLong(output.SchemaCheckpoint),
        SchemaName: __expectString(output.SchemaName),
        SchemaStatus: __expectString(output.SchemaStatus),
        UpdatedTime: __expectString(output.UpdatedTime),
    };
};
const deserializeAws_json1_1GetSchemaVersionResponse = (output, context) => {
    return {
        CreatedTime: __expectString(output.CreatedTime),
        DataFormat: __expectString(output.DataFormat),
        SchemaArn: __expectString(output.SchemaArn),
        SchemaDefinition: __expectString(output.SchemaDefinition),
        SchemaVersionId: __expectString(output.SchemaVersionId),
        Status: __expectString(output.Status),
        VersionNumber: __expectLong(output.VersionNumber),
    };
};
const deserializeAws_json1_1GetSchemaVersionsDiffResponse = (output, context) => {
    return {
        Diff: __expectString(output.Diff),
    };
};
const deserializeAws_json1_1GetSecurityConfigurationResponse = (output, context) => {
    return {
        SecurityConfiguration: output.SecurityConfiguration != null
            ? deserializeAws_json1_1SecurityConfiguration(output.SecurityConfiguration, context)
            : undefined,
    };
};
const deserializeAws_json1_1GetSecurityConfigurationsResponse = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        SecurityConfigurations: output.SecurityConfigurations != null
            ? deserializeAws_json1_1SecurityConfigurationList(output.SecurityConfigurations, context)
            : undefined,
    };
};
const deserializeAws_json1_1GetSessionResponse = (output, context) => {
    return {
        Session: output.Session != null ? deserializeAws_json1_1Session(output.Session, context) : undefined,
    };
};
const deserializeAws_json1_1GetStatementResponse = (output, context) => {
    return {
        Statement: output.Statement != null ? deserializeAws_json1_1Statement(output.Statement, context) : undefined,
    };
};
const deserializeAws_json1_1GetTableResponse = (output, context) => {
    return {
        Table: output.Table != null ? deserializeAws_json1_1Table(output.Table, context) : undefined,
    };
};
const deserializeAws_json1_1GetTablesResponse = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        TableList: output.TableList != null ? deserializeAws_json1_1TableList(output.TableList, context) : undefined,
    };
};
const deserializeAws_json1_1GetTableVersionResponse = (output, context) => {
    return {
        TableVersion: output.TableVersion != null ? deserializeAws_json1_1TableVersion(output.TableVersion, context) : undefined,
    };
};
const deserializeAws_json1_1GetTableVersionsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1TableVersion(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1GetTableVersionsResponse = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        TableVersions: output.TableVersions != null
            ? deserializeAws_json1_1GetTableVersionsList(output.TableVersions, context)
            : undefined,
    };
};
const deserializeAws_json1_1GetTagsResponse = (output, context) => {
    return {
        Tags: output.Tags != null ? deserializeAws_json1_1TagsMap(output.Tags, context) : undefined,
    };
};
const deserializeAws_json1_1GetTriggerResponse = (output, context) => {
    return {
        Trigger: output.Trigger != null ? deserializeAws_json1_1Trigger(output.Trigger, context) : undefined,
    };
};
const deserializeAws_json1_1GetTriggersResponse = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        Triggers: output.Triggers != null ? deserializeAws_json1_1TriggerList(output.Triggers, context) : undefined,
    };
};
const deserializeAws_json1_1GetUnfilteredPartitionMetadataResponse = (output, context) => {
    return {
        AuthorizedColumns: output.AuthorizedColumns != null
            ? deserializeAws_json1_1NameStringList(output.AuthorizedColumns, context)
            : undefined,
        IsRegisteredWithLakeFormation: __expectBoolean(output.IsRegisteredWithLakeFormation),
        Partition: output.Partition != null ? deserializeAws_json1_1Partition(output.Partition, context) : undefined,
    };
};
const deserializeAws_json1_1GetUnfilteredPartitionsMetadataResponse = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        UnfilteredPartitions: output.UnfilteredPartitions != null
            ? deserializeAws_json1_1UnfilteredPartitionList(output.UnfilteredPartitions, context)
            : undefined,
    };
};
const deserializeAws_json1_1GetUnfilteredTableMetadataResponse = (output, context) => {
    return {
        AuthorizedColumns: output.AuthorizedColumns != null
            ? deserializeAws_json1_1NameStringList(output.AuthorizedColumns, context)
            : undefined,
        CellFilters: output.CellFilters != null ? deserializeAws_json1_1ColumnRowFilterList(output.CellFilters, context) : undefined,
        IsRegisteredWithLakeFormation: __expectBoolean(output.IsRegisteredWithLakeFormation),
        Table: output.Table != null ? deserializeAws_json1_1Table(output.Table, context) : undefined,
    };
};
const deserializeAws_json1_1GetUserDefinedFunctionResponse = (output, context) => {
    return {
        UserDefinedFunction: output.UserDefinedFunction != null
            ? deserializeAws_json1_1UserDefinedFunction(output.UserDefinedFunction, context)
            : undefined,
    };
};
const deserializeAws_json1_1GetUserDefinedFunctionsResponse = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        UserDefinedFunctions: output.UserDefinedFunctions != null
            ? deserializeAws_json1_1UserDefinedFunctionList(output.UserDefinedFunctions, context)
            : undefined,
    };
};
const deserializeAws_json1_1GetWorkflowResponse = (output, context) => {
    return {
        Workflow: output.Workflow != null ? deserializeAws_json1_1Workflow(output.Workflow, context) : undefined,
    };
};
const deserializeAws_json1_1GetWorkflowRunPropertiesResponse = (output, context) => {
    return {
        RunProperties: output.RunProperties != null
            ? deserializeAws_json1_1WorkflowRunProperties(output.RunProperties, context)
            : undefined,
    };
};
const deserializeAws_json1_1GetWorkflowRunResponse = (output, context) => {
    return {
        Run: output.Run != null ? deserializeAws_json1_1WorkflowRun(output.Run, context) : undefined,
    };
};
const deserializeAws_json1_1GetWorkflowRunsResponse = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        Runs: output.Runs != null ? deserializeAws_json1_1WorkflowRuns(output.Runs, context) : undefined,
    };
};
const deserializeAws_json1_1GlueEncryptionException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_1GluePolicy = (output, context) => {
    return {
        CreateTime: output.CreateTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreateTime))) : undefined,
        PolicyHash: __expectString(output.PolicyHash),
        PolicyInJson: __expectString(output.PolicyInJson),
        UpdateTime: output.UpdateTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.UpdateTime))) : undefined,
    };
};
const deserializeAws_json1_1GlueSchema = (output, context) => {
    return {
        Columns: output.Columns != null ? deserializeAws_json1_1GlueStudioSchemaColumnList(output.Columns, context) : undefined,
    };
};
const deserializeAws_json1_1GlueSchemas = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1GlueSchema(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1GlueStudioPathList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1EnclosedInStringProperties(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1GlueStudioSchemaColumn = (output, context) => {
    return {
        Name: __expectString(output.Name),
        Type: __expectString(output.Type),
    };
};
const deserializeAws_json1_1GlueStudioSchemaColumnList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1GlueStudioSchemaColumn(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1GlueTable = (output, context) => {
    return {
        AdditionalOptions: output.AdditionalOptions != null
            ? deserializeAws_json1_1GlueTableAdditionalOptions(output.AdditionalOptions, context)
            : undefined,
        CatalogId: __expectString(output.CatalogId),
        ConnectionName: __expectString(output.ConnectionName),
        DatabaseName: __expectString(output.DatabaseName),
        TableName: __expectString(output.TableName),
    };
};
const deserializeAws_json1_1GlueTableAdditionalOptions = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = __expectString(value);
        return acc;
    }, {});
};
const deserializeAws_json1_1GlueTables = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1GlueTable(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1GovernedCatalogSource = (output, context) => {
    return {
        AdditionalOptions: output.AdditionalOptions != null
            ? deserializeAws_json1_1S3SourceAdditionalOptions(output.AdditionalOptions, context)
            : undefined,
        Database: __expectString(output.Database),
        Name: __expectString(output.Name),
        PartitionPredicate: __expectString(output.PartitionPredicate),
        Table: __expectString(output.Table),
    };
};
const deserializeAws_json1_1GovernedCatalogTarget = (output, context) => {
    return {
        Database: __expectString(output.Database),
        Inputs: output.Inputs != null ? deserializeAws_json1_1OneInput(output.Inputs, context) : undefined,
        Name: __expectString(output.Name),
        PartitionKeys: output.PartitionKeys != null
            ? deserializeAws_json1_1GlueStudioPathList(output.PartitionKeys, context)
            : undefined,
        SchemaChangePolicy: output.SchemaChangePolicy != null
            ? deserializeAws_json1_1CatalogSchemaChangePolicy(output.SchemaChangePolicy, context)
            : undefined,
        Table: __expectString(output.Table),
    };
};
const deserializeAws_json1_1GrokClassifier = (output, context) => {
    return {
        Classification: __expectString(output.Classification),
        CreationTime: output.CreationTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreationTime)))
            : undefined,
        CustomPatterns: __expectString(output.CustomPatterns),
        GrokPattern: __expectString(output.GrokPattern),
        LastUpdated: output.LastUpdated != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastUpdated)))
            : undefined,
        Name: __expectString(output.Name),
        Version: __expectLong(output.Version),
    };
};
const deserializeAws_json1_1IdempotentParameterMismatchException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_1IllegalBlueprintStateException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_1IllegalSessionStateException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_1IllegalWorkflowStateException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_1ImportCatalogToGlueResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1ImportLabelsTaskRunProperties = (output, context) => {
    return {
        InputS3Path: __expectString(output.InputS3Path),
        Replace: __expectBoolean(output.Replace),
    };
};
const deserializeAws_json1_1InternalServiceException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_1InvalidInputException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_1InvalidStateException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_1JDBCConnectorOptions = (output, context) => {
    return {
        DataTypeMapping: output.DataTypeMapping != null
            ? deserializeAws_json1_1JDBCDataTypeMapping(output.DataTypeMapping, context)
            : undefined,
        FilterPredicate: __expectString(output.FilterPredicate),
        JobBookmarkKeys: output.JobBookmarkKeys != null
            ? deserializeAws_json1_1EnclosedInStringProperties(output.JobBookmarkKeys, context)
            : undefined,
        JobBookmarkKeysSortOrder: __expectString(output.JobBookmarkKeysSortOrder),
        LowerBound: __expectLong(output.LowerBound),
        NumPartitions: __expectLong(output.NumPartitions),
        PartitionColumn: __expectString(output.PartitionColumn),
        UpperBound: __expectLong(output.UpperBound),
    };
};
const deserializeAws_json1_1JDBCConnectorSource = (output, context) => {
    return {
        AdditionalOptions: output.AdditionalOptions != null
            ? deserializeAws_json1_1JDBCConnectorOptions(output.AdditionalOptions, context)
            : undefined,
        ConnectionName: __expectString(output.ConnectionName),
        ConnectionTable: __expectString(output.ConnectionTable),
        ConnectionType: __expectString(output.ConnectionType),
        ConnectorName: __expectString(output.ConnectorName),
        Name: __expectString(output.Name),
        OutputSchemas: output.OutputSchemas != null ? deserializeAws_json1_1GlueSchemas(output.OutputSchemas, context) : undefined,
        Query: __expectString(output.Query),
    };
};
const deserializeAws_json1_1JDBCConnectorTarget = (output, context) => {
    return {
        AdditionalOptions: output.AdditionalOptions != null
            ? deserializeAws_json1_1AdditionalOptions(output.AdditionalOptions, context)
            : undefined,
        ConnectionName: __expectString(output.ConnectionName),
        ConnectionTable: __expectString(output.ConnectionTable),
        ConnectionType: __expectString(output.ConnectionType),
        ConnectorName: __expectString(output.ConnectorName),
        Inputs: output.Inputs != null ? deserializeAws_json1_1OneInput(output.Inputs, context) : undefined,
        Name: __expectString(output.Name),
        OutputSchemas: output.OutputSchemas != null ? deserializeAws_json1_1GlueSchemas(output.OutputSchemas, context) : undefined,
    };
};
const deserializeAws_json1_1JDBCDataTypeMapping = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = __expectString(value);
        return acc;
    }, {});
};
const deserializeAws_json1_1JdbcTarget = (output, context) => {
    return {
        ConnectionName: __expectString(output.ConnectionName),
        EnableAdditionalMetadata: output.EnableAdditionalMetadata != null
            ? deserializeAws_json1_1EnableAdditionalMetadata(output.EnableAdditionalMetadata, context)
            : undefined,
        Exclusions: output.Exclusions != null ? deserializeAws_json1_1PathList(output.Exclusions, context) : undefined,
        Path: __expectString(output.Path),
    };
};
const deserializeAws_json1_1JdbcTargetList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1JdbcTarget(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1Job = (output, context) => {
    return {
        AllocatedCapacity: __expectInt32(output.AllocatedCapacity),
        CodeGenConfigurationNodes: output.CodeGenConfigurationNodes != null
            ? deserializeAws_json1_1CodeGenConfigurationNodes(output.CodeGenConfigurationNodes, context)
            : undefined,
        Command: output.Command != null ? deserializeAws_json1_1JobCommand(output.Command, context) : undefined,
        Connections: output.Connections != null ? deserializeAws_json1_1ConnectionsList(output.Connections, context) : undefined,
        CreatedOn: output.CreatedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedOn))) : undefined,
        DefaultArguments: output.DefaultArguments != null ? deserializeAws_json1_1GenericMap(output.DefaultArguments, context) : undefined,
        Description: __expectString(output.Description),
        ExecutionClass: __expectString(output.ExecutionClass),
        ExecutionProperty: output.ExecutionProperty != null
            ? deserializeAws_json1_1ExecutionProperty(output.ExecutionProperty, context)
            : undefined,
        GlueVersion: __expectString(output.GlueVersion),
        LastModifiedOn: output.LastModifiedOn != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedOn)))
            : undefined,
        LogUri: __expectString(output.LogUri),
        MaxCapacity: __limitedParseDouble(output.MaxCapacity),
        MaxRetries: __expectInt32(output.MaxRetries),
        Name: __expectString(output.Name),
        NonOverridableArguments: output.NonOverridableArguments != null
            ? deserializeAws_json1_1GenericMap(output.NonOverridableArguments, context)
            : undefined,
        NotificationProperty: output.NotificationProperty != null
            ? deserializeAws_json1_1NotificationProperty(output.NotificationProperty, context)
            : undefined,
        NumberOfWorkers: __expectInt32(output.NumberOfWorkers),
        Role: __expectString(output.Role),
        SecurityConfiguration: __expectString(output.SecurityConfiguration),
        SourceControlDetails: output.SourceControlDetails != null
            ? deserializeAws_json1_1SourceControlDetails(output.SourceControlDetails, context)
            : undefined,
        Timeout: __expectInt32(output.Timeout),
        WorkerType: __expectString(output.WorkerType),
    };
};
const deserializeAws_json1_1JobBookmarkEntry = (output, context) => {
    return {
        Attempt: __expectInt32(output.Attempt),
        JobBookmark: __expectString(output.JobBookmark),
        JobName: __expectString(output.JobName),
        PreviousRunId: __expectString(output.PreviousRunId),
        Run: __expectInt32(output.Run),
        RunId: __expectString(output.RunId),
        Version: __expectInt32(output.Version),
    };
};
const deserializeAws_json1_1JobBookmarksEncryption = (output, context) => {
    return {
        JobBookmarksEncryptionMode: __expectString(output.JobBookmarksEncryptionMode),
        KmsKeyArn: __expectString(output.KmsKeyArn),
    };
};
const deserializeAws_json1_1JobCommand = (output, context) => {
    return {
        Name: __expectString(output.Name),
        PythonVersion: __expectString(output.PythonVersion),
        ScriptLocation: __expectString(output.ScriptLocation),
    };
};
const deserializeAws_json1_1JobList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Job(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1JobNameList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1JobNodeDetails = (output, context) => {
    return {
        JobRuns: output.JobRuns != null ? deserializeAws_json1_1JobRunList(output.JobRuns, context) : undefined,
    };
};
const deserializeAws_json1_1JobRun = (output, context) => {
    return {
        AllocatedCapacity: __expectInt32(output.AllocatedCapacity),
        Arguments: output.Arguments != null ? deserializeAws_json1_1GenericMap(output.Arguments, context) : undefined,
        Attempt: __expectInt32(output.Attempt),
        CompletedOn: output.CompletedOn != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CompletedOn)))
            : undefined,
        DPUSeconds: __limitedParseDouble(output.DPUSeconds),
        ErrorMessage: __expectString(output.ErrorMessage),
        ExecutionClass: __expectString(output.ExecutionClass),
        ExecutionTime: __expectInt32(output.ExecutionTime),
        GlueVersion: __expectString(output.GlueVersion),
        Id: __expectString(output.Id),
        JobName: __expectString(output.JobName),
        JobRunState: __expectString(output.JobRunState),
        LastModifiedOn: output.LastModifiedOn != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedOn)))
            : undefined,
        LogGroupName: __expectString(output.LogGroupName),
        MaxCapacity: __limitedParseDouble(output.MaxCapacity),
        NotificationProperty: output.NotificationProperty != null
            ? deserializeAws_json1_1NotificationProperty(output.NotificationProperty, context)
            : undefined,
        NumberOfWorkers: __expectInt32(output.NumberOfWorkers),
        PredecessorRuns: output.PredecessorRuns != null
            ? deserializeAws_json1_1PredecessorList(output.PredecessorRuns, context)
            : undefined,
        PreviousRunId: __expectString(output.PreviousRunId),
        SecurityConfiguration: __expectString(output.SecurityConfiguration),
        StartedOn: output.StartedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartedOn))) : undefined,
        Timeout: __expectInt32(output.Timeout),
        TriggerName: __expectString(output.TriggerName),
        WorkerType: __expectString(output.WorkerType),
    };
};
const deserializeAws_json1_1JobRunList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1JobRun(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1Join = (output, context) => {
    return {
        Columns: output.Columns != null ? deserializeAws_json1_1JoinColumns(output.Columns, context) : undefined,
        Inputs: output.Inputs != null ? deserializeAws_json1_1TwoInputs(output.Inputs, context) : undefined,
        JoinType: __expectString(output.JoinType),
        Name: __expectString(output.Name),
    };
};
const deserializeAws_json1_1JoinColumn = (output, context) => {
    return {
        From: __expectString(output.From),
        Keys: output.Keys != null ? deserializeAws_json1_1GlueStudioPathList(output.Keys, context) : undefined,
    };
};
const deserializeAws_json1_1JoinColumns = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1JoinColumn(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1JsonClassifier = (output, context) => {
    return {
        CreationTime: output.CreationTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreationTime)))
            : undefined,
        JsonPath: __expectString(output.JsonPath),
        LastUpdated: output.LastUpdated != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastUpdated)))
            : undefined,
        Name: __expectString(output.Name),
        Version: __expectLong(output.Version),
    };
};
const deserializeAws_json1_1KafkaStreamingSourceOptions = (output, context) => {
    return {
        AddRecordTimestamp: __expectString(output.AddRecordTimestamp),
        Assign: __expectString(output.Assign),
        BootstrapServers: __expectString(output.BootstrapServers),
        Classification: __expectString(output.Classification),
        ConnectionName: __expectString(output.ConnectionName),
        Delimiter: __expectString(output.Delimiter),
        EmitConsumerLagMetrics: __expectString(output.EmitConsumerLagMetrics),
        EndingOffsets: __expectString(output.EndingOffsets),
        IncludeHeaders: __expectBoolean(output.IncludeHeaders),
        MaxOffsetsPerTrigger: __expectLong(output.MaxOffsetsPerTrigger),
        MinPartitions: __expectInt32(output.MinPartitions),
        NumRetries: __expectInt32(output.NumRetries),
        PollTimeoutMs: __expectLong(output.PollTimeoutMs),
        RetryIntervalMs: __expectLong(output.RetryIntervalMs),
        SecurityProtocol: __expectString(output.SecurityProtocol),
        StartingOffsets: __expectString(output.StartingOffsets),
        SubscribePattern: __expectString(output.SubscribePattern),
        TopicName: __expectString(output.TopicName),
    };
};
const deserializeAws_json1_1KeySchemaElement = (output, context) => {
    return {
        Name: __expectString(output.Name),
        Type: __expectString(output.Type),
    };
};
const deserializeAws_json1_1KeySchemaElementList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1KeySchemaElement(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1KinesisStreamingSourceOptions = (output, context) => {
    return {
        AddIdleTimeBetweenReads: __expectBoolean(output.AddIdleTimeBetweenReads),
        AddRecordTimestamp: __expectString(output.AddRecordTimestamp),
        AvoidEmptyBatches: __expectBoolean(output.AvoidEmptyBatches),
        Classification: __expectString(output.Classification),
        Delimiter: __expectString(output.Delimiter),
        DescribeShardInterval: __expectLong(output.DescribeShardInterval),
        EmitConsumerLagMetrics: __expectString(output.EmitConsumerLagMetrics),
        EndpointUrl: __expectString(output.EndpointUrl),
        IdleTimeBetweenReadsInMs: __expectLong(output.IdleTimeBetweenReadsInMs),
        MaxFetchRecordsPerShard: __expectLong(output.MaxFetchRecordsPerShard),
        MaxFetchTimeInMs: __expectLong(output.MaxFetchTimeInMs),
        MaxRecordPerRead: __expectLong(output.MaxRecordPerRead),
        MaxRetryIntervalMs: __expectLong(output.MaxRetryIntervalMs),
        NumRetries: __expectInt32(output.NumRetries),
        RetryIntervalMs: __expectLong(output.RetryIntervalMs),
        RoleArn: __expectString(output.RoleArn),
        RoleSessionName: __expectString(output.RoleSessionName),
        StartingPosition: __expectString(output.StartingPosition),
        StreamArn: __expectString(output.StreamArn),
        StreamName: __expectString(output.StreamName),
    };
};
const deserializeAws_json1_1LabelingSetGenerationTaskRunProperties = (output, context) => {
    return {
        OutputS3Path: __expectString(output.OutputS3Path),
    };
};
const deserializeAws_json1_1LakeFormationConfiguration = (output, context) => {
    return {
        AccountId: __expectString(output.AccountId),
        UseLakeFormationCredentials: __expectBoolean(output.UseLakeFormationCredentials),
    };
};
const deserializeAws_json1_1LastActiveDefinition = (output, context) => {
    return {
        BlueprintLocation: __expectString(output.BlueprintLocation),
        BlueprintServiceLocation: __expectString(output.BlueprintServiceLocation),
        Description: __expectString(output.Description),
        LastModifiedOn: output.LastModifiedOn != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedOn)))
            : undefined,
        ParameterSpec: __expectString(output.ParameterSpec),
    };
};
const deserializeAws_json1_1LastCrawlInfo = (output, context) => {
    return {
        ErrorMessage: __expectString(output.ErrorMessage),
        LogGroup: __expectString(output.LogGroup),
        LogStream: __expectString(output.LogStream),
        MessagePrefix: __expectString(output.MessagePrefix),
        StartTime: output.StartTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartTime))) : undefined,
        Status: __expectString(output.Status),
    };
};
const deserializeAws_json1_1LimitedPathList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1LimitedStringList(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1LimitedStringList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1LineageConfiguration = (output, context) => {
    return {
        CrawlerLineageSettings: __expectString(output.CrawlerLineageSettings),
    };
};
const deserializeAws_json1_1ListBlueprintsResponse = (output, context) => {
    return {
        Blueprints: output.Blueprints != null ? deserializeAws_json1_1BlueprintNames(output.Blueprints, context) : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const deserializeAws_json1_1ListCrawlersResponse = (output, context) => {
    return {
        CrawlerNames: output.CrawlerNames != null ? deserializeAws_json1_1CrawlerNameList(output.CrawlerNames, context) : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const deserializeAws_json1_1ListCrawlsResponse = (output, context) => {
    return {
        Crawls: output.Crawls != null ? deserializeAws_json1_1CrawlerHistoryList(output.Crawls, context) : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const deserializeAws_json1_1ListCustomEntityTypesResponse = (output, context) => {
    return {
        CustomEntityTypes: output.CustomEntityTypes != null
            ? deserializeAws_json1_1CustomEntityTypes(output.CustomEntityTypes, context)
            : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const deserializeAws_json1_1ListDataQualityResultsResponse = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        Results: output.Results != null
            ? deserializeAws_json1_1DataQualityResultDescriptionList(output.Results, context)
            : undefined,
    };
};
const deserializeAws_json1_1ListDataQualityRuleRecommendationRunsResponse = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        Runs: output.Runs != null
            ? deserializeAws_json1_1DataQualityRuleRecommendationRunList(output.Runs, context)
            : undefined,
    };
};
const deserializeAws_json1_1ListDataQualityRulesetEvaluationRunsResponse = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        Runs: output.Runs != null ? deserializeAws_json1_1DataQualityRulesetEvaluationRunList(output.Runs, context) : undefined,
    };
};
const deserializeAws_json1_1ListDataQualityRulesetsResponse = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        Rulesets: output.Rulesets != null ? deserializeAws_json1_1DataQualityRulesetList(output.Rulesets, context) : undefined,
    };
};
const deserializeAws_json1_1ListDevEndpointsResponse = (output, context) => {
    return {
        DevEndpointNames: output.DevEndpointNames != null
            ? deserializeAws_json1_1DevEndpointNameList(output.DevEndpointNames, context)
            : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const deserializeAws_json1_1ListJobsResponse = (output, context) => {
    return {
        JobNames: output.JobNames != null ? deserializeAws_json1_1JobNameList(output.JobNames, context) : undefined,
        NextToken: __expectString(output.NextToken),
    };
};
const deserializeAws_json1_1ListMLTransformsResponse = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        TransformIds: output.TransformIds != null ? deserializeAws_json1_1TransformIdList(output.TransformIds, context) : undefined,
    };
};
const deserializeAws_json1_1ListRegistriesResponse = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        Registries: output.Registries != null ? deserializeAws_json1_1RegistryListDefinition(output.Registries, context) : undefined,
    };
};
const deserializeAws_json1_1ListSchemasResponse = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        Schemas: output.Schemas != null ? deserializeAws_json1_1SchemaListDefinition(output.Schemas, context) : undefined,
    };
};
const deserializeAws_json1_1ListSchemaVersionsResponse = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        Schemas: output.Schemas != null ? deserializeAws_json1_1SchemaVersionList(output.Schemas, context) : undefined,
    };
};
const deserializeAws_json1_1ListSessionsResponse = (output, context) => {
    return {
        Ids: output.Ids != null ? deserializeAws_json1_1SessionIdList(output.Ids, context) : undefined,
        NextToken: __expectString(output.NextToken),
        Sessions: output.Sessions != null ? deserializeAws_json1_1SessionList(output.Sessions, context) : undefined,
    };
};
const deserializeAws_json1_1ListStatementsResponse = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        Statements: output.Statements != null ? deserializeAws_json1_1StatementList(output.Statements, context) : undefined,
    };
};
const deserializeAws_json1_1ListTriggersResponse = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        TriggerNames: output.TriggerNames != null ? deserializeAws_json1_1TriggerNameList(output.TriggerNames, context) : undefined,
    };
};
const deserializeAws_json1_1ListWorkflowsResponse = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        Workflows: output.Workflows != null ? deserializeAws_json1_1WorkflowNames(output.Workflows, context) : undefined,
    };
};
const deserializeAws_json1_1LocationMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = __expectString(value);
        return acc;
    }, {});
};
const deserializeAws_json1_1LocationStringList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1LongColumnStatisticsData = (output, context) => {
    return {
        MaximumValue: __expectLong(output.MaximumValue),
        MinimumValue: __expectLong(output.MinimumValue),
        NumberOfDistinctValues: __expectLong(output.NumberOfDistinctValues),
        NumberOfNulls: __expectLong(output.NumberOfNulls),
    };
};
const deserializeAws_json1_1ManyInputs = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1Mapping = (output, context) => {
    return {
        Children: output.Children != null ? deserializeAws_json1_1Mappings(output.Children, context) : undefined,
        Dropped: __expectBoolean(output.Dropped),
        FromPath: output.FromPath != null ? deserializeAws_json1_1EnclosedInStringProperties(output.FromPath, context) : undefined,
        FromType: __expectString(output.FromType),
        ToKey: __expectString(output.ToKey),
        ToType: __expectString(output.ToType),
    };
};
const deserializeAws_json1_1MappingEntry = (output, context) => {
    return {
        SourcePath: __expectString(output.SourcePath),
        SourceTable: __expectString(output.SourceTable),
        SourceType: __expectString(output.SourceType),
        TargetPath: __expectString(output.TargetPath),
        TargetTable: __expectString(output.TargetTable),
        TargetType: __expectString(output.TargetType),
    };
};
const deserializeAws_json1_1MappingList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1MappingEntry(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1Mappings = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Mapping(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1MapValue = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = __expectString(value);
        return acc;
    }, {});
};
const deserializeAws_json1_1MatchCriteria = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1Merge = (output, context) => {
    return {
        Inputs: output.Inputs != null ? deserializeAws_json1_1TwoInputs(output.Inputs, context) : undefined,
        Name: __expectString(output.Name),
        PrimaryKeys: output.PrimaryKeys != null ? deserializeAws_json1_1GlueStudioPathList(output.PrimaryKeys, context) : undefined,
        Source: __expectString(output.Source),
    };
};
const deserializeAws_json1_1MetadataInfo = (output, context) => {
    return {
        CreatedTime: __expectString(output.CreatedTime),
        MetadataValue: __expectString(output.MetadataValue),
        OtherMetadataValueList: output.OtherMetadataValueList != null
            ? deserializeAws_json1_1OtherMetadataValueList(output.OtherMetadataValueList, context)
            : undefined,
    };
};
const deserializeAws_json1_1MetadataInfoMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = deserializeAws_json1_1MetadataInfo(value, context);
        return acc;
    }, {});
};
const deserializeAws_json1_1MicrosoftSQLServerCatalogSource = (output, context) => {
    return {
        Database: __expectString(output.Database),
        Name: __expectString(output.Name),
        Table: __expectString(output.Table),
    };
};
const deserializeAws_json1_1MicrosoftSQLServerCatalogTarget = (output, context) => {
    return {
        Database: __expectString(output.Database),
        Inputs: output.Inputs != null ? deserializeAws_json1_1OneInput(output.Inputs, context) : undefined,
        Name: __expectString(output.Name),
        Table: __expectString(output.Table),
    };
};
const deserializeAws_json1_1MLTransform = (output, context) => {
    return {
        CreatedOn: output.CreatedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedOn))) : undefined,
        Description: __expectString(output.Description),
        EvaluationMetrics: output.EvaluationMetrics != null
            ? deserializeAws_json1_1EvaluationMetrics(output.EvaluationMetrics, context)
            : undefined,
        GlueVersion: __expectString(output.GlueVersion),
        InputRecordTables: output.InputRecordTables != null
            ? deserializeAws_json1_1GlueTables(output.InputRecordTables, context)
            : undefined,
        LabelCount: __expectInt32(output.LabelCount),
        LastModifiedOn: output.LastModifiedOn != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedOn)))
            : undefined,
        MaxCapacity: __limitedParseDouble(output.MaxCapacity),
        MaxRetries: __expectInt32(output.MaxRetries),
        Name: __expectString(output.Name),
        NumberOfWorkers: __expectInt32(output.NumberOfWorkers),
        Parameters: output.Parameters != null ? deserializeAws_json1_1TransformParameters(output.Parameters, context) : undefined,
        Role: __expectString(output.Role),
        Schema: output.Schema != null ? deserializeAws_json1_1TransformSchema(output.Schema, context) : undefined,
        Status: __expectString(output.Status),
        Timeout: __expectInt32(output.Timeout),
        TransformEncryption: output.TransformEncryption != null
            ? deserializeAws_json1_1TransformEncryption(output.TransformEncryption, context)
            : undefined,
        TransformId: __expectString(output.TransformId),
        WorkerType: __expectString(output.WorkerType),
    };
};
const deserializeAws_json1_1MLTransformNotReadyException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_1MLUserDataEncryption = (output, context) => {
    return {
        KmsKeyId: __expectString(output.KmsKeyId),
        MlUserDataEncryptionMode: __expectString(output.MlUserDataEncryptionMode),
    };
};
const deserializeAws_json1_1MongoDBTarget = (output, context) => {
    return {
        ConnectionName: __expectString(output.ConnectionName),
        Path: __expectString(output.Path),
        ScanAll: __expectBoolean(output.ScanAll),
    };
};
const deserializeAws_json1_1MongoDBTargetList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1MongoDBTarget(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1MySQLCatalogSource = (output, context) => {
    return {
        Database: __expectString(output.Database),
        Name: __expectString(output.Name),
        Table: __expectString(output.Table),
    };
};
const deserializeAws_json1_1MySQLCatalogTarget = (output, context) => {
    return {
        Database: __expectString(output.Database),
        Inputs: output.Inputs != null ? deserializeAws_json1_1OneInput(output.Inputs, context) : undefined,
        Name: __expectString(output.Name),
        Table: __expectString(output.Table),
    };
};
const deserializeAws_json1_1NameStringList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1Node = (output, context) => {
    return {
        CrawlerDetails: output.CrawlerDetails != null
            ? deserializeAws_json1_1CrawlerNodeDetails(output.CrawlerDetails, context)
            : undefined,
        JobDetails: output.JobDetails != null ? deserializeAws_json1_1JobNodeDetails(output.JobDetails, context) : undefined,
        Name: __expectString(output.Name),
        TriggerDetails: output.TriggerDetails != null
            ? deserializeAws_json1_1TriggerNodeDetails(output.TriggerDetails, context)
            : undefined,
        Type: __expectString(output.Type),
        UniqueId: __expectString(output.UniqueId),
    };
};
const deserializeAws_json1_1NodeIdList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1NodeList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Node(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1NoScheduleException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_1NotificationProperty = (output, context) => {
    return {
        NotifyDelayAfter: __expectInt32(output.NotifyDelayAfter),
    };
};
const deserializeAws_json1_1NullCheckBoxList = (output, context) => {
    return {
        IsEmpty: __expectBoolean(output.IsEmpty),
        IsNegOne: __expectBoolean(output.IsNegOne),
        IsNullString: __expectBoolean(output.IsNullString),
    };
};
const deserializeAws_json1_1NullValueField = (output, context) => {
    return {
        Datatype: output.Datatype != null ? deserializeAws_json1_1Datatype(output.Datatype, context) : undefined,
        Value: __expectString(output.Value),
    };
};
const deserializeAws_json1_1NullValueFields = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1NullValueField(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1OneInput = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1OperationTimeoutException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_1OracleSQLCatalogSource = (output, context) => {
    return {
        Database: __expectString(output.Database),
        Name: __expectString(output.Name),
        Table: __expectString(output.Table),
    };
};
const deserializeAws_json1_1OracleSQLCatalogTarget = (output, context) => {
    return {
        Database: __expectString(output.Database),
        Inputs: output.Inputs != null ? deserializeAws_json1_1OneInput(output.Inputs, context) : undefined,
        Name: __expectString(output.Name),
        Table: __expectString(output.Table),
    };
};
const deserializeAws_json1_1OrchestrationArgumentsMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = __expectString(value);
        return acc;
    }, {});
};
const deserializeAws_json1_1OrchestrationStringList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1Order = (output, context) => {
    return {
        Column: __expectString(output.Column),
        SortOrder: __expectInt32(output.SortOrder),
    };
};
const deserializeAws_json1_1OrderList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Order(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1OtherMetadataValueList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1OtherMetadataValueListItem(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1OtherMetadataValueListItem = (output, context) => {
    return {
        CreatedTime: __expectString(output.CreatedTime),
        MetadataValue: __expectString(output.MetadataValue),
    };
};
const deserializeAws_json1_1ParametersMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = __expectString(value);
        return acc;
    }, {});
};
const deserializeAws_json1_1Partition = (output, context) => {
    return {
        CatalogId: __expectString(output.CatalogId),
        CreationTime: output.CreationTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreationTime)))
            : undefined,
        DatabaseName: __expectString(output.DatabaseName),
        LastAccessTime: output.LastAccessTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastAccessTime)))
            : undefined,
        LastAnalyzedTime: output.LastAnalyzedTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastAnalyzedTime)))
            : undefined,
        Parameters: output.Parameters != null ? deserializeAws_json1_1ParametersMap(output.Parameters, context) : undefined,
        StorageDescriptor: output.StorageDescriptor != null
            ? deserializeAws_json1_1StorageDescriptor(output.StorageDescriptor, context)
            : undefined,
        TableName: __expectString(output.TableName),
        Values: output.Values != null ? deserializeAws_json1_1ValueStringList(output.Values, context) : undefined,
    };
};
const deserializeAws_json1_1PartitionError = (output, context) => {
    return {
        ErrorDetail: output.ErrorDetail != null ? deserializeAws_json1_1ErrorDetail(output.ErrorDetail, context) : undefined,
        PartitionValues: output.PartitionValues != null
            ? deserializeAws_json1_1ValueStringList(output.PartitionValues, context)
            : undefined,
    };
};
const deserializeAws_json1_1PartitionErrors = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1PartitionError(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1PartitionIndexDescriptor = (output, context) => {
    return {
        BackfillErrors: output.BackfillErrors != null ? deserializeAws_json1_1BackfillErrors(output.BackfillErrors, context) : undefined,
        IndexName: __expectString(output.IndexName),
        IndexStatus: __expectString(output.IndexStatus),
        Keys: output.Keys != null ? deserializeAws_json1_1KeySchemaElementList(output.Keys, context) : undefined,
    };
};
const deserializeAws_json1_1PartitionIndexDescriptorList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1PartitionIndexDescriptor(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1PartitionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Partition(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1PartitionValueList = (output, context) => {
    return {
        Values: output.Values != null ? deserializeAws_json1_1ValueStringList(output.Values, context) : undefined,
    };
};
const deserializeAws_json1_1PathList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1PermissionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1PermissionTypeMismatchException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_1PhysicalConnectionRequirements = (output, context) => {
    return {
        AvailabilityZone: __expectString(output.AvailabilityZone),
        SecurityGroupIdList: output.SecurityGroupIdList != null
            ? deserializeAws_json1_1SecurityGroupIdList(output.SecurityGroupIdList, context)
            : undefined,
        SubnetId: __expectString(output.SubnetId),
    };
};
const deserializeAws_json1_1PIIDetection = (output, context) => {
    return {
        EntityTypesToDetect: output.EntityTypesToDetect != null
            ? deserializeAws_json1_1EnclosedInStringProperties(output.EntityTypesToDetect, context)
            : undefined,
        Inputs: output.Inputs != null ? deserializeAws_json1_1OneInput(output.Inputs, context) : undefined,
        MaskValue: __expectString(output.MaskValue),
        Name: __expectString(output.Name),
        OutputColumnName: __expectString(output.OutputColumnName),
        PiiType: __expectString(output.PiiType),
        SampleFraction: __limitedParseDouble(output.SampleFraction),
        ThresholdFraction: __limitedParseDouble(output.ThresholdFraction),
    };
};
const deserializeAws_json1_1PostgreSQLCatalogSource = (output, context) => {
    return {
        Database: __expectString(output.Database),
        Name: __expectString(output.Name),
        Table: __expectString(output.Table),
    };
};
const deserializeAws_json1_1PostgreSQLCatalogTarget = (output, context) => {
    return {
        Database: __expectString(output.Database),
        Inputs: output.Inputs != null ? deserializeAws_json1_1OneInput(output.Inputs, context) : undefined,
        Name: __expectString(output.Name),
        Table: __expectString(output.Table),
    };
};
const deserializeAws_json1_1Predecessor = (output, context) => {
    return {
        JobName: __expectString(output.JobName),
        RunId: __expectString(output.RunId),
    };
};
const deserializeAws_json1_1PredecessorList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Predecessor(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1Predicate = (output, context) => {
    return {
        Conditions: output.Conditions != null ? deserializeAws_json1_1ConditionList(output.Conditions, context) : undefined,
        Logical: __expectString(output.Logical),
    };
};
const deserializeAws_json1_1PrincipalPermissions = (output, context) => {
    return {
        Permissions: output.Permissions != null ? deserializeAws_json1_1PermissionList(output.Permissions, context) : undefined,
        Principal: output.Principal != null ? deserializeAws_json1_1DataLakePrincipal(output.Principal, context) : undefined,
    };
};
const deserializeAws_json1_1PrincipalPermissionsList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1PrincipalPermissions(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1PublicKeysList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1PutDataCatalogEncryptionSettingsResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1PutResourcePolicyResponse = (output, context) => {
    return {
        PolicyHash: __expectString(output.PolicyHash),
    };
};
const deserializeAws_json1_1PutSchemaVersionMetadataResponse = (output, context) => {
    return {
        LatestVersion: __expectBoolean(output.LatestVersion),
        MetadataKey: __expectString(output.MetadataKey),
        MetadataValue: __expectString(output.MetadataValue),
        RegistryName: __expectString(output.RegistryName),
        SchemaArn: __expectString(output.SchemaArn),
        SchemaName: __expectString(output.SchemaName),
        SchemaVersionId: __expectString(output.SchemaVersionId),
        VersionNumber: __expectLong(output.VersionNumber),
    };
};
const deserializeAws_json1_1PutWorkflowRunPropertiesResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1QuerySchemaVersionMetadataResponse = (output, context) => {
    return {
        MetadataInfoMap: output.MetadataInfoMap != null
            ? deserializeAws_json1_1MetadataInfoMap(output.MetadataInfoMap, context)
            : undefined,
        NextToken: __expectString(output.NextToken),
        SchemaVersionId: __expectString(output.SchemaVersionId),
    };
};
const deserializeAws_json1_1RecrawlPolicy = (output, context) => {
    return {
        RecrawlBehavior: __expectString(output.RecrawlBehavior),
    };
};
const deserializeAws_json1_1RedshiftSource = (output, context) => {
    return {
        Database: __expectString(output.Database),
        Name: __expectString(output.Name),
        RedshiftTmpDir: __expectString(output.RedshiftTmpDir),
        Table: __expectString(output.Table),
        TmpDirIAMRole: __expectString(output.TmpDirIAMRole),
    };
};
const deserializeAws_json1_1RedshiftTarget = (output, context) => {
    return {
        Database: __expectString(output.Database),
        Inputs: output.Inputs != null ? deserializeAws_json1_1OneInput(output.Inputs, context) : undefined,
        Name: __expectString(output.Name),
        RedshiftTmpDir: __expectString(output.RedshiftTmpDir),
        Table: __expectString(output.Table),
        TmpDirIAMRole: __expectString(output.TmpDirIAMRole),
        UpsertRedshiftOptions: output.UpsertRedshiftOptions != null
            ? deserializeAws_json1_1UpsertRedshiftTargetOptions(output.UpsertRedshiftOptions, context)
            : undefined,
    };
};
const deserializeAws_json1_1RegisterSchemaVersionResponse = (output, context) => {
    return {
        SchemaVersionId: __expectString(output.SchemaVersionId),
        Status: __expectString(output.Status),
        VersionNumber: __expectLong(output.VersionNumber),
    };
};
const deserializeAws_json1_1RegistryListDefinition = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1RegistryListItem(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1RegistryListItem = (output, context) => {
    return {
        CreatedTime: __expectString(output.CreatedTime),
        Description: __expectString(output.Description),
        RegistryArn: __expectString(output.RegistryArn),
        RegistryName: __expectString(output.RegistryName),
        Status: __expectString(output.Status),
        UpdatedTime: __expectString(output.UpdatedTime),
    };
};
const deserializeAws_json1_1RelationalCatalogSource = (output, context) => {
    return {
        Database: __expectString(output.Database),
        Name: __expectString(output.Name),
        Table: __expectString(output.Table),
    };
};
const deserializeAws_json1_1RemoveSchemaVersionMetadataResponse = (output, context) => {
    return {
        LatestVersion: __expectBoolean(output.LatestVersion),
        MetadataKey: __expectString(output.MetadataKey),
        MetadataValue: __expectString(output.MetadataValue),
        RegistryName: __expectString(output.RegistryName),
        SchemaArn: __expectString(output.SchemaArn),
        SchemaName: __expectString(output.SchemaName),
        SchemaVersionId: __expectString(output.SchemaVersionId),
        VersionNumber: __expectLong(output.VersionNumber),
    };
};
const deserializeAws_json1_1RenameField = (output, context) => {
    return {
        Inputs: output.Inputs != null ? deserializeAws_json1_1OneInput(output.Inputs, context) : undefined,
        Name: __expectString(output.Name),
        SourcePath: output.SourcePath != null
            ? deserializeAws_json1_1EnclosedInStringProperties(output.SourcePath, context)
            : undefined,
        TargetPath: output.TargetPath != null
            ? deserializeAws_json1_1EnclosedInStringProperties(output.TargetPath, context)
            : undefined,
    };
};
const deserializeAws_json1_1ResetJobBookmarkResponse = (output, context) => {
    return {
        JobBookmarkEntry: output.JobBookmarkEntry != null
            ? deserializeAws_json1_1JobBookmarkEntry(output.JobBookmarkEntry, context)
            : undefined,
    };
};
const deserializeAws_json1_1ResourceNotReadyException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_1ResourceNumberLimitExceededException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_1ResourceUri = (output, context) => {
    return {
        ResourceType: __expectString(output.ResourceType),
        Uri: __expectString(output.Uri),
    };
};
const deserializeAws_json1_1ResourceUriList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1ResourceUri(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1ResumeWorkflowRunResponse = (output, context) => {
    return {
        NodeIds: output.NodeIds != null ? deserializeAws_json1_1NodeIdList(output.NodeIds, context) : undefined,
        RunId: __expectString(output.RunId),
    };
};
const deserializeAws_json1_1RulesetNames = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1RunStatementResponse = (output, context) => {
    return {
        Id: __expectInt32(output.Id),
    };
};
const deserializeAws_json1_1S3CatalogHudiSource = (output, context) => {
    return {
        AdditionalHudiOptions: output.AdditionalHudiOptions != null
            ? deserializeAws_json1_1AdditionalOptions(output.AdditionalHudiOptions, context)
            : undefined,
        Database: __expectString(output.Database),
        Name: __expectString(output.Name),
        OutputSchemas: output.OutputSchemas != null ? deserializeAws_json1_1GlueSchemas(output.OutputSchemas, context) : undefined,
        Table: __expectString(output.Table),
    };
};
const deserializeAws_json1_1S3CatalogSource = (output, context) => {
    return {
        AdditionalOptions: output.AdditionalOptions != null
            ? deserializeAws_json1_1S3SourceAdditionalOptions(output.AdditionalOptions, context)
            : undefined,
        Database: __expectString(output.Database),
        Name: __expectString(output.Name),
        PartitionPredicate: __expectString(output.PartitionPredicate),
        Table: __expectString(output.Table),
    };
};
const deserializeAws_json1_1S3CatalogTarget = (output, context) => {
    return {
        Database: __expectString(output.Database),
        Inputs: output.Inputs != null ? deserializeAws_json1_1OneInput(output.Inputs, context) : undefined,
        Name: __expectString(output.Name),
        PartitionKeys: output.PartitionKeys != null
            ? deserializeAws_json1_1GlueStudioPathList(output.PartitionKeys, context)
            : undefined,
        SchemaChangePolicy: output.SchemaChangePolicy != null
            ? deserializeAws_json1_1CatalogSchemaChangePolicy(output.SchemaChangePolicy, context)
            : undefined,
        Table: __expectString(output.Table),
    };
};
const deserializeAws_json1_1S3CsvSource = (output, context) => {
    return {
        AdditionalOptions: output.AdditionalOptions != null
            ? deserializeAws_json1_1S3DirectSourceAdditionalOptions(output.AdditionalOptions, context)
            : undefined,
        CompressionType: __expectString(output.CompressionType),
        Escaper: __expectString(output.Escaper),
        Exclusions: output.Exclusions != null
            ? deserializeAws_json1_1EnclosedInStringProperties(output.Exclusions, context)
            : undefined,
        GroupFiles: __expectString(output.GroupFiles),
        GroupSize: __expectString(output.GroupSize),
        MaxBand: __expectInt32(output.MaxBand),
        MaxFilesInBand: __expectInt32(output.MaxFilesInBand),
        Multiline: __expectBoolean(output.Multiline),
        Name: __expectString(output.Name),
        OptimizePerformance: __expectBoolean(output.OptimizePerformance),
        OutputSchemas: output.OutputSchemas != null ? deserializeAws_json1_1GlueSchemas(output.OutputSchemas, context) : undefined,
        Paths: output.Paths != null ? deserializeAws_json1_1EnclosedInStringProperties(output.Paths, context) : undefined,
        QuoteChar: __expectString(output.QuoteChar),
        Recurse: __expectBoolean(output.Recurse),
        Separator: __expectString(output.Separator),
        SkipFirst: __expectBoolean(output.SkipFirst),
        WithHeader: __expectBoolean(output.WithHeader),
        WriteHeader: __expectBoolean(output.WriteHeader),
    };
};
const deserializeAws_json1_1S3DirectSourceAdditionalOptions = (output, context) => {
    return {
        BoundedFiles: __expectLong(output.BoundedFiles),
        BoundedSize: __expectLong(output.BoundedSize),
        EnableSamplePath: __expectBoolean(output.EnableSamplePath),
        SamplePath: __expectString(output.SamplePath),
    };
};
const deserializeAws_json1_1S3DirectTarget = (output, context) => {
    return {
        Compression: __expectString(output.Compression),
        Format: __expectString(output.Format),
        Inputs: output.Inputs != null ? deserializeAws_json1_1OneInput(output.Inputs, context) : undefined,
        Name: __expectString(output.Name),
        PartitionKeys: output.PartitionKeys != null
            ? deserializeAws_json1_1GlueStudioPathList(output.PartitionKeys, context)
            : undefined,
        Path: __expectString(output.Path),
        SchemaChangePolicy: output.SchemaChangePolicy != null
            ? deserializeAws_json1_1DirectSchemaChangePolicy(output.SchemaChangePolicy, context)
            : undefined,
    };
};
const deserializeAws_json1_1S3Encryption = (output, context) => {
    return {
        KmsKeyArn: __expectString(output.KmsKeyArn),
        S3EncryptionMode: __expectString(output.S3EncryptionMode),
    };
};
const deserializeAws_json1_1S3EncryptionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1S3Encryption(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1S3GlueParquetTarget = (output, context) => {
    return {
        Compression: __expectString(output.Compression),
        Inputs: output.Inputs != null ? deserializeAws_json1_1OneInput(output.Inputs, context) : undefined,
        Name: __expectString(output.Name),
        PartitionKeys: output.PartitionKeys != null
            ? deserializeAws_json1_1GlueStudioPathList(output.PartitionKeys, context)
            : undefined,
        Path: __expectString(output.Path),
        SchemaChangePolicy: output.SchemaChangePolicy != null
            ? deserializeAws_json1_1DirectSchemaChangePolicy(output.SchemaChangePolicy, context)
            : undefined,
    };
};
const deserializeAws_json1_1S3HudiCatalogTarget = (output, context) => {
    return {
        AdditionalOptions: output.AdditionalOptions != null
            ? deserializeAws_json1_1AdditionalOptions(output.AdditionalOptions, context)
            : undefined,
        Database: __expectString(output.Database),
        Inputs: output.Inputs != null ? deserializeAws_json1_1OneInput(output.Inputs, context) : undefined,
        Name: __expectString(output.Name),
        PartitionKeys: output.PartitionKeys != null
            ? deserializeAws_json1_1GlueStudioPathList(output.PartitionKeys, context)
            : undefined,
        SchemaChangePolicy: output.SchemaChangePolicy != null
            ? deserializeAws_json1_1CatalogSchemaChangePolicy(output.SchemaChangePolicy, context)
            : undefined,
        Table: __expectString(output.Table),
    };
};
const deserializeAws_json1_1S3HudiDirectTarget = (output, context) => {
    return {
        AdditionalOptions: output.AdditionalOptions != null
            ? deserializeAws_json1_1AdditionalOptions(output.AdditionalOptions, context)
            : undefined,
        Compression: __expectString(output.Compression),
        Format: __expectString(output.Format),
        Inputs: output.Inputs != null ? deserializeAws_json1_1OneInput(output.Inputs, context) : undefined,
        Name: __expectString(output.Name),
        PartitionKeys: output.PartitionKeys != null
            ? deserializeAws_json1_1GlueStudioPathList(output.PartitionKeys, context)
            : undefined,
        Path: __expectString(output.Path),
        SchemaChangePolicy: output.SchemaChangePolicy != null
            ? deserializeAws_json1_1DirectSchemaChangePolicy(output.SchemaChangePolicy, context)
            : undefined,
    };
};
const deserializeAws_json1_1S3HudiSource = (output, context) => {
    return {
        AdditionalHudiOptions: output.AdditionalHudiOptions != null
            ? deserializeAws_json1_1AdditionalOptions(output.AdditionalHudiOptions, context)
            : undefined,
        AdditionalOptions: output.AdditionalOptions != null
            ? deserializeAws_json1_1S3DirectSourceAdditionalOptions(output.AdditionalOptions, context)
            : undefined,
        Name: __expectString(output.Name),
        OutputSchemas: output.OutputSchemas != null ? deserializeAws_json1_1GlueSchemas(output.OutputSchemas, context) : undefined,
        Paths: output.Paths != null ? deserializeAws_json1_1EnclosedInStringProperties(output.Paths, context) : undefined,
    };
};
const deserializeAws_json1_1S3JsonSource = (output, context) => {
    return {
        AdditionalOptions: output.AdditionalOptions != null
            ? deserializeAws_json1_1S3DirectSourceAdditionalOptions(output.AdditionalOptions, context)
            : undefined,
        CompressionType: __expectString(output.CompressionType),
        Exclusions: output.Exclusions != null
            ? deserializeAws_json1_1EnclosedInStringProperties(output.Exclusions, context)
            : undefined,
        GroupFiles: __expectString(output.GroupFiles),
        GroupSize: __expectString(output.GroupSize),
        JsonPath: __expectString(output.JsonPath),
        MaxBand: __expectInt32(output.MaxBand),
        MaxFilesInBand: __expectInt32(output.MaxFilesInBand),
        Multiline: __expectBoolean(output.Multiline),
        Name: __expectString(output.Name),
        OutputSchemas: output.OutputSchemas != null ? deserializeAws_json1_1GlueSchemas(output.OutputSchemas, context) : undefined,
        Paths: output.Paths != null ? deserializeAws_json1_1EnclosedInStringProperties(output.Paths, context) : undefined,
        Recurse: __expectBoolean(output.Recurse),
    };
};
const deserializeAws_json1_1S3ParquetSource = (output, context) => {
    return {
        AdditionalOptions: output.AdditionalOptions != null
            ? deserializeAws_json1_1S3DirectSourceAdditionalOptions(output.AdditionalOptions, context)
            : undefined,
        CompressionType: __expectString(output.CompressionType),
        Exclusions: output.Exclusions != null
            ? deserializeAws_json1_1EnclosedInStringProperties(output.Exclusions, context)
            : undefined,
        GroupFiles: __expectString(output.GroupFiles),
        GroupSize: __expectString(output.GroupSize),
        MaxBand: __expectInt32(output.MaxBand),
        MaxFilesInBand: __expectInt32(output.MaxFilesInBand),
        Name: __expectString(output.Name),
        OutputSchemas: output.OutputSchemas != null ? deserializeAws_json1_1GlueSchemas(output.OutputSchemas, context) : undefined,
        Paths: output.Paths != null ? deserializeAws_json1_1EnclosedInStringProperties(output.Paths, context) : undefined,
        Recurse: __expectBoolean(output.Recurse),
    };
};
const deserializeAws_json1_1S3SourceAdditionalOptions = (output, context) => {
    return {
        BoundedFiles: __expectLong(output.BoundedFiles),
        BoundedSize: __expectLong(output.BoundedSize),
    };
};
const deserializeAws_json1_1S3Target = (output, context) => {
    return {
        ConnectionName: __expectString(output.ConnectionName),
        DlqEventQueueArn: __expectString(output.DlqEventQueueArn),
        EventQueueArn: __expectString(output.EventQueueArn),
        Exclusions: output.Exclusions != null ? deserializeAws_json1_1PathList(output.Exclusions, context) : undefined,
        Path: __expectString(output.Path),
        SampleSize: __expectInt32(output.SampleSize),
    };
};
const deserializeAws_json1_1S3TargetList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1S3Target(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1Schedule = (output, context) => {
    return {
        ScheduleExpression: __expectString(output.ScheduleExpression),
        State: __expectString(output.State),
    };
};
const deserializeAws_json1_1SchedulerNotRunningException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_1SchedulerRunningException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_1SchedulerTransitioningException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_1SchemaChangePolicy = (output, context) => {
    return {
        DeleteBehavior: __expectString(output.DeleteBehavior),
        UpdateBehavior: __expectString(output.UpdateBehavior),
    };
};
const deserializeAws_json1_1SchemaColumn = (output, context) => {
    return {
        DataType: __expectString(output.DataType),
        Name: __expectString(output.Name),
    };
};
const deserializeAws_json1_1SchemaId = (output, context) => {
    return {
        RegistryName: __expectString(output.RegistryName),
        SchemaArn: __expectString(output.SchemaArn),
        SchemaName: __expectString(output.SchemaName),
    };
};
const deserializeAws_json1_1SchemaListDefinition = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1SchemaListItem(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1SchemaListItem = (output, context) => {
    return {
        CreatedTime: __expectString(output.CreatedTime),
        Description: __expectString(output.Description),
        RegistryName: __expectString(output.RegistryName),
        SchemaArn: __expectString(output.SchemaArn),
        SchemaName: __expectString(output.SchemaName),
        SchemaStatus: __expectString(output.SchemaStatus),
        UpdatedTime: __expectString(output.UpdatedTime),
    };
};
const deserializeAws_json1_1SchemaReference = (output, context) => {
    return {
        SchemaId: output.SchemaId != null ? deserializeAws_json1_1SchemaId(output.SchemaId, context) : undefined,
        SchemaVersionId: __expectString(output.SchemaVersionId),
        SchemaVersionNumber: __expectLong(output.SchemaVersionNumber),
    };
};
const deserializeAws_json1_1SchemaVersionErrorItem = (output, context) => {
    return {
        ErrorDetails: output.ErrorDetails != null ? deserializeAws_json1_1ErrorDetails(output.ErrorDetails, context) : undefined,
        VersionNumber: __expectLong(output.VersionNumber),
    };
};
const deserializeAws_json1_1SchemaVersionErrorList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1SchemaVersionErrorItem(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1SchemaVersionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1SchemaVersionListItem(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1SchemaVersionListItem = (output, context) => {
    return {
        CreatedTime: __expectString(output.CreatedTime),
        SchemaArn: __expectString(output.SchemaArn),
        SchemaVersionId: __expectString(output.SchemaVersionId),
        Status: __expectString(output.Status),
        VersionNumber: __expectLong(output.VersionNumber),
    };
};
const deserializeAws_json1_1SearchTablesResponse = (output, context) => {
    return {
        NextToken: __expectString(output.NextToken),
        TableList: output.TableList != null ? deserializeAws_json1_1TableList(output.TableList, context) : undefined,
    };
};
const deserializeAws_json1_1SecurityConfiguration = (output, context) => {
    return {
        CreatedTimeStamp: output.CreatedTimeStamp != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedTimeStamp)))
            : undefined,
        EncryptionConfiguration: output.EncryptionConfiguration != null
            ? deserializeAws_json1_1EncryptionConfiguration(output.EncryptionConfiguration, context)
            : undefined,
        Name: __expectString(output.Name),
    };
};
const deserializeAws_json1_1SecurityConfigurationList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1SecurityConfiguration(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1SecurityGroupIdList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1SelectFields = (output, context) => {
    return {
        Inputs: output.Inputs != null ? deserializeAws_json1_1OneInput(output.Inputs, context) : undefined,
        Name: __expectString(output.Name),
        Paths: output.Paths != null ? deserializeAws_json1_1GlueStudioPathList(output.Paths, context) : undefined,
    };
};
const deserializeAws_json1_1SelectFromCollection = (output, context) => {
    return {
        Index: __expectInt32(output.Index),
        Inputs: output.Inputs != null ? deserializeAws_json1_1OneInput(output.Inputs, context) : undefined,
        Name: __expectString(output.Name),
    };
};
const deserializeAws_json1_1SerDeInfo = (output, context) => {
    return {
        Name: __expectString(output.Name),
        Parameters: output.Parameters != null ? deserializeAws_json1_1ParametersMap(output.Parameters, context) : undefined,
        SerializationLibrary: __expectString(output.SerializationLibrary),
    };
};
const deserializeAws_json1_1Session = (output, context) => {
    return {
        Command: output.Command != null ? deserializeAws_json1_1SessionCommand(output.Command, context) : undefined,
        Connections: output.Connections != null ? deserializeAws_json1_1ConnectionsList(output.Connections, context) : undefined,
        CreatedOn: output.CreatedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedOn))) : undefined,
        DefaultArguments: output.DefaultArguments != null
            ? deserializeAws_json1_1OrchestrationArgumentsMap(output.DefaultArguments, context)
            : undefined,
        Description: __expectString(output.Description),
        ErrorMessage: __expectString(output.ErrorMessage),
        GlueVersion: __expectString(output.GlueVersion),
        Id: __expectString(output.Id),
        MaxCapacity: __limitedParseDouble(output.MaxCapacity),
        Progress: __limitedParseDouble(output.Progress),
        Role: __expectString(output.Role),
        SecurityConfiguration: __expectString(output.SecurityConfiguration),
        Status: __expectString(output.Status),
    };
};
const deserializeAws_json1_1SessionCommand = (output, context) => {
    return {
        Name: __expectString(output.Name),
        PythonVersion: __expectString(output.PythonVersion),
    };
};
const deserializeAws_json1_1SessionIdList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1SessionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Session(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1SkewedInfo = (output, context) => {
    return {
        SkewedColumnNames: output.SkewedColumnNames != null
            ? deserializeAws_json1_1NameStringList(output.SkewedColumnNames, context)
            : undefined,
        SkewedColumnValueLocationMaps: output.SkewedColumnValueLocationMaps != null
            ? deserializeAws_json1_1LocationMap(output.SkewedColumnValueLocationMaps, context)
            : undefined,
        SkewedColumnValues: output.SkewedColumnValues != null
            ? deserializeAws_json1_1ColumnValueStringList(output.SkewedColumnValues, context)
            : undefined,
    };
};
const deserializeAws_json1_1SourceControlDetails = (output, context) => {
    return {
        AuthStrategy: __expectString(output.AuthStrategy),
        AuthToken: __expectString(output.AuthToken),
        Branch: __expectString(output.Branch),
        Folder: __expectString(output.Folder),
        LastCommitId: __expectString(output.LastCommitId),
        Owner: __expectString(output.Owner),
        Provider: __expectString(output.Provider),
        Repository: __expectString(output.Repository),
    };
};
const deserializeAws_json1_1SparkConnectorSource = (output, context) => {
    return {
        AdditionalOptions: output.AdditionalOptions != null
            ? deserializeAws_json1_1AdditionalOptions(output.AdditionalOptions, context)
            : undefined,
        ConnectionName: __expectString(output.ConnectionName),
        ConnectionType: __expectString(output.ConnectionType),
        ConnectorName: __expectString(output.ConnectorName),
        Name: __expectString(output.Name),
        OutputSchemas: output.OutputSchemas != null ? deserializeAws_json1_1GlueSchemas(output.OutputSchemas, context) : undefined,
    };
};
const deserializeAws_json1_1SparkConnectorTarget = (output, context) => {
    return {
        AdditionalOptions: output.AdditionalOptions != null
            ? deserializeAws_json1_1AdditionalOptions(output.AdditionalOptions, context)
            : undefined,
        ConnectionName: __expectString(output.ConnectionName),
        ConnectionType: __expectString(output.ConnectionType),
        ConnectorName: __expectString(output.ConnectorName),
        Inputs: output.Inputs != null ? deserializeAws_json1_1OneInput(output.Inputs, context) : undefined,
        Name: __expectString(output.Name),
        OutputSchemas: output.OutputSchemas != null ? deserializeAws_json1_1GlueSchemas(output.OutputSchemas, context) : undefined,
    };
};
const deserializeAws_json1_1SparkSQL = (output, context) => {
    return {
        Inputs: output.Inputs != null ? deserializeAws_json1_1ManyInputs(output.Inputs, context) : undefined,
        Name: __expectString(output.Name),
        OutputSchemas: output.OutputSchemas != null ? deserializeAws_json1_1GlueSchemas(output.OutputSchemas, context) : undefined,
        SqlAliases: output.SqlAliases != null ? deserializeAws_json1_1SqlAliases(output.SqlAliases, context) : undefined,
        SqlQuery: __expectString(output.SqlQuery),
    };
};
const deserializeAws_json1_1Spigot = (output, context) => {
    return {
        Inputs: output.Inputs != null ? deserializeAws_json1_1OneInput(output.Inputs, context) : undefined,
        Name: __expectString(output.Name),
        Path: __expectString(output.Path),
        Prob: __limitedParseDouble(output.Prob),
        Topk: __expectInt32(output.Topk),
    };
};
const deserializeAws_json1_1SplitFields = (output, context) => {
    return {
        Inputs: output.Inputs != null ? deserializeAws_json1_1OneInput(output.Inputs, context) : undefined,
        Name: __expectString(output.Name),
        Paths: output.Paths != null ? deserializeAws_json1_1GlueStudioPathList(output.Paths, context) : undefined,
    };
};
const deserializeAws_json1_1SqlAlias = (output, context) => {
    return {
        Alias: __expectString(output.Alias),
        From: __expectString(output.From),
    };
};
const deserializeAws_json1_1SqlAliases = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1SqlAlias(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1StartBlueprintRunResponse = (output, context) => {
    return {
        RunId: __expectString(output.RunId),
    };
};
const deserializeAws_json1_1StartCrawlerResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1StartCrawlerScheduleResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1StartDataQualityRuleRecommendationRunResponse = (output, context) => {
    return {
        RunId: __expectString(output.RunId),
    };
};
const deserializeAws_json1_1StartDataQualityRulesetEvaluationRunResponse = (output, context) => {
    return {
        RunId: __expectString(output.RunId),
    };
};
const deserializeAws_json1_1StartExportLabelsTaskRunResponse = (output, context) => {
    return {
        TaskRunId: __expectString(output.TaskRunId),
    };
};
const deserializeAws_json1_1StartImportLabelsTaskRunResponse = (output, context) => {
    return {
        TaskRunId: __expectString(output.TaskRunId),
    };
};
const deserializeAws_json1_1StartingEventBatchCondition = (output, context) => {
    return {
        BatchSize: __expectInt32(output.BatchSize),
        BatchWindow: __expectInt32(output.BatchWindow),
    };
};
const deserializeAws_json1_1StartJobRunResponse = (output, context) => {
    return {
        JobRunId: __expectString(output.JobRunId),
    };
};
const deserializeAws_json1_1StartMLEvaluationTaskRunResponse = (output, context) => {
    return {
        TaskRunId: __expectString(output.TaskRunId),
    };
};
const deserializeAws_json1_1StartMLLabelingSetGenerationTaskRunResponse = (output, context) => {
    return {
        TaskRunId: __expectString(output.TaskRunId),
    };
};
const deserializeAws_json1_1StartTriggerResponse = (output, context) => {
    return {
        Name: __expectString(output.Name),
    };
};
const deserializeAws_json1_1StartWorkflowRunResponse = (output, context) => {
    return {
        RunId: __expectString(output.RunId),
    };
};
const deserializeAws_json1_1Statement = (output, context) => {
    return {
        Code: __expectString(output.Code),
        CompletedOn: __expectLong(output.CompletedOn),
        Id: __expectInt32(output.Id),
        Output: output.Output != null ? deserializeAws_json1_1StatementOutput(output.Output, context) : undefined,
        Progress: __limitedParseDouble(output.Progress),
        StartedOn: __expectLong(output.StartedOn),
        State: __expectString(output.State),
    };
};
const deserializeAws_json1_1StatementList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Statement(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1StatementOutput = (output, context) => {
    return {
        Data: output.Data != null ? deserializeAws_json1_1StatementOutputData(output.Data, context) : undefined,
        ErrorName: __expectString(output.ErrorName),
        ErrorValue: __expectString(output.ErrorValue),
        ExecutionCount: __expectInt32(output.ExecutionCount),
        Status: __expectString(output.Status),
        Traceback: output.Traceback != null ? deserializeAws_json1_1OrchestrationStringList(output.Traceback, context) : undefined,
    };
};
const deserializeAws_json1_1StatementOutputData = (output, context) => {
    return {
        TextPlain: __expectString(output.TextPlain),
    };
};
const deserializeAws_json1_1StopCrawlerResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1StopCrawlerScheduleResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1StopSessionResponse = (output, context) => {
    return {
        Id: __expectString(output.Id),
    };
};
const deserializeAws_json1_1StopTriggerResponse = (output, context) => {
    return {
        Name: __expectString(output.Name),
    };
};
const deserializeAws_json1_1StopWorkflowRunResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1StorageDescriptor = (output, context) => {
    return {
        AdditionalLocations: output.AdditionalLocations != null
            ? deserializeAws_json1_1LocationStringList(output.AdditionalLocations, context)
            : undefined,
        BucketColumns: output.BucketColumns != null ? deserializeAws_json1_1NameStringList(output.BucketColumns, context) : undefined,
        Columns: output.Columns != null ? deserializeAws_json1_1ColumnList(output.Columns, context) : undefined,
        Compressed: __expectBoolean(output.Compressed),
        InputFormat: __expectString(output.InputFormat),
        Location: __expectString(output.Location),
        NumberOfBuckets: __expectInt32(output.NumberOfBuckets),
        OutputFormat: __expectString(output.OutputFormat),
        Parameters: output.Parameters != null ? deserializeAws_json1_1ParametersMap(output.Parameters, context) : undefined,
        SchemaReference: output.SchemaReference != null
            ? deserializeAws_json1_1SchemaReference(output.SchemaReference, context)
            : undefined,
        SerdeInfo: output.SerdeInfo != null ? deserializeAws_json1_1SerDeInfo(output.SerdeInfo, context) : undefined,
        SkewedInfo: output.SkewedInfo != null ? deserializeAws_json1_1SkewedInfo(output.SkewedInfo, context) : undefined,
        SortColumns: output.SortColumns != null ? deserializeAws_json1_1OrderList(output.SortColumns, context) : undefined,
        StoredAsSubDirectories: __expectBoolean(output.StoredAsSubDirectories),
    };
};
const deserializeAws_json1_1StreamingDataPreviewOptions = (output, context) => {
    return {
        PollingTime: __expectLong(output.PollingTime),
        RecordPollingLimit: __expectLong(output.RecordPollingLimit),
    };
};
const deserializeAws_json1_1StringColumnStatisticsData = (output, context) => {
    return {
        AverageLength: __limitedParseDouble(output.AverageLength),
        MaximumLength: __expectLong(output.MaximumLength),
        NumberOfDistinctValues: __expectLong(output.NumberOfDistinctValues),
        NumberOfNulls: __expectLong(output.NumberOfNulls),
    };
};
const deserializeAws_json1_1StringList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1Table = (output, context) => {
    return {
        CatalogId: __expectString(output.CatalogId),
        CreateTime: output.CreateTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreateTime))) : undefined,
        CreatedBy: __expectString(output.CreatedBy),
        DatabaseName: __expectString(output.DatabaseName),
        Description: __expectString(output.Description),
        IsRegisteredWithLakeFormation: __expectBoolean(output.IsRegisteredWithLakeFormation),
        LastAccessTime: output.LastAccessTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastAccessTime)))
            : undefined,
        LastAnalyzedTime: output.LastAnalyzedTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastAnalyzedTime)))
            : undefined,
        Name: __expectString(output.Name),
        Owner: __expectString(output.Owner),
        Parameters: output.Parameters != null ? deserializeAws_json1_1ParametersMap(output.Parameters, context) : undefined,
        PartitionKeys: output.PartitionKeys != null ? deserializeAws_json1_1ColumnList(output.PartitionKeys, context) : undefined,
        Retention: __expectInt32(output.Retention),
        StorageDescriptor: output.StorageDescriptor != null
            ? deserializeAws_json1_1StorageDescriptor(output.StorageDescriptor, context)
            : undefined,
        TableType: __expectString(output.TableType),
        TargetTable: output.TargetTable != null ? deserializeAws_json1_1TableIdentifier(output.TargetTable, context) : undefined,
        UpdateTime: output.UpdateTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.UpdateTime))) : undefined,
        VersionId: __expectString(output.VersionId),
        ViewExpandedText: __expectString(output.ViewExpandedText),
        ViewOriginalText: __expectString(output.ViewOriginalText),
    };
};
const deserializeAws_json1_1TableError = (output, context) => {
    return {
        ErrorDetail: output.ErrorDetail != null ? deserializeAws_json1_1ErrorDetail(output.ErrorDetail, context) : undefined,
        TableName: __expectString(output.TableName),
    };
};
const deserializeAws_json1_1TableErrors = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1TableError(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1TableIdentifier = (output, context) => {
    return {
        CatalogId: __expectString(output.CatalogId),
        DatabaseName: __expectString(output.DatabaseName),
        Name: __expectString(output.Name),
    };
};
const deserializeAws_json1_1TableList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Table(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1TableVersion = (output, context) => {
    return {
        Table: output.Table != null ? deserializeAws_json1_1Table(output.Table, context) : undefined,
        VersionId: __expectString(output.VersionId),
    };
};
const deserializeAws_json1_1TableVersionError = (output, context) => {
    return {
        ErrorDetail: output.ErrorDetail != null ? deserializeAws_json1_1ErrorDetail(output.ErrorDetail, context) : undefined,
        TableName: __expectString(output.TableName),
        VersionId: __expectString(output.VersionId),
    };
};
const deserializeAws_json1_1TableVersionErrors = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1TableVersionError(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1TagResourceResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1TagsMap = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = __expectString(value);
        return acc;
    }, {});
};
const deserializeAws_json1_1TaskRun = (output, context) => {
    return {
        CompletedOn: output.CompletedOn != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CompletedOn)))
            : undefined,
        ErrorString: __expectString(output.ErrorString),
        ExecutionTime: __expectInt32(output.ExecutionTime),
        LastModifiedOn: output.LastModifiedOn != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedOn)))
            : undefined,
        LogGroupName: __expectString(output.LogGroupName),
        Properties: output.Properties != null ? deserializeAws_json1_1TaskRunProperties(output.Properties, context) : undefined,
        StartedOn: output.StartedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartedOn))) : undefined,
        Status: __expectString(output.Status),
        TaskRunId: __expectString(output.TaskRunId),
        TransformId: __expectString(output.TransformId),
    };
};
const deserializeAws_json1_1TaskRunList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1TaskRun(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1TaskRunProperties = (output, context) => {
    return {
        ExportLabelsTaskRunProperties: output.ExportLabelsTaskRunProperties != null
            ? deserializeAws_json1_1ExportLabelsTaskRunProperties(output.ExportLabelsTaskRunProperties, context)
            : undefined,
        FindMatchesTaskRunProperties: output.FindMatchesTaskRunProperties != null
            ? deserializeAws_json1_1FindMatchesTaskRunProperties(output.FindMatchesTaskRunProperties, context)
            : undefined,
        ImportLabelsTaskRunProperties: output.ImportLabelsTaskRunProperties != null
            ? deserializeAws_json1_1ImportLabelsTaskRunProperties(output.ImportLabelsTaskRunProperties, context)
            : undefined,
        LabelingSetGenerationTaskRunProperties: output.LabelingSetGenerationTaskRunProperties != null
            ? deserializeAws_json1_1LabelingSetGenerationTaskRunProperties(output.LabelingSetGenerationTaskRunProperties, context)
            : undefined,
        TaskType: __expectString(output.TaskType),
    };
};
const deserializeAws_json1_1TransformConfigParameter = (output, context) => {
    return {
        IsOptional: __expectBoolean(output.IsOptional),
        ListType: __expectString(output.ListType),
        Name: __expectString(output.Name),
        Type: __expectString(output.Type),
        ValidationMessage: __expectString(output.ValidationMessage),
        ValidationRule: __expectString(output.ValidationRule),
        Value: output.Value != null ? deserializeAws_json1_1EnclosedInStringProperties(output.Value, context) : undefined,
    };
};
const deserializeAws_json1_1TransformConfigParameterList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1TransformConfigParameter(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1TransformEncryption = (output, context) => {
    return {
        MlUserDataEncryption: output.MlUserDataEncryption != null
            ? deserializeAws_json1_1MLUserDataEncryption(output.MlUserDataEncryption, context)
            : undefined,
        TaskRunSecurityConfigurationName: __expectString(output.TaskRunSecurityConfigurationName),
    };
};
const deserializeAws_json1_1TransformIdList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1TransformList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1MLTransform(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1TransformParameters = (output, context) => {
    return {
        FindMatchesParameters: output.FindMatchesParameters != null
            ? deserializeAws_json1_1FindMatchesParameters(output.FindMatchesParameters, context)
            : undefined,
        TransformType: __expectString(output.TransformType),
    };
};
const deserializeAws_json1_1TransformSchema = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1SchemaColumn(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1Trigger = (output, context) => {
    return {
        Actions: output.Actions != null ? deserializeAws_json1_1ActionList(output.Actions, context) : undefined,
        Description: __expectString(output.Description),
        EventBatchingCondition: output.EventBatchingCondition != null
            ? deserializeAws_json1_1EventBatchingCondition(output.EventBatchingCondition, context)
            : undefined,
        Id: __expectString(output.Id),
        Name: __expectString(output.Name),
        Predicate: output.Predicate != null ? deserializeAws_json1_1Predicate(output.Predicate, context) : undefined,
        Schedule: __expectString(output.Schedule),
        State: __expectString(output.State),
        Type: __expectString(output.Type),
        WorkflowName: __expectString(output.WorkflowName),
    };
};
const deserializeAws_json1_1TriggerList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Trigger(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1TriggerNameList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1TriggerNodeDetails = (output, context) => {
    return {
        Trigger: output.Trigger != null ? deserializeAws_json1_1Trigger(output.Trigger, context) : undefined,
    };
};
const deserializeAws_json1_1TwoInputs = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1UnfilteredPartition = (output, context) => {
    return {
        AuthorizedColumns: output.AuthorizedColumns != null
            ? deserializeAws_json1_1NameStringList(output.AuthorizedColumns, context)
            : undefined,
        IsRegisteredWithLakeFormation: __expectBoolean(output.IsRegisteredWithLakeFormation),
        Partition: output.Partition != null ? deserializeAws_json1_1Partition(output.Partition, context) : undefined,
    };
};
const deserializeAws_json1_1UnfilteredPartitionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1UnfilteredPartition(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1Union = (output, context) => {
    return {
        Inputs: output.Inputs != null ? deserializeAws_json1_1TwoInputs(output.Inputs, context) : undefined,
        Name: __expectString(output.Name),
        UnionType: __expectString(output.UnionType),
    };
};
const deserializeAws_json1_1UntagResourceResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1UpdateBlueprintResponse = (output, context) => {
    return {
        Name: __expectString(output.Name),
    };
};
const deserializeAws_json1_1UpdateClassifierResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1UpdateColumnStatisticsForPartitionResponse = (output, context) => {
    return {
        Errors: output.Errors != null ? deserializeAws_json1_1ColumnStatisticsErrors(output.Errors, context) : undefined,
    };
};
const deserializeAws_json1_1UpdateColumnStatisticsForTableResponse = (output, context) => {
    return {
        Errors: output.Errors != null ? deserializeAws_json1_1ColumnStatisticsErrors(output.Errors, context) : undefined,
    };
};
const deserializeAws_json1_1UpdateConnectionResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1UpdateCrawlerResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1UpdateCrawlerScheduleResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1UpdateDatabaseResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1UpdateDataQualityRulesetResponse = (output, context) => {
    return {
        Description: __expectString(output.Description),
        Name: __expectString(output.Name),
        Ruleset: __expectString(output.Ruleset),
    };
};
const deserializeAws_json1_1UpdateDevEndpointResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1UpdateJobFromSourceControlResponse = (output, context) => {
    return {
        JobName: __expectString(output.JobName),
    };
};
const deserializeAws_json1_1UpdateJobResponse = (output, context) => {
    return {
        JobName: __expectString(output.JobName),
    };
};
const deserializeAws_json1_1UpdateMLTransformResponse = (output, context) => {
    return {
        TransformId: __expectString(output.TransformId),
    };
};
const deserializeAws_json1_1UpdatePartitionResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1UpdateRegistryResponse = (output, context) => {
    return {
        RegistryArn: __expectString(output.RegistryArn),
        RegistryName: __expectString(output.RegistryName),
    };
};
const deserializeAws_json1_1UpdateSchemaResponse = (output, context) => {
    return {
        RegistryName: __expectString(output.RegistryName),
        SchemaArn: __expectString(output.SchemaArn),
        SchemaName: __expectString(output.SchemaName),
    };
};
const deserializeAws_json1_1UpdateSourceControlFromJobResponse = (output, context) => {
    return {
        JobName: __expectString(output.JobName),
    };
};
const deserializeAws_json1_1UpdateTableResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1UpdateTriggerResponse = (output, context) => {
    return {
        Trigger: output.Trigger != null ? deserializeAws_json1_1Trigger(output.Trigger, context) : undefined,
    };
};
const deserializeAws_json1_1UpdateUserDefinedFunctionResponse = (output, context) => {
    return {};
};
const deserializeAws_json1_1UpdateWorkflowResponse = (output, context) => {
    return {
        Name: __expectString(output.Name),
    };
};
const deserializeAws_json1_1UpsertRedshiftTargetOptions = (output, context) => {
    return {
        ConnectionName: __expectString(output.ConnectionName),
        TableLocation: __expectString(output.TableLocation),
        UpsertKeys: output.UpsertKeys != null
            ? deserializeAws_json1_1EnclosedInStringPropertiesMinOne(output.UpsertKeys, context)
            : undefined,
    };
};
const deserializeAws_json1_1UserDefinedFunction = (output, context) => {
    return {
        CatalogId: __expectString(output.CatalogId),
        ClassName: __expectString(output.ClassName),
        CreateTime: output.CreateTime != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreateTime))) : undefined,
        DatabaseName: __expectString(output.DatabaseName),
        FunctionName: __expectString(output.FunctionName),
        OwnerName: __expectString(output.OwnerName),
        OwnerType: __expectString(output.OwnerType),
        ResourceUris: output.ResourceUris != null ? deserializeAws_json1_1ResourceUriList(output.ResourceUris, context) : undefined,
    };
};
const deserializeAws_json1_1UserDefinedFunctionList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1UserDefinedFunction(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1ValidationException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_1ValueStringList = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1VersionMismatchException = (output, context) => {
    return {
        Message: __expectString(output.Message),
    };
};
const deserializeAws_json1_1Workflow = (output, context) => {
    return {
        BlueprintDetails: output.BlueprintDetails != null
            ? deserializeAws_json1_1BlueprintDetails(output.BlueprintDetails, context)
            : undefined,
        CreatedOn: output.CreatedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreatedOn))) : undefined,
        DefaultRunProperties: output.DefaultRunProperties != null
            ? deserializeAws_json1_1WorkflowRunProperties(output.DefaultRunProperties, context)
            : undefined,
        Description: __expectString(output.Description),
        Graph: output.Graph != null ? deserializeAws_json1_1WorkflowGraph(output.Graph, context) : undefined,
        LastModifiedOn: output.LastModifiedOn != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastModifiedOn)))
            : undefined,
        LastRun: output.LastRun != null ? deserializeAws_json1_1WorkflowRun(output.LastRun, context) : undefined,
        MaxConcurrentRuns: __expectInt32(output.MaxConcurrentRuns),
        Name: __expectString(output.Name),
    };
};
const deserializeAws_json1_1WorkflowGraph = (output, context) => {
    return {
        Edges: output.Edges != null ? deserializeAws_json1_1EdgeList(output.Edges, context) : undefined,
        Nodes: output.Nodes != null ? deserializeAws_json1_1NodeList(output.Nodes, context) : undefined,
    };
};
const deserializeAws_json1_1WorkflowNames = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return __expectString(entry);
    });
    return retVal;
};
const deserializeAws_json1_1WorkflowRun = (output, context) => {
    return {
        CompletedOn: output.CompletedOn != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CompletedOn)))
            : undefined,
        ErrorMessage: __expectString(output.ErrorMessage),
        Graph: output.Graph != null ? deserializeAws_json1_1WorkflowGraph(output.Graph, context) : undefined,
        Name: __expectString(output.Name),
        PreviousRunId: __expectString(output.PreviousRunId),
        StartedOn: output.StartedOn != null ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.StartedOn))) : undefined,
        StartingEventBatchCondition: output.StartingEventBatchCondition != null
            ? deserializeAws_json1_1StartingEventBatchCondition(output.StartingEventBatchCondition, context)
            : undefined,
        Statistics: output.Statistics != null ? deserializeAws_json1_1WorkflowRunStatistics(output.Statistics, context) : undefined,
        Status: __expectString(output.Status),
        WorkflowRunId: __expectString(output.WorkflowRunId),
        WorkflowRunProperties: output.WorkflowRunProperties != null
            ? deserializeAws_json1_1WorkflowRunProperties(output.WorkflowRunProperties, context)
            : undefined,
    };
};
const deserializeAws_json1_1WorkflowRunProperties = (output, context) => {
    return Object.entries(output).reduce((acc, [key, value]) => {
        if (value === null) {
            return acc;
        }
        acc[key] = __expectString(value);
        return acc;
    }, {});
};
const deserializeAws_json1_1WorkflowRuns = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1WorkflowRun(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1WorkflowRunStatistics = (output, context) => {
    return {
        ErroredActions: __expectInt32(output.ErroredActions),
        FailedActions: __expectInt32(output.FailedActions),
        RunningActions: __expectInt32(output.RunningActions),
        StoppedActions: __expectInt32(output.StoppedActions),
        SucceededActions: __expectInt32(output.SucceededActions),
        TimeoutActions: __expectInt32(output.TimeoutActions),
        TotalActions: __expectInt32(output.TotalActions),
        WaitingActions: __expectInt32(output.WaitingActions),
    };
};
const deserializeAws_json1_1Workflows = (output, context) => {
    const retVal = (output || [])
        .filter((e) => e != null)
        .map((entry) => {
        if (entry === null) {
            return null;
        }
        return deserializeAws_json1_1Workflow(entry, context);
    });
    return retVal;
};
const deserializeAws_json1_1XMLClassifier = (output, context) => {
    return {
        Classification: __expectString(output.Classification),
        CreationTime: output.CreationTime != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.CreationTime)))
            : undefined,
        LastUpdated: output.LastUpdated != null
            ? __expectNonNull(__parseEpochTimestamp(__expectNumber(output.LastUpdated)))
            : undefined,
        Name: __expectString(output.Name),
        RowTag: __expectString(output.RowTag),
        Version: __expectLong(output.Version),
    };
};
const deserializeMetadata = (output) => ({
    httpStatusCode: output.statusCode,
    requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
    extendedRequestId: output.headers["x-amz-id-2"],
    cfId: output.headers["x-amz-cf-id"],
});
const collectBody = (streamBody = new Uint8Array(), context) => {
    if (streamBody instanceof Uint8Array) {
        return Promise.resolve(streamBody);
    }
    return context.streamCollector(streamBody) || Promise.resolve(new Uint8Array());
};
const collectBodyString = (streamBody, context) => collectBody(streamBody, context).then((body) => context.utf8Encoder(body));
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body) => {
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers,
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new __HttpRequest(contents);
};
const parseBody = (streamBody, context) => collectBodyString(streamBody, context).then((encoded) => {
    if (encoded.length) {
        return JSON.parse(encoded);
    }
    return {};
});
const parseErrorBody = async (errorBody, context) => {
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data) => {
    const findKey = (object, key) => Object.keys(object).find((k) => k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue) => {
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};
